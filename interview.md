![memes](https://github.com/Swfuse/devops-interview/blob/main/imgs/memes.jpg)  
<!-- TOC -->

- [Вопросы админам 2.0](#%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B0%D0%BC-20)
    - [Железячные вопросы](#%D0%B6%D0%B5%D0%BB%D0%B5%D0%B7%D1%8F%D1%87%D0%BD%D1%8B%D0%B5-%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B)
        - [Сервер не отвечает, как можно получить доступ к серверу, не находясь непосредственно в ЦОДЕ](#%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D0%BD%D0%B5-%D0%BE%D1%82%D0%B2%D0%B5%D1%87%D0%B0%D0%B5%D1%82-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B8%D1%82%D1%8C-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D1%83-%D0%BD%D0%B5-%D0%BD%D0%B0%D1%85%D0%BE%D0%B4%D1%8F%D1%81%D1%8C-%D0%BD%D0%B5%D0%BF%D0%BE%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE-%D0%B2-%D1%86%D0%BE%D0%B4%D0%B5)
        - [Что такое kvmне гипервизор? Как можно его использовать?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-kvm%D0%BD%D0%B5-%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D0%B7%D0%BE%D1%80-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C)
        - [Что такое IPMI? Какие подсистемы он в себя включает?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-ipmi-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B4%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%BE%D0%BD-%D0%B2-%D1%81%D0%B5%D0%B1%D1%8F-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D1%82)
        - [Какие преимущества предоставляет IPMI в сравнении с kvm?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82-ipmi-%D0%B2-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D1%81-kvm)
    - [Просмотр информации о железной составляющей сервера](#%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE-%D0%B6%D0%B5%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D0%B9-%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B5%D0%B9-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0)
        - [Модели процессора, количестве физических и логических ядер, поддерживаемых инструкциях, режиме работы?](#%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0-%D0%BA%D0%BE%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B5-%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D0%B8-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D1%8F%D0%B4%D0%B5%D1%80-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC%D1%8B%D1%85-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F%D1%85-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)
        - [Типы оперативной памяти, модели материнской платы, версии BIOS?](#%D1%82%D0%B8%D0%BF%D1%8B-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B9-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%BD%D1%81%D0%BA%D0%BE%D0%B9-%D0%BF%D0%BB%D0%B0%D1%82%D1%8B-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8-bios)
        - [Текущих значениях датчиков напряжения, температуры, оборотов вентиляторов?](#%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B8%D1%85-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%D1%85-%D0%B4%D0%B0%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2-%D0%BD%D0%B0%D0%BF%D1%80%D1%8F%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D1%83%D1%80%D1%8B-%D0%BE%D0%B1%D0%BE%D1%80%D0%BE%D1%82%D0%BE%D0%B2-%D0%B2%D0%B5%D0%BD%D1%82%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%BE%D0%B2)
        - [Типе используемого сетевого адаптера и состоянии его интерфейсов?](#%D1%82%D0%B8%D0%BF%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D0%BE%D0%B3%D0%BE-%D1%81%D0%B5%D1%82%D0%B5%D0%B2%D0%BE%D0%B3%D0%BE-%D0%B0%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80%D0%B0-%D0%B8-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2)
        - [Подключённых USB и PCI устройствах?](#%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D1%91%D0%BD%D0%BD%D1%8B%D1%85-usb-%D0%B8-pci-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0%D1%85)
    - [Linux](#linux)
        - [Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания.](#%D1%80%D0%B0%D1%81%D1%81%D0%BA%D0%B0%D0%B6%D0%B8-%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8-%D0%BE%D1%81-linux-%D1%81-%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-%D0%BD%D0%B0%D0%B6%D0%B0%D1%82%D0%B8%D1%8F-%D0%BA%D0%BD%D0%BE%D0%BF%D0%BA%D0%B8-%D0%BF%D0%B8%D1%82%D0%B0%D0%BD%D0%B8%D1%8F)
        - [Что за процессы в Linux c PID 0 и 1](#%D1%87%D1%82%D0%BE-%D0%B7%D0%B0-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%D0%B2-linux-c-pid-0-%D0%B8-1)
        - [Что такое POSIX](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-posix)
        - [Интерфейс портативных операционных систем POSIX](#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81-%D0%BF%D0%BE%D1%80%D1%82%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC-posix)
        - [Что такое уровни выполнения run levels в Linux](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B8-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-run-levels-%D0%B2-linux)
        - [Описание уровней выполнения](#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B9-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Примечания к уровням выполнения](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F%D0%BC-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Какие основные части компоненты включает в себя система на базе дистрибутива linux?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%B5%D1%82-%D0%B2-%D1%81%D0%B5%D0%B1%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%BD%D0%B0-%D0%B1%D0%B0%D0%B7%D0%B5-%D0%B4%D0%B8%D1%81%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%B8%D0%B2%D0%B0-linux)
        - [Что такое BIOS, UEFI? Основы и различия](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-bios-uefi-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B8-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
            - [BIOS Basic Input-Output System](#bios-basic-input-output-system)
            - [Ограничения BIOS:](#%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-bios)
            - [UEFI Unified Extensible Firmware Interface](#uefi-unified-extensible-firmware-interface)
            - [Преимущества UEFI по сравнению с BIOS:](#%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-uefi-%D0%BF%D0%BE-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8E-%D1%81-bios)
            - [Заключение](#%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
        - [Что такое PXE? Как загрузиться по сети?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-pxe-%D0%BA%D0%B0%D0%BA-%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%B8%D1%82%D1%8C%D1%81%D1%8F-%D0%BF%D0%BE-%D1%81%D0%B5%D1%82%D0%B8)
            - [Как работает PXE:](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-pxe)
            - [Преимущества PXE:](#%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0-pxe)
            - [Настройка PXE-загрузки:](#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-pxe-%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8)
            - [Примечание:](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D0%B5)
        - [Что такое ядро, initramfs, загрузчик?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%8F%D0%B4%D1%80%D0%BE-initramfs-%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D1%87%D0%B8%D0%BA)
        - [Зачем нужна система инициализации? Какие системы инициализации используются в современных дистрибутивах? 2 - 5 штук init](#%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D0%B2-%D1%81%D0%BE%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B4%D0%B8%D1%81%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%B8%D0%B2%D0%B0%D1%85-2---5-%D1%88%D1%82%D1%83%D0%BA-init)
        - [Что такое systemd и init ? В чем основное преимущество первого над вторым ?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-systemd-%D0%B8-init--%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE-%D0%BD%D0%B0%D0%B4-%D0%B2%D1%82%D0%BE%D1%80%D1%8B%D0%BC-)
        - [Как понять используется ли в системе systemd?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D1%8C-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-%D0%BB%D0%B8-%D0%B2-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-systemd)
        - [Опишите, что происходит с точки зрения процессов, при выполнении любой команды в консоли, например:](#%D0%BE%D0%BF%D0%B8%D1%88%D0%B8%D1%82%D0%B5-%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D1%81-%D1%82%D0%BE%D1%87%D0%BA%D0%B8-%D0%B7%D1%80%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2-%D0%BF%D1%80%D0%B8-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BB%D1%8E%D0%B1%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8-%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
        - [Как посмотреть нагрузку на диски?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D1%82%D1%8C-%D0%BD%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D1%83-%D0%BD%D0%B0-%D0%B4%D0%B8%D1%81%D0%BA%D0%B8)
        - [В чем разница между объявлением переменной export VAR="VALUE" и VAR="VALUE" в bash?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9-export-varvalue-%D0%B8-varvalue-%D0%B2-bash)
        - [Что значит $@, $!, $?, $$ в bash?](#%D1%87%D1%82%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82-----%D0%B2-bash)
        - [Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки STDERR, игнорируя STDOUT?](#%D0%BA%D0%B0%D0%BA-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D1%8C-%D1%84%D0%B8%D0%BB%D1%8C%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8E-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-%D0%BD%D0%B0-%D1%8D%D0%BA%D1%80%D0%B0%D0%BD-%D0%B1%D1%8B%D0%BB%D0%B8-%D0%B2%D1%8B%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D1%8B-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8-stderr-%D0%B8%D0%B3%D0%BD%D0%BE%D1%80%D0%B8%D1%80%D1%83%D1%8F-stdout)
        - [При перенаправлении команд command1 | command2  перенаправляется только stdout. Как сделать так, чтобы stderr тоже перенаправлялся?](#%D0%BF%D1%80%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4-command1--command2--%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-stdout-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%82%D0%B0%D0%BA-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-stderr-%D1%82%D0%BE%D0%B6%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D0%BB%D1%81%D1%8F)
        - [Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D1%82%D1%8C-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80%D0%B0-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D1%82%D1%8C-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B5%D0%B9-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0)
        - [Как работает sudo? Для чего она используется?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-sudo-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BE%D0%BD%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F)
        - [Что такое userspace, kernelspace? Чем они отличаются?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-userspace-kernelspace-%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F)
        - [Что такое системные вызовы? Зачем они нужны и как они работают? Какие системные вызовы знаешь 5-10](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D1%8B-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B8-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D0%B8-%D0%BA%D0%B0%D0%BA-%D0%BE%D0%BD%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D1%8B-%D0%B7%D0%BD%D0%B0%D0%B5%D1%88%D1%8C-5-10)
        - [Где можно найти информацию о конкретном системном вызове?](#%D0%B3%D0%B4%D0%B5-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8E-%D0%BE-%D0%BA%D0%BE%D0%BD%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%BC-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D0%BE%D0%BC-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B5)
        - [Что делает команда kill?](#%D1%87%D1%82%D0%BE-%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D1%82-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0-kill)
        - [В чем разница между одинарными кавычками ' и двойными кавычками "?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BE%D0%B4%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BA%D0%B0%D0%B2%D1%8B%D1%87%D0%BA%D0%B0%D0%BC%D0%B8--%D0%B8-%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BA%D0%B0%D0%B2%D1%8B%D1%87%D0%BA%D0%B0%D0%BC%D0%B8-)
        - [Приложение запущено как сервис - как посмотреть то, что оно написало в stdout?](#%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BF%D1%83%D1%89%D0%B5%D0%BD%D0%BE-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81---%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D1%82%D1%8C-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%BE%D0%BD%D0%BE-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BB%D0%BE-%D0%B2-stdout)
        - [Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией?](#%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B0%D1%8F-load-average-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B5---900-900-900-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D1%81-%D0%BD%D0%B5%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BF%D0%BE%D1%82%D0%B5%D1%80%D0%B5%D0%B9-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D1%8C-%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%BB%D0%B8-%D1%8D%D1%82%D0%BE-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D1%81%D0%B8%D1%82%D1%83%D0%B0%D1%86%D0%B8%D0%B5%D0%B9)
        - [Что такое процесс? Что такое тред? В чем заключаются их главные отличия?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%82%D1%80%D0%B5%D0%B4-%D0%B2-%D1%87%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%B8%D1%85-%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%8F)
        - [Где в linux хранится информация о процессах?](#%D0%B3%D0%B4%D0%B5-%D0%B2-linux-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D1%82%D1%81%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0%D1%85)
        - [Приложение пишет в логи too many opened files, как это диагностировать?](#%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B8%D1%88%D0%B5%D1%82-%D0%B2-%D0%BB%D0%BE%D0%B3%D0%B8-too-many-opened-files-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D0%B4%D0%B8%D0%B0%D0%B3%D0%BD%D0%BE%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C)
        - [Как заставить приложение перестать писать в файл, не завершая процесс?](#%D0%BA%D0%B0%D0%BA-%D0%B7%D0%B0%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D1%82%D0%B0%D1%82%D1%8C-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%B2-%D1%84%D0%B0%D0%B9%D0%BB-%D0%BD%D0%B5-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B0%D1%8F-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81)
        - [Что такое CPU pinning](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-cpu-pinning)
        - [Какие алгоритмы планирования ресурсов в linux ты знаешь](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2-%D0%B2-linux-%D1%82%D1%8B-%D0%B7%D0%BD%D0%B0%D0%B5%D1%88%D1%8C)
        - [Представлен вывод команды top. Что означает каждая запись в выводе?](#%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-top-%D1%87%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D0%BA%D0%B0%D0%B6%D0%B4%D0%B0%D1%8F-%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C-%D0%B2-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B5)
        - [Что такое swap файл подкачки? Зачем он нужен, и как он работает? Какие данные в него записываются?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-swap-%D1%84%D0%B0%D0%B9%D0%BB-%D0%BF%D0%BE%D0%B4%D0%BA%D0%B0%D1%87%D0%BA%D0%B8-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-%D0%B8-%D0%BA%D0%B0%D0%BA-%D0%BE%D0%BD-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2-%D0%BD%D0%B5%D0%B3%D0%BE-%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%D1%81%D1%8F)
        - [Что показывает статус процессов? Какие статусы используются в linux?](#%D1%87%D1%82%D0%BE-%D0%BF%D0%BE%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82-%D1%81%D1%82%D0%B0%D1%82%D1%83%D1%81-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D1%82%D0%B0%D1%82%D1%83%D1%81%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D0%B2-linux)
        - [Что такое зомби-процесс? Как можно создать такой процесс?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B7%D0%BE%D0%BC%D0%B1%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D1%82%D0%B0%D0%BA%D0%BE%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81)
            - [Процесс создания зомби-процесса](#%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B7%D0%BE%D0%BC%D0%B1%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0)
            - [Интересная тонкость](#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B5%D1%81%D0%BD%D0%B0%D1%8F-%D1%82%D0%BE%D0%BD%D0%BA%D0%BE%D1%81%D1%82%D1%8C)
        - [Чем опасны зомби процессы, какие проблемы они могут создать?](#%D1%87%D0%B5%D0%BC-%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D1%8B-%D0%B7%D0%BE%D0%BC%D0%B1%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D0%BE%D0%BD%D0%B8-%D0%BC%D0%BE%D0%B3%D1%83%D1%82-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C)
        - [Можно ли завершить зомби процесс с помощью SIGKILL?](#%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D1%82%D1%8C-%D0%B7%D0%BE%D0%BC%D0%B1%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-sigkill)
        - [Что такое SIGCHLD? В какой ситуации процесс может его получить?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-sigchld-%D0%B2-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B9-%D1%81%D0%B8%D1%82%D1%83%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B8%D1%82%D1%8C)
        - [Что такое файловый дескриптор, какая информация в нем бывает?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B9-%D0%B4%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80-%D0%BA%D0%B0%D0%BA%D0%B0%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%B2-%D0%BD%D0%B5%D0%BC-%D0%B1%D1%8B%D0%B2%D0%B0%D0%B5%D1%82)
        - [Для чего нужны сигналы? Какие сигналы используются чаще всего? 5 - 10 штук](#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D1%87%D0%B0%D1%89%D0%B5-%D0%B2%D1%81%D0%B5%D0%B3%D0%BE-5---10-%D1%88%D1%82%D1%83%D0%BA)
        - [Как осуществляется обработка сигналов? Чем отличается SIGTERM от SIGKILL?](#%D0%BA%D0%B0%D0%BA-%D0%BE%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D0%BE%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-sigterm-%D0%BE%D1%82-sigkill)
        - [Какой сигнал получит активный процесс при нажатии Ctrl+C в консоли?](#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B9-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B8%D1%82-%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%BF%D1%80%D0%B8-%D0%BD%D0%B0%D0%B6%D0%B0%D1%82%D0%B8%D0%B8-ctrlc-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D0%B8)
        - [Какие сигналы не могут быть проигнорированы?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB%D1%8B-%D0%BD%D0%B5-%D0%BC%D0%BE%D0%B3%D1%83%D1%82-%D0%B1%D1%8B%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B8%D0%B3%D0%BD%D0%BE%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D1%8B)
        - [Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-load-average-%D1%87%D1%82%D0%BE-%D0%BF%D0%BE%D0%BA%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D0%B5%D1%82-%D1%8D%D1%82%D0%B0-%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%BA%D0%B0-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-load-average-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82-%D0%B8%D0%B7-%D1%82%D1%80%D1%91%D1%85-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9)
        - [Можно ли сделать так, чтобы пользователи могли получать информацию только о своих процессах?](#%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%82%D0%B0%D0%BA-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B8-%D0%BC%D0%BE%D0%B3%D0%BB%D0%B8-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B0%D1%82%D1%8C-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8E-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BE-%D1%81%D0%B2%D0%BE%D0%B8%D1%85-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0%D1%85)
        - [Что такое физическая память?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C)
        - [Что такое виртуальная память?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C)
        - [Почему в htop может быть не до конца корректная сводка по потребляемой памяти](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B2-htop-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%B1%D1%8B%D1%82%D1%8C-%D0%BD%D0%B5-%D0%B4%D0%BE-%D0%BA%D0%BE%D0%BD%D1%86%D0%B0-%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BA%D1%82%D0%BD%D0%B0%D1%8F-%D1%81%D0%B2%D0%BE%D0%B4%D0%BA%D0%B0-%D0%BF%D0%BE-%D0%BF%D0%BE%D1%82%D1%80%D0%B5%D0%B1%D0%BB%D1%8F%D0%B5%D0%BC%D0%BE%D0%B9-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8)
        - [Где в системе можно посмотреть сводку по текущему потреблению памяти?](#%D0%B3%D0%B4%D0%B5-%D0%B2-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BF%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D0%B4%D0%BA%D1%83-%D0%BF%D0%BE-%D1%82%D0%B5%D0%BA%D1%83%D1%89%D0%B5%D0%BC%D1%83-%D0%BF%D0%BE%D1%82%D1%80%D0%B5%D0%B1%D0%BB%D0%B5%D0%BD%D0%B8%D1%8E-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8)
        - [Как работает оом киллер и для чего нужен? Out of memory, oom](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BE%D0%BE%D0%BC-%D0%BA%D0%B8%D0%BB%D0%BB%D0%B5%D1%80-%D0%B8-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-out-of-memory-oom)
        - [Как процессы в системе взаимодействуют между собой?](#%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%D0%B2-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D1%81%D0%BE%D0%B1%D0%BE%D0%B9)
        - [a=5; true | { true && a=10; } чему будет равно a?](#a5-true---true--a10--%D1%87%D0%B5%D0%BC%D1%83-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D1%80%D0%B0%D0%B2%D0%BD%D0%BE-a)
        - [Что такое QEMU](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-qemu)
        - [Что такое KVM гипервизор](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-kvm-%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D0%B7%D0%BE%D1%80)
        - [Что такое qemu-kvm?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-qemu-kvm)
        - [Что такое iowait и почему он может появляться?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-iowait-%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BE%D0%BD-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%BF%D0%BE%D1%8F%D0%B2%D0%BB%D1%8F%D1%82%D1%8C%D1%81%D1%8F)
    - [Диски и файловая система](#%D0%B4%D0%B8%D1%81%D0%BA%D0%B8-%D0%B8-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0)
        - [Что такое символьные устройства? Какие элементарные операции с ними можно производить?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D1%81-%D0%BD%D0%B8%D0%BC%D0%B8-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D1%8C)
        - [Что такое major and minor numbers блочных устройств, чему они соответствуют?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-major-and-minor-numbers-%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2-%D1%87%D0%B5%D0%BC%D1%83-%D0%BE%D0%BD%D0%B8-%D1%81%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82)
        - [Что такое файловая система? Для чего она нужна?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BE%D0%BD%D0%B0-%D0%BD%D1%83%D0%B6%D0%BD%D0%B0)
            - [Файловая система как система хранения](#%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Как создать файловую систему на блочном устройстве? Какие параметры можно задать при создании?](#%D0%BA%D0%B0%D0%BA-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%83%D1%8E-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%83-%D0%BD%D0%B0-%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D0%BE%D0%BC-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B5-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B7%D0%B0%D0%B4%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%B8-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8)
        - [Что такое inodes айноды](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-inodes-%D0%B0%D0%B9%D0%BD%D0%BE%D0%B4%D1%8B)
        - [Где физически находятся inodes айноды](#%D0%B3%D0%B4%D0%B5-%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8-%D0%BD%D0%B0%D1%85%D0%BE%D0%B4%D1%8F%D1%82%D1%81%D1%8F-inodes-%D0%B0%D0%B9%D0%BD%D0%BE%D0%B4%D1%8B)
        - [По какой причине и на какого типа системах айноды могут закончиться? И к чему это может привести?](#%D0%BF%D0%BE-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B9-%D0%BF%D1%80%D0%B8%D1%87%D0%B8%D0%BD%D0%B5-%D0%B8-%D0%BD%D0%B0-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D1%85-%D0%B0%D0%B9%D0%BD%D0%BE%D0%B4%D1%8B-%D0%BC%D0%BE%D0%B3%D1%83%D1%82-%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D1%82%D1%8C%D1%81%D1%8F-%D0%B8-%D0%BA-%D1%87%D0%B5%D0%BC%D1%83-%D1%8D%D1%82%D0%BE-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%81%D1%82%D0%B8)
        - [Какая файловая система бывает  динамическими айнодами и что это такое, зачем нужно?](#%D0%BA%D0%B0%D0%BA%D0%B0%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B1%D1%8B%D0%B2%D0%B0%D0%B5%D1%82--%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%BC%D0%B8-%D0%B0%D0%B9%D0%BD%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8-%D0%B8-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE)
        - [Где хранится информация об именах файлов, директорий?](#%D0%B3%D0%B4%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D1%82%D1%81%D1%8F-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0%D1%85-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B9)
        - [Каким образом осуществляется монтирование ФС? Как можно посмотреть список примонтированных ФС? 2 - 3 способа](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%BE%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%BC%D0%BE%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%84%D1%81-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BF%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B5%D1%82%D1%8C-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BF%D1%80%D0%B8%D0%BC%D0%BE%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%84%D1%81-2---3-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B0)
        - [Что такое псевдофайловая система?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0)
        - [Какие проблемы могут возникать с файловой системой и жёстким диском? Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D0%BC%D0%BE%D0%B3%D1%83%D1%82-%D0%B2%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%B0%D1%82%D1%8C-%D1%81-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BE%D0%B9-%D0%B8-%D0%B6%D1%91%D1%81%D1%82%D0%BA%D0%B8%D0%BC-%D0%B4%D0%B8%D1%81%D0%BA%D0%BE%D0%BC-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C-%D1%84%D1%81-%D0%BF%D1%80%D0%B8-%D0%BD%D0%B5%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%BC-%D0%BF%D0%BE%D0%B2%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B8-%D0%B5%D1%91-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C)
            - [Восстановление файловых систем и инструменты для проверки](#%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC-%D0%B8-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B8)
            - [Ручная проверка файловой системы](#%D1%80%D1%83%D1%87%D0%BD%D0%B0%D1%8F-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B)
            - [Продвинутые инструменты](#%D0%BF%D1%80%D0%BE%D0%B4%D0%B2%D0%B8%D0%BD%D1%83%D1%82%D1%8B%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B)
            - [Инструменты для файловых систем ext2 и ext3](#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC-ext2-%D0%B8-ext3)
            - [Инструменты для файловых систем ReiserFS](#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC-reiserfs)
            - [Инструменты для файловой системы XFS](#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-xfs)
        - [Какую файловую систему выбрать ext4 или xfs?](#%D0%BA%D0%B0%D0%BA%D1%83%D1%8E-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%83%D1%8E-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%83-%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D1%82%D1%8C-ext4-%D0%B8%D0%BB%D0%B8-xfs)
        - [Как определить, на каком физическом жёстком диске находится раздел с файловой системой? Как можно идентифицировать этот носитель без выключения сервера?](#%D0%BA%D0%B0%D0%BA-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D1%8C-%D0%BD%D0%B0-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%BC-%D0%B6%D1%91%D1%81%D1%82%D0%BA%D0%BE%D0%BC-%D0%B4%D0%B8%D1%81%D0%BA%D0%B5-%D0%BD%D0%B0%D1%85%D0%BE%D0%B4%D0%B8%D1%82%D1%81%D1%8F-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB-%D1%81-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BE%D0%B9-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D1%8D%D1%82%D0%BE%D1%82-%D0%BD%D0%BE%D1%81%D0%B8%D1%82%D0%B5%D0%BB%D1%8C-%D0%B1%D0%B5%D0%B7-%D0%B2%D1%8B%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0)
        - [Как узнать, какими процессами используется раздел?](#%D0%BA%D0%B0%D0%BA-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC%D0%B8-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0%D0%BC%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB)
        - [Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?](#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B-etcfstab-etcmtab-etcmdadmmdadmconf)
        - [Отличие хардлинков от симлинков hardlinks symlinks](#%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D1%85%D0%B0%D1%80%D0%B4%D0%BB%D0%B8%D0%BD%D0%BA%D0%BE%D0%B2-%D0%BE%D1%82-%D1%81%D0%B8%D0%BC%D0%BB%D0%B8%D0%BD%D0%BA%D0%BE%D0%B2-hardlinks-symlinks)
        - [Что такое RAID? Какие основные типы RAID существуют, чем они отличаются?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-raid-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-raid-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B8-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F)
        - [Какие средства для работы с программными RAID массивами существуют в linux?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B0-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%BC%D0%B8-raid-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D0%B2-linux)
        - [Что такое LVM? Для решения каких задач он предназначен?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-lvm-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87-%D0%BE%D0%BD-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD)
        - [Что такое loop devices? Как их можно использовать?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-loop-devices-%D0%BA%D0%B0%D0%BA-%D0%B8%D1%85-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C)
        - [При создании нового файла система возвращает ошибку no space left device](#%D0%BF%D1%80%D0%B8-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D1%83-no-space-left-device)
        - [df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?deleted files](#df-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B0%D0%B5%D1%82-%D0%BE-%D0%BD%D0%B0%D0%BB%D0%B8%D1%87%D0%B8%D0%B8-20-%D0%B3%D0%B1-%D0%B7%D0%B0%D0%BD%D1%8F%D1%82%D0%BE%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82-%D0%B7%D0%B0%D0%BD%D1%8F%D1%82%D0%BE%D0%B3%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D0%BC%D0%B8-%D0%BC%D0%B5%D1%81%D1%82%D0%B0-%D0%BF%D1%80%D0%B8-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D0%B8-du-%D0%B4%D0%B0%D1%91%D1%82-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82-%D0%B2-20-%D0%BC%D0%B1-%D0%BF%D1%80%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D0%BE%D0%B1%D1%81%D1%82%D0%BE%D1%8F%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%B0%D1%85-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%B2%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%BD%D1%83%D1%82%D1%8C-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D0%B8%D1%82%D1%83%D0%B0%D1%86%D0%B8%D1%8Fdeleted-files)
        - [При создании нового файла пользователем система возвращает ошибку no space left on device](#%D0%BF%D1%80%D0%B8-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%BC-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D1%83-no-space-left-on-device)
    - [Debug](#debug)
        - [Сервер не отвечает, как можно получить доступ к серверу, не находясь непосредственно в ЦОДе](#%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D0%BD%D0%B5-%D0%BE%D1%82%D0%B2%D0%B5%D1%87%D0%B0%D0%B5%D1%82-%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B8%D1%82%D1%8C-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D1%83-%D0%BD%D0%B5-%D0%BD%D0%B0%D1%85%D0%BE%D0%B4%D1%8F%D1%81%D1%8C-%D0%BD%D0%B5%D0%BF%D0%BE%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE-%D0%B2-%D1%86%D0%BE%D0%B4%D0%B5)
        - [Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?](#%D0%B2%D0%B5%D0%B1-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B8%D0%B9-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B5-%D0%B2-%D0%BD%D0%B0%D1%88%D0%B5%D0%B9-%D1%81%D0%B5%D1%82%D0%B8-%D0%BE%D1%82%D0%B4%D0%B0%D1%91%D1%82-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D1%83-502-%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D0%BF%D1%80%D0%B8%D1%87%D0%B8%D0%BD%D1%83-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8)
        - [В директории находится файл с нечитаемым содержимым. Каким образом можно узнать  формат хранения данных и предназначение файла?](#%D0%B2-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BD%D0%B0%D1%85%D0%BE%D0%B4%D0%B8%D1%82%D1%81%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB-%D1%81-%D0%BD%D0%B5%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D0%BC%D1%8B%D0%BC-%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%BC%D1%8B%D0%BC-%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C--%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8-%D0%BF%D1%80%D0%B5%D0%B4%D0%BD%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0)
        - [Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?](#%D0%BF%D0%BE%D0%BF%D1%8B%D1%82%D0%BA%D0%B0-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D0%B5%D0%BC%D0%BE%D0%B3%D0%BE-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%BE%D0%B9-no-such-file-or-directory-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83)
        - [Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?](#%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B0%D0%B5%D1%82-%D0%BE-%D1%82%D0%BE%D0%BC-%D1%87%D1%82%D0%BE-%D0%BD%D0%B5-%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8-%D1%81%D0%B2%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D1%84%D0%B0%D0%B9%D0%BB-%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%B3%D0%B4%D0%B5-%D0%BE%D0%BD%D0%B0-%D0%BF%D1%8B%D1%82%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%B5%D0%B3%D0%BE-%D0%BD%D0%B0%D0%B9%D1%82%D0%B8)
        - [Что будешь делать если у команды chmod убрали права на исполнение? chmod -x chmod](#%D1%87%D1%82%D0%BE-%D0%B1%D1%83%D0%B4%D0%B5%D1%88%D1%8C-%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D0%B5%D1%81%D0%BB%D0%B8-%D1%83-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-chmod-%D1%83%D0%B1%D1%80%D0%B0%D0%BB%D0%B8-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0-%D0%BD%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-chmod--x-chmod)
        - [База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?](#%D0%B1%D0%B0%D0%B7%D0%B0-%D1%81%D0%B5%D0%B9%D1%87%D0%B0%D1%81-%D1%81%D0%B8%D0%B4%D0%B8%D1%82-%D0%B8-%D1%83%D0%BF%D0%B8%D1%80%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%B2-%D0%B4%D0%B8%D1%81%D0%BA-%D0%B8-%D1%81-%D0%BD%D0%B5%D0%B9-%D0%BD%D0%B8%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D0%B5-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C--%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D0%BD%D0%B8%D0%BA%D1%82%D0%BE-%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%B0%D1%82%D1%8C-%D0%BD%D0%B5-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C-%D1%82%D0%B0%D0%BA-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-%D0%BE%D0%BD%D0%BE-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%BB%D0%BE-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B5%D0%B5-%D0%BF%D1%80%D1%8F%D0%BC%D0%BE-%D1%81%D0%B5%D0%B9%D1%87%D0%B0%D1%81)
        - [Почему доступной available памяти сейчас 2919, если свободной free памяти 843?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%BE%D0%B9-available-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8-%D1%81%D0%B5%D0%B9%D1%87%D0%B0%D1%81-2919-%D0%B5%D1%81%D0%BB%D0%B8-%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9-free-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8-843)
        - [Что такое разделяемая память?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D0%BC%D0%B0%D1%8F-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C)
        - [Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.](#%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D0%BF%D0%BE%D0%B4-%D0%BD%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%BE%D0%B9-%D1%82%D0%BE%D1%80%D0%BC%D0%BE%D0%B7%D0%B8%D1%82---%D1%82%D1%8F%D0%B6%D0%B5%D0%BB%D1%8B%D0%B5-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%BA-%D0%BA%D0%B0%D1%81%D1%81%D0%B0%D0%BD%D0%B4%D1%80%D0%B5-%D0%B8-elk-%D0%BE%D1%82%D1%80%D0%B0%D0%B1%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D1%8E%D1%82-%D1%81%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE-%D0%BC%D0%B5%D0%B4%D0%BB%D0%B5%D0%BD%D0%BD%D0%B5%D0%B5-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%BD%D1%8C%D1%88%D0%B5-%D0%B8-%D1%87%D0%B5%D0%BC-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D0%B0%D0%BD%D0%B0%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%BD%D1%8B%D0%B5-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B0)
        - [допустим у тебя есть бинарник который запускается и сразу падает, у него все файловые дискрипторы пустые, как бы ты искал решение проблемы?](#%D0%B4%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC-%D1%83-%D1%82%D0%B5%D0%B1%D1%8F-%D0%B5%D1%81%D1%82%D1%8C-%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%B8%D0%BA-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%B8-%D1%81%D1%80%D0%B0%D0%B7%D1%83-%D0%BF%D0%B0%D0%B4%D0%B0%D0%B5%D1%82-%D1%83-%D0%BD%D0%B5%D0%B3%D0%BE-%D0%B2%D1%81%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B4%D0%B8%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D1%83%D1%81%D1%82%D1%8B%D0%B5-%D0%BA%D0%B0%D0%BA-%D0%B1%D1%8B-%D1%82%D1%8B-%D0%B8%D1%81%D0%BA%D0%B0%D0%BB-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B)
    - [Docker контейнеры](#docker-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B)
        - [Что такое docker и какие инструменты linux лежат в основе? Для чего он используется?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-docker-%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-linux-%D0%BB%D0%B5%D0%B6%D0%B0%D1%82-%D0%B2-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BE%D0%BD-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F)
        - [Что такое контейнеры, образы? В чём заключаются концепции их использования?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D1%8B-%D0%B2-%D1%87%D1%91%D0%BC-%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
        - [В каком виде хранятся образы? Для чего используются слои? Что представляет собой overlayfs?](#%D0%B2-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D0%B2%D0%B8%D0%B4%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D1%8F%D1%82%D1%81%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D1%81%D0%BB%D0%BE%D0%B8-%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82-%D1%81%D0%BE%D0%B1%D0%BE%D0%B9-overlayfs)
        - [Что такое docker commit](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-docker-commit)
        - [Каким образом в docker реализована изоляция контейнеров друг от друга? Какие средства linux для этого используются?namespace](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%BC-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%BC-%D0%B2-docker-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B0-%D0%B8%D0%B7%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%BE%D0%B2-%D0%B4%D1%80%D1%83%D0%B3-%D0%BE%D1%82-%D0%B4%D1%80%D1%83%D0%B3%D0%B0-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B0-linux-%D0%B4%D0%BB%D1%8F-%D1%8D%D1%82%D0%BE%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8Fnamespace)
        - [Почему в контейнере можно увидеть только процессы, запущенные в самом контейнере?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B2-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B5-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%83%D0%B2%D0%B8%D0%B4%D0%B5%D1%82%D1%8C-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B-%D0%B7%D0%B0%D0%BF%D1%83%D1%89%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2-%D1%81%D0%B0%D0%BC%D0%BE%D0%BC-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B5)
        - [В папке /var/lib/docker/ как понять какая папка к какому контейнеру принадлежит](#%D0%B2-%D0%BF%D0%B0%D0%BF%D0%BA%D0%B5-varlibdocker-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D1%8C-%D0%BA%D0%B0%D0%BA%D0%B0%D1%8F-%D0%BF%D0%B0%D0%BF%D0%BA%D0%B0-%D0%BA-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC%D1%83-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%83-%D0%BF%D1%80%D0%B8%D0%BD%D0%B0%D0%B4%D0%BB%D0%B5%D0%B6%D0%B8%D1%82)
        - [Какие типы сетей есть в докере](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D1%81%D0%B5%D1%82%D0%B5%D0%B9-%D0%B5%D1%81%D1%82%D1%8C-%D0%B2-%D0%B4%D0%BE%D0%BA%D0%B5%D1%80%D0%B5)
        - [Можно ли настроить сетевое взаимодействие между двумя docker-контейнерами? Как это реализовано?](#%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B8%D1%82%D1%8C-%D1%81%D0%B5%D1%82%D0%B5%D0%B2%D0%BE%D0%B5-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%B4%D0%B2%D1%83%D0%BC%D1%8F-docker-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0%D0%BC%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BE)
        - [Что происходит когда пишешь ENTRYPOINT?](#%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BF%D0%B8%D1%88%D0%B5%D1%88%D1%8C-entrypoint)
        - [В чем отличие CMD и ENTRYPOINT](#%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-cmd-%D0%B8-entrypoint)
        - [Как уменьшить размер образа докера? У нас много COPY, RUN](#%D0%BA%D0%B0%D0%BA-%D1%83%D0%BC%D0%B5%D0%BD%D1%8C%D1%88%D0%B8%D1%82%D1%8C-%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%B0-%D0%B4%D0%BE%D0%BA%D0%B5%D1%80%D0%B0-%D1%83-%D0%BD%D0%B0%D1%81-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-copy-run)
        - [Разработчики собрали образ, и запустили докер контейнер. При запуске выдает ошибку /bin/bash not found. Как диагностировать проблему?](#%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D1%81%D0%BE%D0%B1%D1%80%D0%B0%D0%BB%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7-%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BB%D0%B8-%D0%B4%D0%BE%D0%BA%D0%B5%D1%80-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80-%D0%BF%D1%80%D0%B8-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B5-%D0%B2%D1%8B%D0%B4%D0%B0%D0%B5%D1%82-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D1%83-binbash-not-found-%D0%BA%D0%B0%D0%BA-%D0%B4%D0%B8%D0%B0%D0%B3%D0%BD%D0%BE%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%83)
        - [Какие команды порождают слои?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BF%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%82-%D1%81%D0%BB%D0%BE%D0%B8)
        - [Что за none образы можно увидеть в docker images?](#%D1%87%D1%82%D0%BE-%D0%B7%D0%B0-none-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D1%8B-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%83%D0%B2%D0%B8%D0%B4%D0%B5%D1%82%D1%8C-%D0%B2-docker-images)
        - [Что такое squash сквош?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-squash-%D1%81%D0%BA%D0%B2%D0%BE%D1%88)
        - [Что такое Docker squash?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-docker-squash)
        - [Можно ли ограничить использование ресурсов cpu, ram, io, network для docker контейнера? Как это реализовано? cgroup**](#%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B8%D1%82%D1%8C-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2-cpu-ram-io-network-%D0%B4%D0%BB%D1%8F-docker-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0-%D0%BA%D0%B0%D0%BA-%D1%8D%D1%82%D0%BE-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BE-cgroup)
        - [Для решения каких задач применяется docker-compose?](#%D0%B4%D0%BB%D1%8F-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D1%82%D1%81%D1%8F-docker-compose)
        - [Что такое виртуализация? Чем виртуализация отличается от эмуляции?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%87%D0%B5%D0%BC-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D1%82-%D1%8D%D0%BC%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D0%B8)
        - [В чем разница между docker stop и docker pause?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-docker-stop-%D0%B8-docker-pause)
        - [Что такое слои в докере?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B8-%D0%B2-%D0%B4%D0%BE%D0%BA%D0%B5%D1%80%D0%B5)
        - [В чем разница между ADD и COPY](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-add-%D0%B8-copy)
        - [Почему latest образы использовать нежелательно?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-latest-%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BD%D0%B5%D0%B6%D0%B5%D0%BB%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE)
        - [В чем отличие ARG от ENV?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-arg-%D0%BE%D1%82-env)
        - [От кого по умолчанию запускается контейнер? Почему это плохо?](#%D0%BE%D1%82-%D0%BA%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%8D%D1%82%D0%BE-%D0%BF%D0%BB%D0%BE%D1%85%D0%BE)
        - [Как убить контейнер изнутри?](#%D0%BA%D0%B0%D0%BA-%D1%83%D0%B1%D0%B8%D1%82%D1%8C-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80-%D0%B8%D0%B7%D0%BD%D1%83%D1%82%D1%80%D0%B8)
        - [Возможен ли самостоятельный перезапуск контейнера?](#%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%B5%D0%BD-%D0%BB%D0%B8-%D1%81%D0%B0%D0%BC%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BF%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0)
        - [Какие есть best practices для написания Dockerfile?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B5%D1%81%D1%82%D1%8C-best-practices-%D0%B4%D0%BB%D1%8F-%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F-dockerfile)
        - [Что такое ката kata контейнер?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BA%D0%B0%D1%82%D0%B0-kata-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80)
        - [CRI, CSI, CNI, что это ?](#cri-csi-cni-%D1%87%D1%82%D0%BE-%D1%8D%D1%82%D0%BE-)
    - [Сети сеть](#%D1%81%D0%B5%D1%82%D0%B8-%D1%81%D0%B5%D1%82%D1%8C)
        - [Почему latency до 8.8.8.8 всегда низкий?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-latency-%D0%B4%D0%BE-8888-%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%BD%D0%B8%D0%B7%D0%BA%D0%B8%D0%B9)
        - [Расскажи мне, как неподготовленному слушателю как устанавливает соединение SSH и происходит авторизация разными методами: по паролю и SSH-ключам.](#%D1%80%D0%B0%D1%81%D1%81%D0%BA%D0%B0%D0%B6%D0%B8-%D0%BC%D0%BD%D0%B5-%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B5%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%BC%D1%83-%D1%81%D0%BB%D1%83%D1%88%D0%B0%D1%82%D0%B5%D0%BB%D1%8E-%D0%BA%D0%B0%D0%BA-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%B0%D0%B2%D0%BB%D0%B8%D0%B2%D0%B0%D0%B5%D1%82-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-ssh-%D0%B8-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D0%BC%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8-%D0%BF%D0%BE-%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8E-%D0%B8-ssh-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%BC)
        - [Что такое IP и маска подсети?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-ip-%D0%B8-%D0%BC%D0%B0%D1%81%D0%BA%D0%B0-%D0%BF%D0%BE%D0%B4%D1%81%D0%B5%D1%82%D0%B8)
        - [Что такое и зачем нужен ARP протокол?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-arp-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB)
        - [Зачем нужен VLAN?](#%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-vlan)
        - [Чем отличается TCP от UDP?](#%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-tcp-%D0%BE%D1%82-udp)
        - [Как TCP устанавливает соединение?](#%D0%BA%D0%B0%D0%BA-tcp-%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%B0%D0%B2%D0%BB%D0%B8%D0%B2%D0%B0%D0%B5%D1%82-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
        - [Как TCP поддерживает соединение?](#%D0%BA%D0%B0%D0%BA-tcp-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D0%B2%D0%B0%D0%B5%D1%82-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
        - [Что происходит когда в браузере вводишь yandex.ru? Описать процесс](#%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B2-%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B5-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B8%D1%88%D1%8C-yandexru-%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81)
        - [На каком уровне работает протокол TCP?](#%D0%BD%D0%B0-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB-tcp)
        - [На каком уровне оси работает ssh?](#%D0%BD%D0%B0-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5-%D0%BE%D1%81%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-ssh)
        - [Как работает DNS, зачем он нужен?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-dns-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD)
        - [типы DNS записей, какие бывают](#%D1%82%D0%B8%D0%BF%D1%8B-dns-%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B5%D0%B9-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B1%D1%8B%D0%B2%D0%B0%D1%8E%D1%82)
        - [Что такое адреса 127.0.0.0/8, 192.168.0.0/16, 10.0.0.0/8, 172.16.0.0/12? Зачем они нужны?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0-1270008-1921680016-100008-172160012-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B8-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B)
        - [Как работает NAT, зачем он нужен?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-nat-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD)
            - [Частные и публичные IP-адреса. NAT Network Address Translation](#%D1%87%D0%B0%D1%81%D1%82%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D1%87%D0%BD%D1%8B%D0%B5-ip-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0-nat-network-address-translation)
            - [NAT Network Address Translation](#nat-network-address-translation)
            - [Дополнительное объяснение NAT](#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-nat)
        - [Что такое SNI?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-sni)
        - [Что такое TLS и SSL](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-tls-%D0%B8-ssl)
        - [Чем симметричное шифрование отличается от ассиметричного?](#%D1%87%D0%B5%D0%BC-%D1%81%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%BE%D0%B5-%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D1%82-%D0%B0%D1%81%D1%81%D0%B8%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE)
        - [Почему DNS использует UDP?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-dns-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82-udp)
        - [днс использует только udp соединение?](#%D0%B4%D0%BD%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-udp-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
        - [На каком порту работает ping?](#%D0%BD%D0%B0-%D0%BA%D0%B0%D0%BA%D0%BE%D0%BC-%D0%BF%D0%BE%D1%80%D1%82%D1%83-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-ping)
        - [Как работает ICMP](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-icmp)
        - [Что такое TTL?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-ttl)
            - [Time To Live TTL](#time-to-live-ttl)
            - [Почему был введён TTL?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B1%D1%8B%D0%BB-%D0%B2%D0%B2%D0%B5%D0%B4%D1%91%D0%BD-ttl)
        - [Как работает traceroute?](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-traceroute)
        - [Что такое authority в DNS?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-authority-%D0%B2-dns)
        - [Как узнать мой внешний ip адрес?](#%D0%BA%D0%B0%D0%BA-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BC%D0%BE%D0%B9-%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B8%D0%B9-ip-%D0%B0%D0%B4%D1%80%D0%B5%D1%81)
        - [Что такое рекурсивный DNS](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-dns)
        - [Рекурсивный и нерекурсивный запрос к серверу dns](#%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D0%B8-%D0%BD%D0%B5%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81-%D0%BA-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D1%83-dns)
        - [Базовая http аутентификация авторизация, как работает](#%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D1%8F-http-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82)
        - [В чём отличие аутентификации от авторизации?](#%D0%B2-%D1%87%D1%91%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE%D1%82-%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
        - [Как работают сертификаты? Как подтверждается соединение? https соединение](#%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D1%8B-%D0%BA%D0%B0%D0%BA-%D0%BF%D0%BE%D0%B4%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-https-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
        - [Опиши принцип работы ssl-шифрования](#%D0%BE%D0%BF%D0%B8%D1%88%D0%B8-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-ssl-%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
        - [Какие стандартные коды ответов есть у веб-серверов?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%B4%D1%8B-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%BE%D0%B2-%D0%B5%D1%81%D1%82%D1%8C-%D1%83-%D0%B2%D0%B5%D0%B1-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%B2)
        - [Какие существуют основные типы запросов HTTP?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2-http)
        - [Что такое маска подсети?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BC%D0%B0%D1%81%D0%BA%D0%B0-%D0%BF%D0%BE%D0%B4%D1%81%D0%B5%D1%82%D0%B8)
        - [Что такое таблица маршрутизации](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0-%D0%BC%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
        - [Что такое REST API и API](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-rest-api-%D0%B8-api)
        - [Динамическая маршрутизация и разные протоколы динамической маршрутизации, ebgp ibgp, константы bgp. На чём сейчас принято строить bgp-пиринги. Что такое blackhole.](#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%BC%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D1%8B-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9-%D0%BC%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-ebgp-ibgp-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B-bgp-%D0%BD%D0%B0-%D1%87%D1%91%D0%BC-%D1%81%D0%B5%D0%B9%D1%87%D0%B0%D1%81-%D0%BF%D1%80%D0%B8%D0%BD%D1%8F%D1%82%D0%BE-%D1%81%D1%82%D1%80%D0%BE%D0%B8%D1%82%D1%8C-bgp-%D0%BF%D0%B8%D1%80%D0%B8%D0%BD%D0%B3%D0%B8-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-blackhole)
            - [eBGP и iBGP](#ebgp-%D0%B8-ibgp)
            - [Константы BGP](#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B-bgp)
            - [Построение BGP-пирингов](#%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-bgp-%D0%BF%D0%B8%D1%80%D0%B8%D0%BD%D0%B3%D0%BE%D0%B2)
            - [Blackhole](#blackhole)
        - [Расскажи про модель TCP IP](#%D1%80%D0%B0%D1%81%D1%81%D0%BA%D0%B0%D0%B6%D0%B8-%D0%BF%D1%80%D0%BE-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-tcp-ip)
        - [Чем отличаются балансировщики L4 и L7? Что умеет балансировщик L7, чего не умеет L4?](#%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F-%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA%D0%B8-l4-%D0%B8-l7-%D1%87%D1%82%D0%BE-%D1%83%D0%BC%D0%B5%D0%B5%D1%82-%D0%B1%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-l7-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D0%B5-%D1%83%D0%BC%D0%B5%D0%B5%D1%82-l4)
    - [Ansible](#ansible)
        - [Для чего нужен ad hoc в ansible?](#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-ad-hoc-%D0%B2-ansible)
        - [Что такое роли в ansible, пример](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%80%D0%BE%D0%BB%D0%B8-%D0%B2-ansible-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80)
        - [Что такое идемпотентность? Приведи пример таких операций, и противоположных им](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%82%D0%B0%D0%BA%D0%B8%D1%85-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9-%D0%B8-%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2%D0%BE%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%BD%D1%8B%D1%85-%D0%B8%D0%BC)
        - [Для чего нужны хендлеры, handlers?](#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B-%D1%85%D0%B5%D0%BD%D0%B4%D0%BB%D0%B5%D1%80%D1%8B-handlers)
        - [В чем разница pull и push модели?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-pull-%D0%B8-push-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8)
        - [В чем плюсы ансибла?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BF%D0%BB%D1%8E%D1%81%D1%8B-%D0%B0%D0%BD%D1%81%D0%B8%D0%B1%D0%BB%D0%B0)
        - [Опишите основные примитивы Ansible](#%D0%BE%D0%BF%D0%B8%D1%88%D0%B8%D1%82%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-ansible)
        - [В чем разница между модулем и плагином**](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%BC-%D0%B8-%D0%BF%D0%BB%D0%B0%D0%B3%D0%B8%D0%BD%D0%BE%D0%BC)
    - [СУБД Базы Mysql](#%D1%81%D1%83%D0%B1%D0%B4-%D0%B1%D0%B0%D0%B7%D1%8B-mysql)
        - [Что такое индексы, зачем они нужны?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD%D0%B8-%D0%BD%D1%83%D0%B6%D0%BD%D1%8B)
        - [Какая будет проблема если проставить много индексов?](#%D0%BA%D0%B0%D0%BA%D0%B0%D1%8F-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0-%D0%B5%D1%81%D0%BB%D0%B8-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2)
        - [Как настроить мастер слейв репликацию в мускуле?](#%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B8%D1%82%D1%8C-%D0%BC%D0%B0%D1%81%D1%82%D0%B5%D1%80-%D1%81%D0%BB%D0%B5%D0%B9%D0%B2-%D1%80%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8E-%D0%B2-%D0%BC%D1%83%D1%81%D0%BA%D1%83%D0%BB%D0%B5)
        - [В чем разница между TRUNCATE DELETE и DROP?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-truncate-delete-%D0%B8-drop)
    - [Что такое роли в pgsql](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%80%D0%BE%D0%BB%D0%B8-%D0%B2-pgsql)
        - [Почему не следует использовать утилиту mysqldump на большой активной базе данных? Какие Вы знаете альтернативы?](#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%BD%D0%B5-%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D1%82-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D1%83%D1%82%D0%B8%D0%BB%D0%B8%D1%82%D1%83-mysqldump-%D0%BD%D0%B0-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B9-%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B0%D0%B7%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B2%D1%8B-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-%D0%B0%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D1%8B)
        - [Аббревиатура ACID, как расшифровывается?](#%D0%B0%D0%B1%D0%B1%D1%80%D0%B5%D0%B2%D0%B8%D0%B0%D1%82%D1%83%D1%80%D0%B0-acid-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D1%8B%D0%B2%D0%B0%D0%B5%D1%82%D1%81%D1%8F)
        - [Как безопасно удалить или изменить миллион строк в базе данных?](#%D0%BA%D0%B0%D0%BA-%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE-%D1%83%D0%B4%D0%B0%D0%BB%D0%B8%D1%82%D1%8C-%D0%B8%D0%BB%D0%B8-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B8%D1%82%D1%8C-%D0%BC%D0%B8%D0%BB%D0%BB%D0%B8%D0%BE%D0%BD-%D1%81%D1%82%D1%80%D0%BE%D0%BA-%D0%B2-%D0%B1%D0%B0%D0%B7%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
        - [Что такое wal-файл и зачем он нужен?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-wal-%D1%84%D0%B0%D0%B9%D0%BB-%D0%B8-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD)
    - [Python](#python)
        - [Хеш-таблица](#%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)
            - [Что такое хеш-таблица?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)
            - [Пример использования хеш-таблиц](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86)
        - [Что такое генератор, что такое итератор?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
            - [Итератор](#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
            - [Генератор](#%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80)
        - [В чем разница между кортежем и списком?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6%D0%B5%D0%BC-%D0%B8-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%BC)
        - [Что такое декоратор?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80)
    - [Какое значение принимает переменная в Python, которая не имеет значения?](#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D1%82-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F-%D0%B2-python-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%B0%D1%8F-%D0%BD%D0%B5-%D0%B8%D0%BC%D0%B5%D0%B5%D1%82-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)
    - [KUBERNETES](#kubernetes)
        - [Что такое kubernetes?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-kubernetes)
        - [Какую проблему решает kubernetes?](#%D0%BA%D0%B0%D0%BA%D1%83%D1%8E-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%83-%D1%80%D0%B5%D1%88%D0%B0%D0%B5%D1%82-kubernetes)
        - [Что такое minikube?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-minikube)
        - [Приведи пример проблемы, которая упрощает работу именно с использованием кубернетеса?](#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%B0%D1%8F-%D1%83%D0%BF%D1%80%D0%BE%D1%89%D0%B0%D0%B5%D1%82-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83-%D0%B8%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE-%D1%81-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC-%D0%BA%D1%83%D0%B1%D0%B5%D1%80%D0%BD%D0%B5%D1%82%D0%B5%D1%81%D0%B0)
        - [В чем отличие statefulset от Deployment?**](#%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-statefulset-%D0%BE%D1%82-deployment)
        - [statefulset что такое ?](#statefulset-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-)
        - [В чем отличие Deployment от Replicaset?](#%D0%B2-%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-deployment-%D0%BE%D1%82-replicaset)
        - [Что такое Readiness, Liveness, Startup пробы, какое отличие?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-readiness-liveness-startup-%D0%BF%D1%80%D0%BE%D0%B1%D1%8B-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5)
        - [Что такое оператор в kubernetes?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B2-kubernetes)
        - [Что такое узел, нода?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%83%D0%B7%D0%B5%D0%BB-%D0%BD%D0%BE%D0%B4%D0%B0)
        - [Опиши архитектуру кубернетес кластера, из чего состоит?](#%D0%BE%D0%BF%D0%B8%D1%88%D0%B8-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%83-%D0%BA%D1%83%D0%B1%D0%B5%D1%80%D0%BD%D0%B5%D1%82%D0%B5%D1%81-%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%B0-%D0%B8%D0%B7-%D1%87%D0%B5%D0%B3%D0%BE-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82)
        - [Что такое pod?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-pod)
        - [В чем разница между подом и контейнером?**](#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%BF%D0%BE%D0%B4%D0%BE%D0%BC-%D0%B8-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%BE%D0%BC)
        - [Как создается под? Какие компоненты задействуются при его создании?](#%D0%BA%D0%B0%D0%BA-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BF%D0%BE%D0%B4-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D0%B7%D0%B0%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82%D1%81%D1%8F-%D0%BF%D1%80%D0%B8-%D0%B5%D0%B3%D0%BE-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8)
        - [Может ли под запуститься на двух разных узлах?](#%D0%BC%D0%BE%D0%B6%D0%B5%D1%82-%D0%BB%D0%B8-%D0%BF%D0%BE%D0%B4-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%8C%D1%81%D1%8F-%D0%BD%D0%B0-%D0%B4%D0%B2%D1%83%D1%85-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85-%D1%83%D0%B7%D0%BB%D0%B0%D1%85)
        - [Что такое ReplicaSet?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-replicaset)
        - [Что такое Deployment?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-deployment)
        - [Что такое Service](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-service)
        - [Какие типы service бывают?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-service-%D0%B1%D1%8B%D0%B2%D0%B0%D1%8E%D1%82)
        - [Что такое Ingress](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-ingress)
        - [Что такое Job](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-job)
        - [Что такое CronJob](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-cronjob)
        - [Что означает версия api apiVersion](#%D1%87%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F-api-apiversion)
        - [Что такое namespace?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-namespace)
        - [Что такое Volume](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-volume)
        - [Какие бывают типы файловых хранилищ](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B1%D1%8B%D0%B2%D0%B0%D1%8E%D1%82-%D1%82%D0%B8%D0%BF%D1%8B-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85-%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BB%D0%B8%D1%89)
        - [Что такое configMap?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-configmap)
        - [Что такое Secret](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-secret)
        - [Что такое PersistentVolume, PersistentVolumeClaim](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-persistentvolume-persistentvolumeclaim)
        - [Что такое nodeSelector, nodeName?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-nodeselector-nodename)
        - [DaemonSet зачем нужен для чего его обычно используют?**](#daemonset-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B5%D0%B3%D0%BE-%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82)
        - [Что такое Taints, Tolerations?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-taints-tolerations)
        - [Что такое Requests, Limits?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-requests-limits)
        - [Affinity, anti-affinity**](#affinity-anti-affinity)
        - [Что такое Helm](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-helm)
        - [Что дает helm в кубе ?](#%D1%87%D1%82%D0%BE-%D0%B4%D0%B0%D0%B5%D1%82-helm-%D0%B2-%D0%BA%D1%83%D0%B1%D0%B5-)
        - [если лимит больше чем реквест и нету ресурсов на ноде и выложиться ли такой под](#%D0%B5%D1%81%D0%BB%D0%B8-%D0%BB%D0%B8%D0%BC%D0%B8%D1%82-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5-%D1%87%D0%B5%D0%BC-%D1%80%D0%B5%D0%BA%D0%B2%D0%B5%D1%81%D1%82-%D0%B8-%D0%BD%D0%B5%D1%82%D1%83-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2-%D0%BD%D0%B0-%D0%BD%D0%BE%D0%B4%D0%B5-%D0%B8-%D0%B2%D1%8B%D0%BB%D0%BE%D0%B6%D0%B8%D1%82%D1%8C%D1%81%D1%8F-%D0%BB%D0%B8-%D1%82%D0%B0%D0%BA%D0%BE%D0%B9-%D0%BF%D0%BE%D0%B4)
        - [Через что реализованы сети в kubernetes?](#%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%87%D1%82%D0%BE-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D1%8B-%D1%81%D0%B5%D1%82%D0%B8-%D0%B2-kubernetes)
        - [Что произойдет при изменении имейджа? Как будут докатываться изменения?](#%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%BE%D0%B9%D0%B4%D0%B5%D1%82-%D0%BF%D1%80%D0%B8-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8-%D0%B8%D0%BC%D0%B5%D0%B9%D0%B4%D0%B6%D0%B0-%D0%BA%D0%B0%D0%BA-%D0%B1%D1%83%D0%B4%D1%83%D1%82-%D0%B4%D0%BE%D0%BA%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C%D1%81%D1%8F-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Что такое headless service ?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-headless-service-)
    - [GITLAB CI/CD](#gitlab-cicd)
        - [Каковы ключевые компоненты GitLab CI/CD?](#%D0%BA%D0%B0%D0%BA%D0%BE%D0%B2%D1%8B-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-gitlab-cicd)
        - [Что такое before_script и after_script в GitLab CI/CD?/CD?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-before_script-%D0%B8-after_script-%D0%B2-gitlab-cicdcd)
        - [У вас есть 5 проектов на одном языке программирования. Как организовать пайплайны, чтобы избежать дублирования конфигурации?](#%D1%83-%D0%B2%D0%B0%D1%81-%D0%B5%D1%81%D1%82%D1%8C-5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%BD%D0%B0-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA-%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D0%B0%D0%B9%D0%BF%D0%BB%D0%B0%D0%B9%D0%BD%D1%8B-%D1%87%D1%82%D0%BE%D0%B1%D1%8B-%D0%B8%D0%B7%D0%B1%D0%B5%D0%B6%D0%B0%D1%82%D1%8C-%D0%B4%D1%83%D0%B1%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8)
        - [Как запускать тесты только при создании merge request?](#%D0%BA%D0%B0%D0%BA-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D1%82%D1%8C-%D1%82%D0%B5%D1%81%D1%82%D1%8B-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BF%D1%80%D0%B8-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B8-merge-request)
        - [Если в before_script переопределить переменную, будет ли она доступна в script?pt?](#%D0%B5%D1%81%D0%BB%D0%B8-%D0%B2-before_script-%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%83%D1%8E-%D0%B1%D1%83%D0%B4%D0%B5%D1%82-%D0%BB%D0%B8-%D0%BE%D0%BD%D0%B0-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%B0-%D0%B2-scriptpt)
        - [Какие существуют способы контроля запуска job в GitLab CI?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82-%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D1%8B-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8F-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0-job-%D0%B2-gitlab-ci)
        - [Что такое кэширование в GitLab CI/CD?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BA%D1%8D%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-gitlab-cicd)
    - [GIT](#git)
        - [Чем merge отличается от rebase?](#%D1%87%D0%B5%D0%BC-merge-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D0%BE%D1%82-rebase)
        - [Когда нужно использовать merge, когда rebase?](#%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-merge-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-rebase)
        - [Чем отличается git pull и git fetch](#%D1%87%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F-git-pull-%D0%B8-git-fetch)
        - [Что такое cherry pick ?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-cherry-pick-)
        - [Какие пратики работы с гитом вы знаете? Форки](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D1%82%D0%B8%D0%BA%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D0%B3%D0%B8%D1%82%D0%BE%D0%BC-%D0%B2%D1%8B-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-%D1%84%D0%BE%D1%80%D0%BA%D0%B8)
        - [Что такое GitFlow?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-gitflow)
    - [Terraform](#terraform)
        - [Отличие ansible и terraform](#%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-ansible-%D0%B8-terraform)
        - [Что такое провайдер в terraform](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80-%D0%B2-terraform)
        - [Что такое ресурс в terraform](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81-%D0%B2-terraform)
        - [Что такое tfstate](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-tfstate)
        - [configure drift что такое](#configure-drift-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5)
        - [Как блокировать tfstate](#%D0%BA%D0%B0%D0%BA-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-tfstate)
        - [Как можно ресурс созданный в GUI перенести в код terraform](#%D0%BA%D0%B0%D0%BA-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%B2-gui-%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B5%D1%81%D1%82%D0%B8-%D0%B2-%D0%BA%D0%BE%D0%B4-terraform)
        - [Отличие contidion от look up](#%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-contidion-%D0%BE%D1%82-look-up)
        - [Ты накидал код в тераформе, запустил план, вышел. После этого твой коллега накидал свой код, выполнил план, вышел. далее тебе нужно зааплаить свою инфру, будут ли какие-то ошибки](#%D1%82%D1%8B-%D0%BD%D0%B0%D0%BA%D0%B8%D0%B4%D0%B0%D0%BB-%D0%BA%D0%BE%D0%B4-%D0%B2-%D1%82%D0%B5%D1%80%D0%B0%D1%84%D0%BE%D1%80%D0%BC%D0%B5-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BB-%D0%BF%D0%BB%D0%B0%D0%BD-%D0%B2%D1%8B%D1%88%D0%B5%D0%BB-%D0%BF%D0%BE%D1%81%D0%BB%D0%B5-%D1%8D%D1%82%D0%BE%D0%B3%D0%BE-%D1%82%D0%B2%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%B3%D0%B0-%D0%BD%D0%B0%D0%BA%D0%B8%D0%B4%D0%B0%D0%BB-%D1%81%D0%B2%D0%BE%D0%B9-%D0%BA%D0%BE%D0%B4-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D0%BB-%D0%BF%D0%BB%D0%B0%D0%BD-%D0%B2%D1%8B%D1%88%D0%B5%D0%BB-%D0%B4%D0%B0%D0%BB%D0%B5%D0%B5-%D1%82%D0%B5%D0%B1%D0%B5-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%B0%D0%B0%D0%BF%D0%BB%D0%B0%D0%B8%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D1%8E-%D0%B8%D0%BD%D1%84%D1%80%D1%83-%D0%B1%D1%83%D0%B4%D1%83%D1%82-%D0%BB%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D1%82%D0%BE-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8)
        - [У вас есть 20 серверов, созданных с помощью Terraform, но вы хотите удалить один из них. Можно ли уничтожить один ресурс из нескольких ресурсов без правки в самих файлах?](#%D1%83-%D0%B2%D0%B0%D1%81-%D0%B5%D1%81%D1%82%D1%8C-20-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BE%D0%B2-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-terraform-%D0%BD%D0%BE-%D0%B2%D1%8B-%D1%85%D0%BE%D1%82%D0%B8%D1%82%D0%B5-%D1%83%D0%B4%D0%B0%D0%BB%D0%B8%D1%82%D1%8C-%D0%BE%D0%B4%D0%B8%D0%BD-%D0%B8%D0%B7-%D0%BD%D0%B8%D1%85-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D0%BB%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B8%D1%82%D1%8C-%D0%BE%D0%B4%D0%B8%D0%BD-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81-%D0%B8%D0%B7-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D1%85-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2-%D0%B1%D0%B5%D0%B7-%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8-%D0%B2-%D1%81%D0%B0%D0%BC%D0%B8%D1%85-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85)
        - [Какие есть best practice для ухаживания за tfstate file?](#%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%B5%D1%81%D1%82%D1%8C-best-practice-%D0%B4%D0%BB%D1%8F-%D1%83%D1%85%D0%B0%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B7%D0%B0-tfstate-file)
        - [У вас есть несколько сред — dev, stage, prod для вашего приложения, и вы хотите использовать один и тот же код для всех этих сред. Как ты можешь это сделать?](#%D1%83-%D0%B2%D0%B0%D1%81-%D0%B5%D1%81%D1%82%D1%8C-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D1%81%D1%80%D0%B5%D0%B4--dev-stage-prod-%D0%B4%D0%BB%D1%8F-%D0%B2%D0%B0%D1%88%D0%B5%D0%B3%D0%BE-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%B2%D1%8B-%D1%85%D0%BE%D1%82%D0%B8%D1%82%D0%B5-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D0%B4%D0%B8%D0%BD-%D0%B8-%D1%82%D0%BE%D1%82-%D0%B6%D0%B5-%D0%BA%D0%BE%D0%B4-%D0%B4%D0%BB%D1%8F-%D0%B2%D1%81%D0%B5%D1%85-%D1%8D%D1%82%D0%B8%D1%85-%D1%81%D1%80%D0%B5%D0%B4-%D0%BA%D0%B0%D0%BA-%D1%82%D1%8B-%D0%BC%D0%BE%D0%B6%D0%B5%D1%88%D1%8C-%D1%8D%D1%82%D0%BE-%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C)
    - [Рабочий процесс](#%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B8%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81)
        - [Что такое SLO, SLA, SLI?](#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-slo-sla-sli)

<!-- /TOC -->

# Вопросы админам 2.0


---

## Железячные вопросы

### Сервер не отвечает, как можно получить доступ к серверу, не находясь непосредственно в ЦОДЕ

- Ответ

Через IPMI или kvm если оно есть на сервере.
Ну или звонить дежурному инженера ЦОДА, если иных опций нет.

---


### Что такое kvm(не гипервизор)? Как можно его использовать?

- Ответ
    
    KVM (или kvm over ip) — устройство, позволяющее передавать видеосигнал и ввод с мыши/клавиатуры по сети с использованием IP-протокола от вашего сервера. При помощи KVM вы можете перезагрузить сервер, получить доступ в BIOS сервера и к другим функциям, которые невозможно выполнить на сервере через терминал. То есть он обособлен от операционной системы.
    
    Часто используется как последнее средств. Когда сервер не грузится, или есть ещё какой-то программный или системный сбой.
    
    KVM - это аббревиатура, состоящая из слов. Клавиатура, монитор(видео), мышь.
    

---

### Что такое IPMI? Какие подсистемы он в себя включает?

- Ответ
    
    IPMI (Intelligent Platform Management Interface) – это интерфейс для удаленного мониторинга и управления физическим состоянием сервера.
    
    Как я понимаю, модуль находится внутри самого сервера. И называется он BMC. Контроллер управления. 
    
    В случае утраты контроля над работой сервера, можно удаленно управлять его работой, а именно:
    
    - получить доступ к консоли, изменить настройки BIOS;
    
    - перезагрузить, включить/выключить сервер;
    
    - ознакомиться с состоянием сервера (слежение за температурными 
    датчиками, датчиками напряжения, состояние блока питания, скорость 
    вращения вентиляторов);
    
    - подключение образов .iso.
    
    Но вообще, BMC ― это отдельный компьютер со своим программным обеспечением и сетевым интерфейсом, который распаивают на материнской плате или подключают как плату расширения по шине PCI management bus.
    
    К BMC контроллеры подключаются через интерфейс IPMB (Intelligent 
    Platform Management Bus ― шина интеллектуального управления платформой).
     IPMB ― это шина на основе I2C (Inter-Integrated Circuit), по которой 
    BMC перенаправляет команды управления к различным частям архитектуры:
    
    - Общается с дополнительными контроллерами (MCs)
    - Считывает данные сенсоров (Sensors)
    - Обращается к энергонезависимому хранилищу (Non-Volatile Storage)
    
    Архитектура IPMI реализована так, что удаленный администратор не 
    имеет прямого доступа к компонентам системы. Например, чтобы получить 
    данные с сенсоров, удаленный администратор посылает команду на BMC, а 
    BMC в свою очередь обращается к сенсорам.
    
    Подробнее о технологии можно почитать по ссылке:  
    [https://selectel.ru/blog/ipmi-obzor-texnologii/](https://selectel.ru/blog/ipmi-obzor-texnologii/)
    

---

### Какие преимущества предоставляет IPMI в сравнении с kvm?

- Ответ
    
    Недостатки модуля IP-KVM в сравнении с IPMI
    
    Традиционные внешние IP-KVM устройства позволяют вам удаленно работать 
    только с консолью своего сервера, отсутствует возможность управления 
    питанием, монтирования образов и контроля состояния датчиков сервера.
    
    У IP-KVM есть несколько ключевых недостатков:
    
    - отсутствие постоянного доступа к управлению сервером (чтобы
    воспользоваться IP-KVM, вам нужно создать запрос в техподдержку с
    просьбой подключить к вашему серверу временный IP-KVM в датацентре;
    заявку желательно подавать заранее, подключение занимает от 15 до 30
    минут в лучшем случае; в подключении KVM может быть отказано, если
    сейчас в наличии нет свободного оборудования);
    - отсутствие возможности управлять питанием, монтировать образы и контролировать состояние датчиков сервера.

---

## Просмотр информации о железной составляющей сервера

### Модели процессора, количестве физических и логических ядер, поддерживаемых инструкциях, режиме работы?

- Ответ
    - Модель процессора `cat /proc/cpuinfo`
    
    ```
    model name	: Intel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz
    model		: 45
    ```
    
    Та же модель процессора через `lscpu`
    
    ```
    Model name:          Intel(R) Xeon(R) CPU E5-2620 0 @ 2.00GHz
    ```
    
    Ядра физические и логические
    
    ```
    vm13 : ~ [0] # grep "cpu cores" /proc/cpuinfo |sort -u |cut -d":" -f2
     4
    vm13 : ~ [0] # grep -c "processor" /proc/cpuinfo
    4
    ```
    
    Поддерживаемые инструкции /proc/cpuinfo и lscpu
    
    Но возможно стоит также в спецификацию посмотреть
    
    ```
    Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology pni pclmulqdq vmx ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx hypervisor lahf_lm kaiser tpr_shadow vnmi flexpriority ept vpid tsc_adjust xsaveopt arat
    ```
    
    режимы работы процессора
    
    `find / -name scaling_governor`
    
    `find / -name scaling_max_freq`
    
    `cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor`
    
    - **powersave** — режим энергосбережения, ядро будет работать на пониженных частотах
    - **ondemand** — режим зависящей от текущей нагрузки на ядро
    - **performance** — режим максимальной мощности, выставляет максимально возможную частоту

    - Физические ядра - это число физических ядер, реальных аппаратных компонентов.

    Логические ядра - это число физических ядер, умноженное на количество потоков, которые могут выполняться на каждом ядре с помощью гиперпотока.
    например, мой 4-ядерный процессор запускает два потока на ядро, поэтому у меня есть 8 логических процессоров.
    
    Узнать сколько ядер доступно можно командой:
    
    ```
    dmidecode -t processor | grep "Core Enabled:"
    Core Enabled: 6
    Core Enabled: 6
    ```
    
    Видим, что на данной системе находится 12 физических ядер (6+6). Соответственно, нормальный показатель LA должен быть менее 12. Однако, на процессорах Intel используется технология [Hyper-Threading](http://www.intel.ru/content/www/ru/ru/architecture-and-technology/hyper-threading/hyper-threading-technology.html), которая делит одно физическое ядро на два логических.
    
    ```
    dmidecode -t processor | grep "Thread Count:"
    Thread Count: 12
    Thread Count: 12
    ```
    
    Соответственно, в данном случае в системе может быть одновременно 24 виртуальных процессора (потока).
    
    Технология Turbo Boost позволяет процессору «разгоняться» и работать на частоте выше заявленной (т.е. выше 100%, выше единицы). Какой показатель LA считать нормальным в данном случае является предметом споров.
    
    ---
    
### Типы оперативной памяти, модели материнской платы, версии BIOS?  

    
    **Оперативная память** 
    
    ```
    dmidecode --type memory 
    # dmidecode --type 17
    # dmidecode 2.11
    SMBIOS 2.8 present.
    
    Handle 0x1100, DMI type 17, 40 bytes
    Memory Device
    	Array Handle: 0x1000
    	Error Information Handle: Not Provided
    	Total Width: Unknown
    	Data Width: Unknown
    	Size: 9216 MB
    	Form Factor: DIMM
    	Set: None
    	Locator: DIMM 0
    	Bank Locator: Not Specified
    	Type: RAM
    	Type Detail: Other
    	Speed: Unknown
    	Manufacturer: QEMU
    	Serial Number: Not Specified
    	Asset Tag: Not Specified
    	Part Number: Not Specified
    	Rank: Unknown
    	Configured Clock Speed: Unknown
    
    Handle 0x004F, DMI type 17, 34 bytes
    Memory Device
    	Array Handle: 0x003F
    	Error Information Handle: Not Provided
    	Total Width: 72 bits
    	Data Width: 64 bits
    	Size: 16384 MB
    	Form Factor: DIMM
    	Set: None
    	Locator: P2_DIMMH2
    	Bank Locator: Node1_Bank0
    	Type: DDR3
    	Type Detail: Registered (Buffered)
    	Speed: 1333 MHz
    	Manufacturer: Samsung            
    	Serial Number: 85D3A920     
    	Asset Tag: Dimm10_AssetTag
    	Part Number: M393B2G70BH0-Y
    	Rank: 2
    	Configured Clock Speed: 1333 MHz
    ```
    
    Материнская плата
    
    ```
    
    dmidecode --type baseboard
    Handle 0x0002, DMI type 2, 15 bytes
    Base Board Information
    	Manufacturer: Supermicro
    	Product Name: X9DR3-F
    	Version: 0123456789
    	Serial Number: VM16BS021748
    	Asset Tag: To be filled by O.E.M.
    	Features:
    		Board is a hosting board
    		Board is replaceable
    	Location In Chassis: To be filled by O.E.M.
    	Chassis Handle: 0x0003
    	Type: Motherboard
    	Contained Object Handles: 0
    ```
    
    Версия bios
    
    ```bash
    storage8 : ~ [130] # dmidecode --type BIOS
    # dmidecode 2.11
    SMBIOS 2.7 present.
    
    Handle 0x0000, DMI type 0, 24 bytes
    BIOS Information
    	Vendor: American Megatrends Inc.
    	Version: 3.2a
    ```
    



---

### Текущих значениях датчиков напряжения, температуры, оборотов вентиляторов?

- Ответ, нужно дополнить
    
    Температура и всякие такие штуки можно смотреть в `sensors`
    
    ```bash
    sorsstorage13 : ~ [0] # sensors
    coretemp-isa-0001
    Adapter: ISA adapter
    Core 0:       +32.0°C  (high = +85.0°C, crit = +95.0°C)
    Core 1:       +36.0°C  (high = +85.0°C, crit = +95.0°C)
    Core 9:       +27.0°C  (high = +85.0°C, crit = +95.0°C)
    Core 10:      +39.0°C  (high = +85.0°C, crit = +95.0°C)
    
    intel5500-pci-00a3
    Adapter: PCI adapter
    temp1:        +65.5°C  (high = +100.0°C, hyst = +95.0°C)
                           (crit = +110.0°C)
    
    coretemp-isa-0000
    Adapter: ISA adapter
    Core 0:       +39.0°C  (high = +85.0°C, crit = +95.0°C)
    Core 1:       +38.0°C  (high = +85.0°C, crit = +95.0°C)
    Core 9:       +31.0°C  (high = +85.0°C, crit = +95.0°C)
    Core 10:      +29.0°C  (high = +85.0°C, crit = +95.0°C)
    ```
    
    Но большая часть информации через ipmicfg может взяться
    
    ```bash
    sorshocking : ~ [0] # ipmicfg -pminfo
     [SlaveAddress = 78h] [Module 1]
     Item                           |                          Value
     ----                           |                          -----
     Status                         |              [STATUS OK] (00h)
     Input Voltage                  |                        227.2 V
     Input Current                  |                         0.52 A
     Main Output Voltage            |                        12.09 V
     Main Output Current            |                         9.37 A
     Temperature 1                  |                        33C/91F
     Temperature 2                  |                       41C/106F
     Fan 1                          |                       3968 RPM
     Fan 2                          |                          0 RPM
     Main Output Power              |                          113 W
     Input Power                    |                          126 W
     PMBus Revision                 |                           0x22
     PWS Serial Number              |                P7061VF28GT1194
     PWS Module Number              |                    PWS-706P-1R
     PWS Revision                   |                            1.1
     Current Sharing Control        |           Active - Active (80)
    
     [SlaveAddress = 7Ah] [Module 2]
     Item                           |                          Value
     ----                           |                          -----
     Status                         |              [STATUS OK] (00h)
     Input Voltage                  |                        226.5 V
     Input Current                  |                         0.59 A
     Main Output Voltage            |                        12.09 V
     Main Output Current            |                        10.50 A
     Temperature 1                  |                        35C/95F
     Temperature 2                  |                       41C/106F
     Fan 1                          |                       4384 RPM
     Fan 2                          |                          0 RPM
     Main Output Power              |                          127 W
     Input Power                    |                          147 W
     PMBus Revision                 |                           0x22
     PWS Serial Number              |                P7061VF28GT1193
     PWS Module Number              |                    PWS-706P-1R
     PWS Revision                   |                            1.1
     Current Sharing Control        |           Active - Active (80)
    ```
    

---

### Типе используемого сетевого адаптера и состоянии его интерфейсов? 

- Ответ
    
    ```bash
    sorsstorage13 : ~ [0] # lspci | grep net
    01:00.0 Ethernet controller: Intel Corporation 82576 Gigabit Network Connection (rev 01)
    01:00.1 Ethernet controller: Intel Corporation 82576 Gigabit Network Connection (rev 01)
    ```
    
    ```bash
    vm13 : ~ [0] # lshw -class network -short
    H/W path      Device       Class      Description
    =================================================
    /0/100/12     eth0         network    Virtio network device
    /0/100/13     eth1         network    Virtio network device
    /1            vethd2a5488  network    Ethernet interface
    /2            vethd29a7c3  network    Ethernet interface
    /3            veth12f3f63  network    Ethernet interface
    /4            veth39864d5  network    Ethernet interface
    /5            vethbe4b44c  network    Ethernet interface
    /6            veth62b367d  network    Ethernet interface
    /7            veth26cd9d1  network    Ethernet interface
    /8            veth2ab7aa7  network    Ethernet interface
    /9            vethb7e97f1  network    Ethernet interface
    ```
    
    ```bash
    vm13 : ~ [255] # ip a s eth0
    2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
        link/ether 3e:8e:90:47:59:70 brd ff:ff:ff:ff:ff:ff
        inet 5.101.156.76/24 brd 5.101.156.255 scope global eth0
    ```
    
    Или так
    
    ```bash
    vm13 : ~ [0] # ip link show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 3e:8e:90:47:59:70 brd ff:ff:ff:ff:ff:ff
    3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
        link/ether 2e:84:f2:32:05:88 brd ff:ff:ff:ff:ff:ff
    ```
    
    Здесь можно увидеть понятие up, означает что интерфейс поднят
    
    - UP — устройство подключено и готово принимать и отправлять фреймы;
    - LOOPBACK — интерфейс является локальным и не может взаимодействовать с другими узлами в сети;
    - BROADCAST - устройство способно отправлять широковещательные фреймы;
    - POINTTOPOINT — соединение типа «точка-точка»
    - PROMISC — устройство находится в режиме «прослушивания» и принимает все фреймы.
    - NOARP — отключена поддержка разрешения имен сетевого уровня.
    - ALLMULTI — устройство принимает все групповые пакеты.
    - NO-CARRIER — нет связи (не подключен кабель).
    - DOWN — устройство отключено.
        
        
    
    Еще можно вот так посмотреть:
    
    ```bash
    ls /sys/class/net
    additional-docker-sys-sys    docker0  eth1  veth12f3f63  veth2ab7aa7  veth62b367d  vethbe4b44c  vethd2a5488
    br-a67eedd3a789  eth0     lo    veth26cd9d1  veth39864d5  vethb7e97f1  vethd29a7c3
    ```
    

---

### Подключённых USB и PCI устройствах? 

- Ответ
    
    PC
    
    ```bash
    lspci -vvv
    ```
    
    USB
    
    ```bash
    lsusb -vvv
    ```
    

---

## Linux

### Расскажи, как происходит процесс загрузки ОС linux с момента нажатия кнопки питания. 

- Процесс загрузки системы
    
    Этапы следующие
    
    ![boot-system-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled.png)
    
    1. При включении компьютера цп переходит на адрес биоса и загружает биос.  
    2. Биос, или uefi проходит кучу проверок и согласно своим проверкам носитель информации.  
    3. На носителе находится MBR или GPT где находится загрузчик. Дальше по обстоятельствам. Загрузчик может загружать ось, а может передать управление дальше. 
       Например, если у нас есть несколько систем на нескольких разделах.  
       Под первой частью загрузки подразумевается небольшая часть машинного кода, которая запускает второй загрузчик. Потому что выделяется 446 байт. Там ничего не поместится.   
    4. Итого загрузчик первого этапа загружает загрузчик второго и кладет данные в оперативку. 
       Загрузчик, зная где лежит загрузчик ос, грузит его, и грузит initial ram disk - там лежат модули ядра. Они также являются драйверами, которые необходимы для загрузки всей остальной системы.   
    
    1. Затем ядро берет всё на себя. Инициализация устройств, конфигурирование процессора, памяти
    2. Далее запускается пользовательская среда, процесс init
    

    

    **супер коротко**
    1. загрузка биоса либо UEFI.
    2. биос либо UEFI проверяет работоспособность всех компонентов и запускает бутлоадер, 
       ищет его в  MBR или GPT разделе на диске.
    3. бутлоадер грузит OS.
    4. она уже грузит ядро.
    5. ядро конфигурирует уже всю память, процессор и тд.
    6. ядро запускает init процесс.
    8. запускаются все сервисы.
    9. логин в систему.
    7. запускаются скрипты оболочки юзера аля .bashrc, .zshrc, zprofile и тд.
    

    Полная подробная по загрузке пк вы можете увидеть по ссылке:
    [https://vc.ru/dev/137548-pusk-v-detalyah-kak-zagruzhaetsya-server](https://vc.ru/dev/137548-pusk-v-detalyah-kak-zagruzhaetsya-server)


---

### Что за процессы в Linux c PID 0 и 1

- Ответ
    Процесс с PID 0 - это процесс swap (или идл процесс).
    
    Этот процесс не выполняет никаких задач, он является бездействующим.
    Процессор переходит к выполнению процесса 0, когда нет других активных процессов для выполнения.
    
    
    Процесс с PID 1 - это init процесс (или systemd в современных дистрибутивах Linux).
    
    Это первый процесс, который запускается во время загрузки системы после ядра Linux.
    Он является родительским процессом для всех остальных процессов в системе.
    init процесс отвечает за запуск различных системных служб и демонов при загрузке.
    Если init процесс завершается, это приводит к остановке всей системы.


---

### Что такое POSIX 

- Ответ
    
    ### Интерфейс портативных операционных систем (POSIX)

    **Портативность** в контексте стандарта POSIX относится к исходному коду, а не к бинарным файлам, которые собираются из этого исходного кода. Это означает, что программы, написанные с соблюдением стандартов POSIX, могут быть скомпилированы и запущены на различных операционных системах без значительных изменений в исходном коде.

    **Интерфейс** — это способ взаимодействия вашего кода с остальной системой. POSIX определяет общий интерфейс, который описывает, как программы должны взаимодействовать с операционной системой.

    Таким образом, программы, разработанные для одной операционной системы, могут быть легко перенесены на другую, если обе системы поддерживают стандарт POSIX.

    Некоторые из ключевых аспектов POSIX включают:
    - **Семафоры** — механизм для синхронизации процессов и разделения ресурсов.
    - **Управление потоками** — стандарты для работы с потоками, синхронизации и управления ими.

    POSIX предоставляет основу для того, чтобы разработчики могли писать программы, которые будут совместимы с различными операционными системами, обеспечивая высокую степень переносимости кода.

    
---

### Что такое уровни выполнения (run levels) в Linux

- Ответ

    В Linux существует понятие **уровень выполнения** (*run level*), который обозначается числами от 0 до 6. Каждый уровень выполнения соответствует определённому состоянию системы.
    
    Система в любой момент времени находится на определённом уровне выполнения. Как системный администратор, вы можете переводить её с одного уровня выполнения на другой с помощью программы `init` (или `telinit`), передавая в качестве аргумента число, соответствующее нужному уровню выполнения.
    
    ### Описание уровней выполнения
    
  - **0** — система выполняет действия по выключению.
  - **1** — **однопользовательский режим** (*single user mode*). Предназначен для административных задач, например, восстановления системы. По функциональности напоминает безопасный режим (*Safe Mode*) в Windows, однако не является его полной аналогией. В этом режиме система сконфигурирована, но не запущен ни один сервис, и может работать только один пользователь — `root`.
  - **2** — **многопользовательский режим без сетевых файловых систем**. Не используется во многих дистрибутивах, но в Debian используется как стандартный многопользовательский режим.
  - **3** — **многопользовательский режим с сетевыми возможностями**. Это нормальный режим работы сервера без графического интерфейса.
  - **4** — **не используется** в большинстве систем. В Slackware Linux используется для графического входа в систему.
  - **5** — **графический режим**. В RedHat и SuSE Linux этот уровень используется для графического входа в систему. В Slackware не сконфигурирован.
  - **6** — выполняются действия по перезагрузке системы.

   ### Примечания к уровням выполнения
  - В большинстве современных систем уровни выполнения заменены на **systemd targets**, но принцип остаётся аналогичным.


---

### Какие основные части компоненты включает в себя система на базе дистрибутива linux? 

- Написать ответ
  1. **Начальный загрузчик (GRUB)**  
     GRUB (Grand Unified Bootloader) — это программа, которая отвечает за загрузку операционной системы. Она выполняется на этапе начальной загрузки и предоставляет выбор операционных систем или конфигураций для загрузки ядра.

  2. **Ядро Linux**  
    Ядро — это центральная часть операционной системы. Оно управляет ресурсами компьютера, такими как процессор, память и устройства ввода-вывода. Ядро выполняет важнейшие функции, включая управление процессами, памятью и взаимодействие с аппаратным обеспечением.

  3. **Демоны**  
   Демоны — это фоновые процессы, которые работают в системе и выполняют различные задачи без вмешательства пользователя. Примеры: `cron` (планировщик задач), `sshd` (управление удалёнными соединениями).

  4. **Командная оболочка (Shell)**  
   Оболочка — это интерфейс между пользователем и операционной системой. Она позволяет вводить команды и запускать программы. Примеры командных оболочек: `bash`, `zsh`, `fish`.

  5. **Утилиты командной оболочки**  
   Это набор команд и программ, которые выполняются из командной строки. Примеры таких утилит: `ls` (список файлов), `cp` (копирование файлов), `grep` (поиск текста).

  6. **Графический сервер**  
   Графический сервер, такой как [X.org](http://x.org), управляет графическим интерфейсом, видеокартой, монитором, мышью и другими устройствами ввода-вывода, необходимыми для отображения и взаимодействия с пользователем.

  7. **Среда рабочего стола**  
   Среда рабочего стола — это графический интерфейс, предоставляющий пользователю доступ к утилитам и инструментам операционной системы. Примеры: KDE, GNOME, Xfce, Cinnamon. Они включают в себя различные программы, такие как файловые менеджеры, панель задач и другие утилиты.

  8. **Программы рабочего стола**  
   Программы рабочего стола — это приложения, которые запускаются в рамках среды рабочего стола, такие как текстовые редакторы, браузеры, почтовые клиенты и файловые менеджеры, специфичные для каждой среды.
---

### Что такое BIOS, UEFI? Основы и различия

-  Ответ

    #### BIOS (Basic Input-Output System)
    **BIOS** — это низкоуровневое программное обеспечение, которое хранится на микросхеме, расположенной на материнской плате компьютера. Оно загружается при включении ПК и отвечает за инициализацию аппаратных компонентов, обеспечивая их правильную работу, а затем запускает загрузчик операционной системы.
    
    Когда компьютер включается, **BIOS** выполняет самотестирование — **POST (Power-On Self Test)**. В процессе тестирования проверяется конфигурация и работоспособность оборудования. Если обнаружены ошибки, BIOS может издавать звуковые сигналы (пищать) или выводить коды ошибок. После этого BIOS ищет загрузочную запись или MBR (Master Boot Record) и запускает загрузчик системы.
    
    BIOS также взаимодействует с **CMOS** (Дополнительный металл-оксид-полупроводник), небольшой памятью с батарейным питанием, где хранятся настройки BIOS, такие как конфигурация оборудования, системное время и параметры загрузки.
    
    #### Ограничения BIOS:
    - BIOS поддерживает загрузку только с дисков объемом до **2.1 ТБ**, так как использует **MBR** для разметки дисков.
    - BIOS работает в режиме **16-разрядного процессора** и имеет всего **1 МБ свободной памяти**.
    - У BIOS есть проблемы с одновременной инициализацией нескольких аппаратных устройств.
  
    Из-за этих ограничений BIOS считается устаревшей технологией.
    
    #### UEFI (Unified Extensible Firmware Interface)
    В 2007 году был разработан новый стандарт — **UEFI**, который заменяет BIOS и устраняет его ограничения. UEFI — это современная прошивка, которая предоставляет более гибкие возможности для взаимодействия с аппаратным обеспечением и операционной системой.
    
    #### Преимущества UEFI по сравнению с BIOS:
    - Поддержка загрузки с дисков объемом до **2.2 ТБ** и выше (до **9.4 зетабайт**) с использованием **GPT** (GUID Partition Table).
    - Работает в **32-битном** или **64-битном** режиме, что позволяет иметь большее адресное пространство и более быстрый запуск системы.
    - В UEFI есть поддержка графики и мыши, что делает интерфейс более удобным, хотя это не обязательно.
    - **Безопасная загрузка (Secure Boot)** — UEFI проверяет целостность загружаемых компонентов, что защищает от загрузки неподписанного или изменённого программного обеспечения.
    - Поддержка сетевых функций в прошивке, что позволяет загружаться через сеть (PXE).
      
    UEFI можно рассматривать как маленькую операционную систему, которая работает поверх прошивки ПК. Она может храниться на флеш-памяти и обладает значительно большими возможностями по сравнению с BIOS.
    
    #### Заключение
    BIOS был основным методом управления запуском системы на протяжении десятилетий, но его ограничения привели к созданию UEFI, более мощного и гибкого стандарта, который поддерживает современные технологии и устраняет недостатки BIOS.

---

### Что такое PXE? Как загрузиться по сети?

- Ответ

    **PXE** (читается как "пикси") — это среда, которая позволяет компьютеру загружаться по сети с помощью сетевой карты. Это особенно удобно для установки операционных систем без необходимости постоянно использовать физические носители, такие как флешки или диски.
    
    #### Как работает PXE:
    
    1. При включении компьютера, последовательность запуска выглядит так:
       - Подача питания → **BIOS** → инициализация сетевой карты через её собственный стек (ЗЧУ).
       - После этого запускается программа сетевой загрузки **NBP** (Network Boot Program), которая загружается с **TFTP-сервера** (Trivial File Transfer Protocol) в оперативную память компьютера.
       - Далее загружается образ операционной системы или установочный образ.

    2. **PXE-код** встроен в ПЗУ сетевой карты. Он отвечает за получение исполняемого файла по сети, используя протокол **TFTP**.

    #### Преимущества PXE:
    PXE позволяет системным администраторам устанавливать операционные системы на компьютеры удалённо, без необходимости использовать физические носители. Это особенно полезно для массовой установки систем в корпоративных сетях.

    #### Настройка PXE-загрузки:

    1. Зайдите в **BIOS** или **UEFI**.
    2. Найдите раздел **Advanced** или похожий, в зависимости от версии BIOS.
    3. Найдите опцию, связанную с загрузкой по сети, такую как **LAN Boot** или **Network Boot**, и включите её.

    #### Примечание:
    - При включённой функции **Fast Boot** сетевые карты могут загружаться через агент сетевой загрузки, например, **Network Atheros Boot Agent**.
    
    Таким образом, PXE позволяет загружать операционные системы напрямую по сети, что упрощает массовую установку и обслуживание системы.

---

### Что такое ядро, initramfs, загрузчик?

- Ответ
    
    **Ядро** - это самый низкий уровень программного обеспечения, которое взаимодействует с аппаратными средствами компьютера. Оно отвечает за взаимодействие всех приложений, работающих в пространстве пользователя вплоть до физического оборудования.
    
    **Initramfs** - основная цель предоставить пользователю его файлы, которые размещены в файловой системе. То есть для ядра нужно найти, примонтировать файловую систему и предоставить пользователю. 
    
    **Загрузчик** операционной системы — системное программное обеспечение, обеспечивающее загрузку операционной системы непосредственно после включения компьютера (процедуры POST) и начальной загрузки.
    

---

### Зачем нужна система инициализации? Какие системы инициализации используются в современных дистрибутивах? (2 - 5 штук) (init)

- Ответ
    
    В операционной системе Linux и других системах семейства Unix после завершения загрузки ядра начинается инициализация Linux системы, сервисов и других компонентов. За это отвечает процесс инициализации, он запускается ядром сразу после завершения загрузки, имеет PID 1, и будет выполняться пока будет работать система.
    
    За время развития операционных систем были созданы различные системы инициализации Linux. В разных дистрибутивах использовались разные системы
    
    Есть init. Это первый процесс, родительский процесс, которые все процессы запускает. Проверка, монитрование файловых систем, запуск служб.
    
    Есть три его варианты работы
    
    **System V init (SysV)**
    
    Это загрузка, основанная на уровне запуска. Обычно их семь. Ну там включение, выключение, режим восстановления и тп.
    
    То есть процесс инициализирует на одном из уровней запуска системы
    
    **SystemD**
    
    Родительский процесс, который запускает инициализацию в ускоренном режиме за счет параллельного запуска задач. Ускоренный режим достигается за счет особенностей работы процессора. И если они позволяют, запускает инициализацию параллельно.
    
    **Upstart**
    
    Здесь запускаются скрипты инициализации, отслеживает события, и реагирует на них. Более гибкий процесс инициализации. Если какая-то служба не запустилась, или вдруг упала, то апстарт это отследит и запустит повторно.
    
---

### Что такое systemd и init ? В чем основное преимущество первого над вторым ?

- Ответ
    И то, и то система инциализации.
    
    В чём конкретно преимущества для меня systemd над init:
    
    - Параллельный старт процессов, в отличие от init
    - Запуск системы с ним быстрее происходит.
    - Не нужно городить костыли на баше — использую простенький
    шаблон для юнитов, в отличие от баш портянки.
    - Не нужно городить километровые пайпы для чтения нужной информации из логов — для всего есть человекопонятные опции;
    - Автоматический рестарт юнитов при падении — не нужно плясать с бубном вокруг ряда сервисов, если выпал один промежуточный;
    - Простая и понятная настройка всего — несколько конфигов (а не тонны, раскиданные по всей системе, как было в легаси) с парами
    ключ=значение;
    - Хорошая документированность (я не говорю, что легаси-набор плохо документирован, я лишь говорю, что systemd не уступает);
    - Он не только загрузчик, но и система инициализирующая демоны
    
---

### Как понять используется ли в системе systemd?

- Ответ
    
    `/run/systemd/` говорит о наличии systemd в системе.
    
    `/run/systemd/system/` - говорит о том, что это активная система инициализации
    
    Можно через stat узнать
    
    Если есть симлинк - используется systemd.
    
    ```
    stat /sbin/init
    File: ‘/sbin/init’ -> ‘../lib/systemd/systemd’
    ```
    

    Можно сделать ещё через процесс 1, и через файловую систему `/proc`:

    ```
    root@swfuse:~# stat /proc/1/exe 
    File: /proc/1/exe -> /lib/systemd/systemd
    Size: 0         	Blocks: 0          IO Block: 1024   symbolic link
    Device: 4h/4d	Inode: 444358      Links: 1
    Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)
    Access: 2022-06-20 00:00:01.579875809 +0000
    Modify: 2022-06-09 17:19:41.581240179 +0000
    Change: 2022-06-09 17:19:41.581240179 +0000
    ```

---

### Опишите, что происходит (с точки зрения процессов), при выполнении любой команды в консоли, например:
`$ ls -l` 

- **Ответ**
    
    При выполнении команды в консоли происходит системный вызов fork(), в результате которого создаётся копия процесса консоли, затем копия процесса выполняет команду с помощью системного вызова exec(). 
    
    После выполнения команды, копия процесса выполняет системный вызов exit(), в результате которого оригинальному процессу консоли отправляется сигнал SIGCHLD (сообщающий о том, что дочерний процесс завершён). 
    
    Во время работы копии процесса, оригинальный процесс находится в ожидании из-за системного вызова wait().
    

---

**Как работает система разграничения доступа к
файлам в linux? Какие возможности она предоставляет?**

- Ответ
    
    [https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-1/](https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-1/)
    
    [https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-2/](https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-2/)
    
    [https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-3/](https://webistore.ru/administrirovaniye-unix/prava-dostupa-k-fajlam-i-direktoriyam-v-linux-chast-3/)
    
    - Оболочка проверяет, являетесь ли вы владельцем файла, к которому вы хотите получить доступ. Если вы являетесь этим владельцем, вы получаете разрешения и оболочка прекращает проверку.
    - Если вы не являетесь владельцем файла, оболочка проверит, являетесь ли вы участником группы, у которой есть разрешения на этот файл. Если вы являетесь участником этой группы, вы получаете доступ к файлу с разрешениями, которые для группы установлены, и оболочка прекратит проверку.
    - Если вы не являетесь ни пользователем, ни владельцем группы, вы получаете права других пользователей (Other).
    

---

### Как посмотреть нагрузку на диски?

- Ответ
    
    Установить утилиту `sysstat`, проверить нагрузку на диски `iostat -xtc`.  
    Использовать утилиту `iotop`, которая показывает процессы, которые активно используют диск.  
    Использовать `dstat` - утилита, которая выводит раз в какое-то время статистику по системным ресурсам. В целом более удобная замена таких утилит как vmstat, iostat, ifstat
    

---

### В чем разница между объявлением переменной `export VAR="VALUE"` и `VAR="VALUE"` в bash?

- Ответ
    
    При объявлении переменной через **export** - переменная будет доступна в любых других процессах. 
    
    При обычном объявлении переменной - переменная будет доступна только в запущенном процессе.
    

---

### Что значит `$@`, `$!`, `$?`, `$$` в bash?

- Ответ
    
    `$@` - показывает все параметры переданные скрипту.  
    `$!` - показывает pid последнего процесса, которая оболочка запустила в фоновом режиме.  
    `$$` - показывает текущий pid процесса.  
    `$?` - показывает с каким кодом завершилась последняя выполненная функция. 0 - успешное выполнение.

    

---

### Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?

- Ответ
    
    ```bash
    cmd 2>&1 >/dev/null | grep pattern
    ```
    

---

### При перенаправлении команд (command1 | command2 ) перенаправляется только stdout. Как сделать так, чтобы stderr тоже перенаправлялся?  

- Ответ
    Либо использовать перенаправление. То есть перенаправляется второй файловый дескриптор туда, куда направлен stdout:  
    `command1 2>&1 | command2`  

    Либо использовать более укороченную версию:    
    `command1 |& command2`  


---

### Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?

- Ответ
    
    Посмотреть полную информацию по дескриптору возможно командой `stat <path_to_file>`. 
    
    Время модификации командой  `stat --format=%y dira`
    

---

### Как работает sudo? Для чего она используется?

- Ответ
    
    
    Sudo позволяет подменить пользователя и выполнить команду от его имени. 
    Расшифровывается именно так - **s**ubstitute **u**ser and **do**
    
    По умолчанию выполнение команды происходит от имени суперпользователя.
    
    Например, вот эта команда
    
    ```bash
    sudo whoami
    ```
    
    И вот эта
    
    ```bash
    sudo -u swfuse whoami
    ```
    
    Будет отличаться результатом.
    
    Можно просмотреть какие полномочия есть с помощью команды:
    
    ```bash
    sudo -l
    ```
    

---

### Что такое userspace, kernelspace? Чем они отличаются?

- Ответ
    
    Под **пользовательским** пространством понимается весь код операционной системы, который находится вне ядра. 
    
    Большинство Unix-подобных операционных систем (включая Linux) поставляются с разнообразными предустановленными утилитами, средствами разработки и графическими инструментами — это все приложения пространства пользователя.
    
    Все пользовательские приложения (и контейнеризированные и нет) при работе используют различные данные, но где эти данные хранятся?
    
     Какие-то данные поступают из регистров процессора и внешних устройств, но чаще они хранятся в памяти и на диске. Приложения получают доступ к данным, выполняя специальные запросы к ядру — системные вызовы. Например, такие как выделение памяти (для переменных) или открытие файла. В памяти и файлах часто хранится конфиденциальная информация, принадлежащая разным пользователям, поэтому доступ к ним должен запрашиваться у ядра с помощью системных вызовов.
    
    Ядро обеспечивает абстракцию для безопасности, оборудования и внутренних структур данных. Например, системный вызов open() используется для получения дескриптора файла в Python, C, Ruby и других языках программирования. Вряд ли бы вы хотели, чтобы ваша программа работала с XFS на уровне битов, поэтому ядро предоставляет системные вызовы и работает с драйверами. Фактически этот системный вызов настолько распространен, что является частью библиотеки POSIX .
    
    [https://habr.com/ru/company/otus/blog/565832/](https://habr.com/ru/company/otus/blog/565832/)
    
- Краткое определние
    - **Пользовательское пространство** представляющее собой набор местоположений, в которых выполняются обычные пользовательские процессы (т. е. все, кроме ядра). Роль ядра состоит в том, чтобы управлять приложениями, работающими в этом пространстве, от взаимодействия друг с другом и с машиной.
    - **Пространство ядра** , то есть место, где хранится и выполняется код ядра.
    
    Пользовательское пространство имеет доступ к ограниченной памяти, ядро имеет всю память.
    
    И чтобы работать приложения взаимодествуют через интерфейс, которое называется системным вызовом.
    

---

### Что такое системные вызовы? Зачем они нужны и как они работают? Какие системные вызовы знаешь (5-10)

- Ответ
    
    **Системный вызов** — это то, посредством чего код приложения, выполняющегося в пользовательском режиме, запрашивает службу, предоставляемую кодом, который выполняется в режиме ядра.
    
    **read** - чтение из файлового дескриптора.
    
    **open** - открывающий и по возможности создающий файл или устройство
    
    **close -** закрыть файловый дескриптор
    
    **access -** проверка пользовательских привелегий для этого файла
    
    **mmap** - служит для отображения предварительно открытого файла (например, с помощью системного вызоваа open()) в адресное пространство вычислительной системы
    
    Команда для вывода всех системных вызовов во время исполнения программы:
    ```bash
    strace -c ls
    % time     seconds  usecs/call     calls    errors syscall
    ------ ----------- ----------- --------- --------- ----------------
      0.00    0.000000           0         4           read
      0.00    0.000000           0         5           write
      0.00    0.000000           0         6           open
      0.00    0.000000           0         9           close
      0.00    0.000000           0         7           fstat
      0.00    0.000000           0        18           mmap
      0.00    0.000000           0        10           mprotect
      0.00    0.000000           0         2           munmap
      0.00    0.000000           0         3           brk
      0.00    0.000000           0         2           rt_sigaction
      0.00    0.000000           0         1           rt_sigprocmask
      0.00    0.000000           0         2           ioctl
      0.00    0.000000           0         6         6 access
      0.00    0.000000           0         1           execve
      0.00    0.000000           0         2           getdents
      0.00    0.000000           0         1           getrlimit
      0.00    0.000000           0         1           arch_prctl
      0.00    0.000000           0         1         1 futex
      0.00    0.000000           0         1           set_tid_address
      0.00    0.000000           0         1           openat
      0.00    0.000000           0         1           set_robust_list
    ------ ----------- ----------- --------- --------- ----------------
    100.00    0.000000                    84         7 total
    
    ```

    
---

### Где можно найти информацию о конкретном системном вызове?

- Ответ
    
    `man 2 <syscall>`
    
    Но нужно будет предварительно поставить пакет `man-pages`
    
    ```
    sudo apt install manpages-dev manpages-posix-dev
    ```
    

---

### Что делает команда kill?

- Ответ
    
    Назначение команды kill - отправить определенный сигнал процессу.
    По умолчанию используется сигнал SIGTERM.

    А вот все  **сигналы** можно глянуть через kill -l, они нужны для взаимодействия между процессами 
    
    ```
    root@swfuse:~# kill -l
     1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
     6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
    11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
    16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
    21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
    26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
    31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
    38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
    43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
    48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
    53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
    58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
    63) SIGRTMAX-1  64) SIGRTMAX
    ```

---

### В чем разница между одинарными кавычками (') и двойными кавычками (")?

- Ответ  
    Одинарные кавычки ('):  
    Трактуют всё внутри них как текст. Если там есть переменные, то они раскрыты не будут
    Не позволяют подставить переменнные или выполнить команду.   


    Двойные кавычки ("):  
    Позволяют подставлять переменные.   
    Позволяют подставить обратные кавычки для выполнения комманд  

    Одинарная кавычка (переменная в выводе не подставляется, а выводится как текст):   
    ```
    $ echo 'URL = https://$MYVAR.ru'
    URL = https://$MYVAR.ru
    ```
    Двойная кавычка (переменная в выводе подставляется как значение):  
    ```
    $ echo "URL = https://$MYVAR.ru"
    URL = https://swfuse.ru  
    ```  

    Одинарная кавычка (выводит текст явно):    
    ```
    echo 'Сегодняшняя дата: `date`'  
    Сегодняшняя дата: `date`  
    ```  

    Двойная кавычка (внедряет результат выполнения команды в строку):  
    ```
    $ echo "Сегодняшняя дата: `date`"
    Сегодняшняя дата: Wed Sep 18 10:59:45 RTZ 2024
    ```  

---

### Приложение запущено как сервис - как посмотреть то, что оно написало в stdout?  
  - Ответ
    Либо попытаться найти логи юнита, если это что-то systemdшное. Как правило такие сервисы пишут логи.  
    `sudo journalctl -u [юнит, который нам нужен]`   

    Либо попытаться найти в какой файл пишет процесс  
    `lsof -p PID | grep -E 'w|u'`  

    Либо попытаться вывести его stdout через `strace`    
    `strace -e write -s 9999 -p 12345`   
    -e write - тут отслеживаем только системные вызовы write
    -s 9999 - показывать по 9999 символов в строке, чтобы точно всё влезло
    -p PID - интересующий нас идентификатор процесса. 

    Но strace может замедлить работу процесса. И вывод нужно будет еще как-то интерпретировать, раскрыть.  

    Например программа выводит в stdout следующее:
    ```
    Привет, это тестовое сообщение!
    Привет, это тестовое сообщение!
    ```
    А в strace это будет выглядеть вот так:
    ```
    write(1, "\320\237\321\200\320\270\320\262\320\265\321\202, \321\215\321\202\320\276 \321\202\320\265\321\201\321\202\320\276\320\262\320\276\320\265 \321\201\320\276\320\276\320\261\321\211\320\265\320\275\320\270\320\265!\n", 58) = 58
    write(1, "\320\237\321\200\320\270\320\262\320\265\321\202, \321\215\321\202\320\276 \321\202\320\265\321\201\321\202\320\276\320\262\320\276\320\265 \321\201\320\276\320\276\320\261\321\211\320\265\320\275\320\270\320\265!\n", 58) = 58
    ```


---

### Текущая load average на сервере - 900, 900, 900. Сервер работает с незначительной потерей производительности. Каким образом можно понять, является ли это нормальной ситуацией? 

- Ответ
    
    Я бы начал с того, что бы понял а что вообще вызывает проблему, и что на сервере важное. Что работает, а что не работает.
    
    Если сайтики не открываются на работающем сервере все - проблема.
    Если проблема только с одним, то копать.
    А может быть все важные функции работают для работы сайтов или сервисов. 
    
    И допустим нужно писать данные или читать данные на что-то медленное. Система не тормозит, но из-за того, что процессы записи чтения на медленный девайс скопились - ЛА подросла.  В этом случае будет высокая wa
    При этом все остальные процессы отрабатывают быстро
    
    На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр *wa*
     в утилите *top*
    ) в дисков и задержка сети. Данные параметры могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему.

    Иными словами на сервере с активными приложениями высокий LA скорее всего будет проблемной ситуацией. 
    А на сервере с бэкапами высокий LA может проблемой не быть. Поскольку туда постоянно пишутся данные, и la растет просто из-за того, что копятся процессы, которые ожидают очереди записи на диск.
    

---

### Что такое процесс? Что такое тред? В чем заключаются их главные отличия?

- Ответ
    
    **Процесс** - это исполняемая программа. Когда программист пишет программу и выполняет ее, эта программа становится процессом. Он выполняет задачи в соответствии с инструкциями программы.
    
    **Процесс** - это экземпляр выполняемой компьютерной программы. 
    **Поток** - это компонент процесса, который является самой маленькой исполнительной единицей.
    
    Можно представить процессы и потоки на примере задачи "Починка дороги".
    
    Хорошо, как я могу построить дорогу, поэтому мне нужен какой-то ресурс для строительства, верно?
    
    Выделяемые ресурсы:
    
    1. Граница дороги (область)
    - Технически мы можем назвать это виртуальным адресным пространством, оно имеет уникальный идентификатор процесса для идентификации работы.
    - Доступ к ограниченной границе области. Контекст безопасности
    - Также, вы можете сопоставить другие свойства процесса с приведенным выше примером (окружение, приоритет и т.д.)
    
    1. Жесткое или рабочее пространство
    - Количество "оборудования или рабочей силы" основано на мышлении подрядчика; предположим, что он хочет закончить работу быстро, тогда он должен назначить больше людей на эту работу.
    - Т.е. каждый работник может получить доступ к этой ограниченной территории (общее пограничное пространство).
    - Для начала работы нужен хотя бы один человек один поток.
    - У каждого человека есть свой идентификатор
    
    Ключевая разница
    
    - Процесс означает, что программа выполняется, а поток означает сегмент процесса.
    - Процесс не является легковесным, тогда как потоки - легковесными.
    - Процессу требуется больше времени для завершения, а потоку требуется меньше времени для завершения.
    - Процесс требует больше времени для создания, тогда как поток требует меньше времени на создание.
    - Процессу, требуется больше времени для переключения контекста, тогда как потокам требуется меньше времени для переключения контекста. 
    - **Процесс в основном изолирован, тогда как потоки разделяют память.**
    - Процесс не обменивается данными, а потоки обмениваются данными друг с другом.

---

### Где в linux хранится информация о процессах?

- Ответ
    
    Директория `proc/PID`
    
    Информация о процессах хранится в директориях /proc/N, где N — числовой идентификатор процесса. В этой директории содержатся различные псевдо-файлы, которые содержат информацию о самом процессе и связанном с ним окружении.
    
    **/proc/N/cmdline** — Содержимое командной строки, которой был запущен процесс.
    
    **/proc/N/environ** — Описание окружения, в котором работает процесс. Оно может быть полезно для просмотра содержимого окружения, если вам надо, например, посмотреть, была ли установлена переменная окружения перед запуском программы.
    
    **/proc/N/exe** — Символическая ссылка на выполнимый файл запущенной программы.
    
    **/proc/N/limits** — Лимиты на использование системных ресурсов, актуальные для работающего процесса.
    
    **/proc/N/mounts** — Список смонтированных ресурсов, которые доступны процессу
    
    **/proc/N/status** — Статус работающей программы. Он включает в себя такую информацию как идентификатор родительского процесса, статус самого процесса, его название, его идентификатор, идентификатор пользователя и группы, группы, в которые входит владелец процесса, сколько потоков использует процесс, сколько памяти он использует и так далее.
    
    В этой же директории содержится несколько псевдо-директорий:
    
    **/proc/N/cwd** — Текущая директория для процесса. Представлена символической ссылкой на директорию. Если рабочая директория для процесса изменится, изменится и ссылка.
    
    **/proc/N/fd** — Файловые дескрипторы, которые используются процессом. Для программы bash, например, там по умолчанию будут дескрипторы 0, 1, 2 и 255, указывающие на виртуальный терминал, в котором запущен процесс, например, /dev/pts/6.
    
    **/proc/N/fdinfo** — Информация о файловых дескрипторах. Каждый файл в этой директории содержит поля pos (позиция курсора), flags (флаги, с которыми этот дескриптор был открыт) и mnt_id (идентификатор точки монтирования из списка, содержащегося в файле /proc/N/mountinfo)
    
    **/proc/N/root** — Символическая ссылка на директорию, которая для данного процесса является корневой
    
    **/proc/N/net** — Сетевые системные ресурсы и их параметры, действующие для конкретного процесса.
    

---

### Приложение пишет в логи too many opened files, как это диагностировать?  
- Ответ  
  Сначала проверить лимиты для данного процесса:    
  `grep "Max open files" /proc/PID/limits`   

  Также можно посмотреть лимиты для текущего пользователя:      
  `ulimit -n`    

  Имеет смысл посмотреть лимиты systemd.  
  Что-то типа по пути: `/etc/systemd/system/<service_name>.service`   
  Можно найти такие строчки:
  ```
  [Service]
  LimitNOFILE=10
  ```  

  Также можно заглянуть в лимиты по пути `/etc/security/limits.conf`, пример вывода:
  ```
  *           hard    nofile     65535
  *           soft    nofile      8192       # Required for certain games to run.
  ```

  Также пожно глянуть сколько вообще открыто файлов процессом.    
  `lsof -p PID`  

  Через `strace` процесса можно глянуть какие процессы открываются, и, возможно, не закрываются.  
  `strace -e trace=open,close -p PID`   
  

---

### Как заставить приложение перестать писать в файл, не завершая процесс?   
- Ответ    
  Ищем нужный нам файловый дескриптор через `lsof -p $PID`    
  Например, это процесс с номером 1737, и файловым дескриптором 77.      
  
  Вариант с gdb:
  ```
  gdb -p 1737
  ....
  (gdb) p close(77)
  $1 = 0
  ...
  ```

  Вариант с exec:  
  `exec 77>&-`

     



---

### Что такое CPU pinning

- Ответ

  Это механизм который прекреплять определенный процесс или поток к определенному ядру, что позволяет допустим прикреплять определенный конетйнер к определенному ядру, что убирает  позволяет убрать тротлинг(механизм когда процессор при сильном перегреве понижает частоты).
  
---

### Какие алгоритмы планирования ресурсов в linux ты знаешь

- Ответ
  
  **Довольно редкий вопрос на самом деле**

  **CPU**:
   Completely Fair Scheduler (CFS) - когда в очередь ставятся процессы на основе их приоритета и времени исполнения
   Round Robin - когда на выполнения процессов выделяется определенное время для их выполнения процессором
   Shortest Job First(SJF) - когда процесс с наименьшем временем выполнения получает наивысший приоритет
   Multi-Level Feedback Queue (MLFQ)- когда динамически меняется приоритет процесса на основне его поведения.

  **Ввод/Вывод**:
   Completely Fair Queuing (CFQ) - Когда ставяться в очередь процессы на основе их приоритета, и пытается обеспечить равномерное распределение на все запросы.
   first come first serve (FCFS) - когда очеред операций обрабатывается в порядке поступления
   Deadline - когда алгоритм гарантирует, что запрос на диск будет обработан в заданный срок

  **Память**:
   Slab Allocation - когда кэшируются объекты одного типа вместе, что бы уменшить накладные ресурсы на выделение и освобождения памяти.



---

### Представлен вывод команды *top*. Что означает каждая запись в выводе?

```bash
top - 10:44:36 up 91 days, 19:29,  7 users,  load average: 0,00, 0,02, 0,05
Tasks: 156 total,   1 running, 155 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,0 us,  1,5 sy,  0,0 ni, 96,9 id,  0,0 wa,  0,0 hi,  0,0 si,  1,5 st
KiB Mem : 12137392 total,  6227844 free,  1117728 used,  4791820 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 10090148 avail Mem
```

- Ответ
    
    top - утилита
    
    10:44:36 — время системы
    
    up - сколько система работает с момента последнего запуска
    
    7 user - количество авторизованных юзеров в системе
    
    load average: 0.00, 0.02, 0.05 - параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут
    
    156 total - всего процессов в системе
    
    1 running - количество процессов в работе
    
    155 sleeping - ожидание процесса или сигнала
    
    0 stopped - количество приостановленных процессов сигналом STOP или выполнение трассировки
    
    0 zombie -  количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения.
    
| параметр                    |   описание                                                                                                                                                                                                                                             |
|-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|us (user)                    |Использование процессора пользовательским процессами                                                                                                                                                                                                    |
|sy (system)                  |Использование процессора системным процессами                                                                                                                                                                                                           |
|ni (nice)                    |Использование процессора процессами с измененным приоритетом с помощью команды nice                                                                                                                                                                     |
|id (idle)                    |Простой процессора. Можно сказать, что это свободные ресурсы                                                                                                                                                                                            |
|wa (IO-wait)                 |Время на простой, то есть ожидания переферийных устройств ввода вывода                                                                                                                                                                                  |
|hi (hardware interrupts)     |Показывает сколько процессорного времени было потрачено на обслуживание аппаратного прерывания. (Аппаратные прерывания генерируются аппаратными устройствами. Сетевыми картами, клавиуатурами, датчиками, когда им нужно о чем-то просигнализировать цп.|
|si (software interrupts)     |Показывает сколько процессорного времени было потрачено на обслуживание софтверного прерывания. Фрагмент кода, вызывающий процедуру прерывания                                                                                                          |
|st (stolen by the hypervisor)|Показывает сколько процессорного времени было «украдено» гипервизором. Для запуска виртуальной машины, или для иных нужд                                                                                                                                |


    
    **KiB Mem** - количество оперативной памяти в кибибайтах (кратно 1024): *7106404 total* -- всего доступно оперативной памяти в системе, *306972 free* -- свободно оперативной памяти для использования, *3127144 used* -- использовано оперативной памяти, *3672288 buff/cache* -- буферизовано/закешировано оперативной памяти.
    
    **KiB Swap** - количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске: *8191996 total* - всего выделено swap-памяти, *8191996 free* - свободно swap-памяти *0 used* - использовано swap-памяти, *3270520 avail Mem* - доступно для использования swap-памяти.
    

---

### Что такое swap файл (подкачки)? Зачем он нужен, и как он работает? Какие данные в него записываются?  
  - Ответ   
  
    Нужно начать с понятия подкачки, зачем она нужна.   

    Зачем она нужна:  
    1. Если системе требуется больше памяти, чем физически доступно, ядро выгружает менее используемые страницы и отдает память текущему приложению, процессу, которому память нужна немедленно.   
    2. Значительное количество страниц могут использоваться только для инициализации. Система может выгрузить эти страницы и освободить память для других приложений и ядра.   

    Минусы понятия файла\раздела подкачки:
    * По сравнению с оперативной памятью диски довольно медленные. В памяти обработка происходит в пределах наносекунд, в дисках уже милисекунды. То есть разница в десятки тысяч раз. 
      И чем больше операций подкачки - тем медленнее работает система. Или же случаи, когда страница выгружается, а затем снова заменяется.   
      То есть система пытается найти баланс между свободной памятью и поддержкой работы приложений, и скачет туда сюда. И тут поможет скорее только добавление оперативки. 

    По поводу самой подкачки - это может быть как файл подкачки. Так и раздел подкачки.  
    **Раздел подкачки** - это, собственно, отдельный раздел диска исключительно для файла подкачки. Никакие другие файлы там не могут находиться.   
    **Файл подкачки** - это специальный файл в файловой системе.  
    Через команду `swapon -s` можно увидеть информацию о подкачке, в том числе раздел это или файл.    
    ```
    Filename  Type       Size       Used Priority
    /dev/sda5 partition  859436  0       -1
    ```
    Тут мы видим в качестве примера что это раздел. Что сейчас пространство не использовано.  

    В линуксе есть понятие **Swappiness** - это свойство в ядре Linux, которое меняет баланс между подкачкой времени выполнения и удалением страниц из кеша системы.  
    Значение устанавливается от 0 до 100 включительно.  
    Низкое значение означает, что ядро будет стараться избегать использования файла подкачки настолько, насколько это возможно.  
    Высокое - заставит ядро активно использовать пространство подкачки.   

    Чем подкачка **не является** - так это аварийной памятью, которая используется, когда что-то идет не так.    
    Есть понятие анонимных страниц. Которые не имеют какого-то резервного хранилища. В случае удаления - их восстановить нельзя.   
    Анонимная память\анонимные страниы это такоие страницы виртуальной памяти, которые не связаны с файлами на диске.    
    Они создаются как бы на лету. И там хранятся временные данные процесса.   
    И вот подкачка это хорошая область где можно сохранять такие страницы.   

    И подводя итог - необходимость в использовании swap файла возникает тогда, когда система не может удержать в пмяти необходимый кэш и грязные страницы. То есть это не экстренная память. 
    А та паммять, которая позволяет системе эффективнее управлять кэшем и грязными страницы.  
    Что в итоге влияет на общую производительность системы.  

    **Кэш памяти** - Это буфер в оперативной памяти, где система хранит копии данных с диска, которые недавно использовались или могут понадобиться в ближайшее время.  Нужен для ускорения работы, и уменьшения нагрузки на диск.  

    Пример:  
    Когда открывается файл - его содержимое читается с диска и сохраняется. в кэше. Что при дальнейшем повторном открытии системы позволяет системе взять данные из кэша.  
    
    **Грязные страницы (Dirty Pages)** - это те страницы в памяти, которые поменяли, но ещё не записали. 
    
    Пример: При открытии текстового редактора вы можете что-то внести. И вот пока вы файл не сохранили - данные считаются грязными. После записи - страницы становятся "чистыми". (Тут есть нюанс что некоторые редакторы промежуточные данные все равно могут сохранить на диск, но здесь пример больше для понимания).   

    И такие данные система удалить не может из памяти, их нужно записать на диск. И большое количество данных может замедлить работу системы.    

    **Обобщенный пример:**  
    Можно представить память как ваш стол, за которым работаете.  
    Кэш - это документы, которые вы оставили на столе чтобы иметь к ним быстрый доступ. Их можно в любой момент убрать в ящик. Ну или "удалить" если говорить про систему.
    А грязные страницы это как черновики. И они нам нужны для дальнейшей работы, и прежде чем их убрать - перенести в чистовик. Иначе наша работа насмарку пойдет. 

    **Как ядро работает с памятью?**   
    Вся память, которой оперирует система, разбита на страницы. Каждый процесс в системе имеет свое «плоское» адресное пространство. Для каждого процесса система поддерживает карту страниц — какая страница адресного пространства процесса (страница виртуальной памяти) отображена в какую страницу физической памяти - если вообще отображена, разумеется.  

    И когда процесс пытается получить доступ к какой-то странице своей памяти, MMU (memory management unit) процессора фактически производит обращение к той странице физической оперативной памяти, куда страница отображена.  

    А если страница не отображена ни в какую физическую страницу, то возникает page fault — исключительная ситуация «страница не найдена». При обработке этой ситуации система (ядро) проверяет, имеет ли процесс право получить доступ к своей логической странице: если не имеет (например эта страница заразервирована ядром или находится «за хвостом кучи» процесса) - то процессу придет сигнал `SEGFAULT` — и процесс умрет.  

    А если имеет — то ядро выполнит все нужные действия, чтобы восстановить правильное содержимое страницы, и предъявит её процессу - после чего операция успешно выполнится.

    **Примеры поведения**:   
    **Недостаток памяти, ее отсутствие**:  
    При файле подкачки: можем заменить редко используемую анонимную память. Что позволит и память освободить, и оптимизировать частоту обращений в кэш. 
    Без файла подкачки: Мы не можем выгрузить анонимную память, поскольку она заблокирована. Что может привести к нетривиальному падению производительности.    

    **При скачках при потреблении памяти**  
    При файле подкачки: мы можем отсрочить отрабатывание оом киллера. И успеть с этим что-то сделать.    
    Без подкачки: оом срабатывает быстрее. Плюс заблокированы анонимные страницы памяти.   
    

    Когда памяти становится мало, то алгоритм следующий:  
    * Система может попытаться удалить страницы кэша. Их можно просто заново прочитать с диска  
    * Грязные страницы перед удалением нужно записать сначала на диск, их просто так система не удалит  
    * Анонимные страницы (например данные процессов) можно выгрузить в swap.    

    Полезные ссылки для ознакомления:  
    https://basis.gnulinux.pro/ru/latest/basis/49/49._%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%2C_swap.html  

    Особенно рекомендую эти две стаьи от Артемия:    
    https://habr.com/ru/articles/540104/    
    https://habr.com/ru/post/541214/  

---

### Что показывает статус процессов? Какие статусы используются в linux?

- Ответ
    
    ```bash
    R - процесс исполнется, или ждет своей очереди на исполнение
    S - прерываемый сон - процесс ожидает определенного события или сигнала. 
    Нужен, когда процесс нельзя завершить (чтение из файла), ядро переводит на ожидание.
    Ожидать данные от сетевого соединения
    D - непрерывное ожидание, сон. Ждем сигнал от аппаратной части.
    T - остановка процесса, посылаем сигнал STOP. В этом состоянии процессу запрещено выполняться
    Чтобы вернуть к жизни нужно послать CONT
    При завершении процесса он становится зомби
    Z(zombie) - зомби это процесс, который закончил выполнение, но не передал родительскому процессу
    свой код возвращения. Процесс в этом состоянии игнорирует kill. 
    Родитель получает код, и освобождает структуру ядра, которое относится к процессу
    Бывает еще когда родительский умирает раньше дочернего. Процесс становится сиротой. 
    ```
    

---

### Что такое зомби-процесс? Как можно создать такой процесс?

- Ответ
    
    ```bash
    Z(zombie) - зомби это процесс, который закончил выполнение, но не передал родительскому процессу
    свой код возвращения. Процесс в этом состоянии игнорирует kill. 
    
    ```
    
    ```bash
    #include «stdlib.h>
    #include <sys/types.h>
    #include <unistd.h>
    int main() {
     pid_t child_pid;
     /* Создание дочернего процесса. */
     child_pid = fork();
     if (child_pid > 0) {
      /* Это родительский процесс — делаем минутную паузу. */
      sleep(60);
     } else {
      /* Это дочерний процесс — немедленно завершаем работу. */
      exit(0);
     }
     return 0;
    }
    ```
    
    Другой вариант создания зомби процесса, попроще:  
    `(sleep 1 & exec /bin/sleep 10)`  

    #### Процесс создания зомби-процесса

    Зомби-процесс — это процесс, который завершился, но его статус завершения не был считан родительским процессом. Рассмотрим, как происходит создание зомби-процесса:

    1. Родительский процесс (например, оболочка) создаёт дочерний процесс для выполнения команды в скобках.
    2. Внутри этого дочернего процесса запускается команда `sleep 1` в фоновом режиме.
    3. Сразу после этого выполняется команда `exec /bin/sleep 10`, которая заменяет дочерний процесс на `sleep 10`.
    4. Когда `sleep 1` завершает своё выполнение (через 1 секунду), его родительский процесс уже не может обработать его завершение, так как был заменён на команду `sleep 10`.
    5. В результате, процесс `sleep 1` становится **зомби-процессом**, ожидая, пока его статус завершения будет считан. Однако, этого не происходит, потому что родительский процесс уже выполняет другую программу — `sleep 10`.

    Зомби-процесс будет существовать до тех пор, пока не завершится команда `sleep 10` (через 10 секунд), после чего родительская оболочка сможет обработать завершение всей составной команды. 

    Это происходит потому, что команда `exec` заменяет текущий процесс на другой без создания нового процесса, и, следовательно, не может корректно обработать завершение предыдущего дочернего процесса.
    
    #### Интересная тонкость
    
    Каждый процесс, при завершении, временно становится зомби до тех пор, пока родительский процесс не считает его статус завершения. Это совершенно нормальное поведение системы, и короткоживущие зомби-процессы не представляют проблемы.
    
    Однако, ошибки программирования могут привести к накоплению **необрабатываемых зомби-процессов** — процессов, которые завершились, но их статус не был считан родительским процессом. Это может негативно сказаться на работе системы, так как зомби-процессы продолжают занимать записи в таблице процессов.




---

### Чем опасны зомби процессы, какие проблемы они могут создать?

- Ответ
    
    Зомби не занимают памяти (как [процессы-сироты](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%81%D0%B8%D1%80%D0%BE%D1%82%D0%B0)
    ), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
    
    При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор *sh* должен создать новый процесс)
    
    Иногда, если родительский процесс выполняется от имени суперпользователя, для освобождения записей (перезапуска процесса) может потребоваться перезагрузка (причём зачастую — только аппаратным рестартом). Некоторые операционные системы (например, [Sun Solaris](https://ru.wikipedia.org/wiki/Solaris)
    ) при возникновении такой ситуации аварийно завершают часть выполняющихся процессов, восстанавливая работоспособность системы.
    

---

### Можно ли завершить зомби процесс с помощью SIGKILL?
 - Ответ
    Нет, не может. Поскольку зомби процесс уже завершен. И не может принимать сигналов. И тут зомби ожидает что родительский процесс считает код завершения с помощью системного вызова wait.

---

### Что такое SIGCHLD? В какой ситуации процесс может его получить?

- Ответ
    
    В POSIX-системах SIGCHLD — сигнал, посылаемый при изменении статуса дочернего процесса (завершён, приостановлен или возобновлен).
    
    Допустим дочерний процесс завершил выполнение и все
    

---

### Что такое файловый дескриптор, какая информация в нем бывает?

- Ответ
    
    *Файловый дескриптор*
     - неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (kernel) для идентификации ресурсов файла / сокета. Когда создаётся новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор.
     Важно отметить, что файловые дескрипторы не ограничиваются только файлами. 
     Они также могут ссылаться на каталоги, сокеты, каналы (pipes), устройства ввода-вывода и даже некоторые специфические для процесса ресурсы, такие как файлы процесса и области памяти.
     Операционная система автоматически создает три файловых дескриптора для каждого процесса: 0 (стандартный ввод), 1 (стандартный вывод) и 2 (стандартный вывод ошибок).
    

---

### Для чего нужны сигналы? Какие сигналы используются чаще всего? (5 - 10 штук)

- Ответ
    
    Это уведомление процесса о наступившем событии. Также это способ взаимодйествия между процссами.
    `SIGTERM (15)` - запрос на "мягкое завершение процесса.  
    `SIGKILL (9)` - принудительное завершение процесса.  
    `SIGINT (2)` - прерывание процесса. (Например нажатие Ctrl-C)  
    `SIGSTOP (10)` - приостановка процесса.   
    `SIGCONT (18)` - возобновить работу процесса.   
    `SIGHUP (1)` - перезагрузка конфигурации (например можно так сделать релоад nginx)   

    Сигналы `SIGKILL` и `SIGSTOP` нельзя перехватить, блокировать или игнорировать.   





---

### Как осуществляется обработка сигналов? Чем отличается SIGTERM от SIGKILL?

- Ответ
    
    SIGTERM завершает программу. Это как бы мягкое уничтожение. И по умолчанию при вводе команды kill - используется именно он.SIGKILL - немедленное прекращение выполнение процесса. Процесс будет завершен с потоками. Используется как последнее средство. (kill)
    
    Сигнал SIGKILL передается процессу, чтобы заставить его немедленно завершиться. В отличие от SIGTERM и SIGINT, **этот сигнал не может быть перехвачен или проигнорирован, и процесс получения не может выполнить очистку после получения этого сигнала.**
    
    Он нужен в критических ситуациях, когда повис процесс.
    
    Проблема использования sigkill:  
    SIGKILL убивает дочерние процессы.И в этом случае может появиться процесс зомби.  
    Уничтоженный процесс не имеет возможности сообщить родителю о том, что у него был сигнал уничтожения. (kill9)
    
    

---

### Какой сигнал получит активный процесс при нажатии Ctrl+C в консоли?

- Ответ
    
    SIGINT (от англ. signal и interrupt — прервать) — сигнал, применяемый в POSIX-системах для остановки процесса пользователем с терминала.
    

---

---

### Какие сигналы не могут быть проигнорированы?  
- Ответ  
    SIGSTOP - принудительная остановка процесса    
    SIGKILL - немедленное завершение процесса    

---

### Что такое load average? Что показывает эта метрика? Почему load average состоит из трёх значений?

- Ответ
    
    Часто говорят что это средняя загрузка процессора или нагрузка системы, или какие-то циферки.
    Узнать значение la можно разными способами. Например, uptime, top, и другими командами.
    
    Принято считать, что какое-то стабильное значение этих цифр отражает стабильное поведение системы. 
    Появление всплеска может означать появление проблемы в системе.  Что-то идет не так, копятся процессы.
    Цифры обозначают нагрузку за определенный период времени. 1, 5 и 15 минут. (Это важно учесть, это все рассчитывается для предыдущего времени. И когда вы заходите на сервер спустя минуту - там может ничего не быть)
    
    
    **Определение LA по сути - эта цифра показывает количество процессов в статусе d r (ожидание, запущено соответственно)**
    А дальше уже всё будет зависеть от ситуации.
    Допустим у нас сервер есть где постоянно на диски пишутся резервные копии. Там LA будет высокая скорее всего. Просто потому что есть процессы в статусе d, которые копятся из-за того, что диск занят. 
    Но на работу системы в целом это может не влиять вообще.

    Если процессов скопилось много там, где это не ожидается, ну там сервера с сайтами, базами данных, с php-fpm, nginx и прочим таким, то смотрим через `top -cHi -d1` что там именно скопилось. 
    И в таких вот случаях сервер может тупить, ибо будут копиться процессы в статусе r. Из-за чего работа сервера будет медленной. Даже по ssh иногда не зайти будет.


    **если коротко** это кол-во процессов и операций ввода/вывода которые находяться в ожидание 
    процессорного времени(исполнения процессором) за 1, 5, 15 минут
    
    

---

### Можно ли сделать так, чтобы пользователи могли получать информацию только о своих процессах?

- Ответ
    
    Да, можно, за это отвечает параметр hidepid
    
    ```bash
    myserver : ~ [0] # cat /proc/mounts | grep proc
    proc /proc proc rw,nosuid,nodev,noexec,relatime,hidepid=2 0 0
    ```
    

---

### Что такое физическая память?

- Ответ
    
    **Физическая память** (или ***«ОЗУ»***, ***«RAM»***, ***«оперативка»***) — это энергозависимая память, установленная в компьютере. Для её работы требуется непрерывный поток электричества. Перебои с электропитанием или внезапное выключение компьютера могут привести к стиранию хранящихся в ней данных. Кроме того, эта память является линейно адресуемой. Другими словами, значения адресов памяти увеличиваются линейным образом.
    
    Запуская и исполняя программы, процессор напрямую обращается к физической памяти. 
    Обычно программы хранятся на жестком диске. Время доступа процессора к диску значительно превышает аналогичное время доступа к физической (оперативной) памяти.   
    Чтобы процессор мог выполнять программы быстрее, они сначала помещаются в физическую (оперативную) память. После завершения своей работы, они возвращаются обратно на жесткий диск.  
    Освобожденная таким образом память может быть выделена новой программе. При выполнении данные программы называются **процессами**. 
    

---

### Что такое виртуальная память?

- Ответ
    
    Виртуальная память (или «логическая память») — это метод управления памятью, осуществляемый операционной системой, который позволяет программам задействовать значительно больше памяти, чем фактически установлено в компьютере.   
    Например, если объем физической памяти компьютера составляет 4 ГБ, а виртуальной 16 ГБ, то программе может быть доступен объем виртуальной памяти вплоть до 16 ГБ.  
    
    Основное различие между физической и виртуальной памятью заключается в том, что физическая память относится к оперативной памяти компьютера, подключенной непосредственно к его материнской плате.  
    Именно в ней находятся выполняемые в данный момент программы. 
    А виртуальная память — это метод управления, расширяющий при помощи жесткого диска объем физической памяти, благодаря чему у пользователей появляется возможность запускать программы, требование к памяти которых превышает объем установленной в компьютере физической памяти. 
    
    ![memory-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%201.png)
    
---

### Почему в htop может быть не до конца корректная сводка по потребляемой памяти

- Ответ (спорный)
Hop не всегда корректно показывает сколько памяти приложение потребляет по факту.
Пункт VIRT там это скорее параметр, который указывает сколько приложение запросило как бы запросило (про запас), а не сколько использует по факту. 
И в этом плане на этот параметр лучше не полагаться.
Для анализа используемой памяти лучше использовать скрипт `ps_mem.py`. Он показывает сколько памяти съедается по факту тем или иным процессом, группой процессов. 
Можно найти по ссылке:
https://github.com/pixelb/ps_mem  


---

### Где в системе можно посмотреть сводку по текущему потреблению памяти?

- Ответ
    
    ```bash
    free -m
    ```
    ```
                   total        used        free      shared  buff/cache   available
    Mem:            3923         309         231           2        3382        3318
    Swap:              0           0           0
    ```
    Эта утилита не показывает физическое количество памяти.   
    Она показывает сколько памяти доступно в системе.  
    То есть физически сколько заняло ядро.  

    `total` - 3923 мегабайт - Она показывает сколько памяти у нас в системе.    
    `used` - 309 мегабайт - сколько у нас памяти занимают исполняемые процессы.     
    `free` - 231 мегабайт - ненужная в данный момент память. То есть если надо будет системе - она ее займет.  
    `shared` - 2 мегабайта - shared память для межпроцессорного взаимодействия. Чтобы поделиться памятью из одного процессора в другой.   
    `buff/cache` - буффер - память для компоновки данных. Страничный кэш - это то, с помощью чего мы например можем файлы открывать.   


    **Почему линукс съедает память?**
    Потому что процесс который запрашивает данные из файла на диски - он данные выгружает в оперативную память.   
    Чем больше процессов просит данных - тем больше кэша, свободной памяти становится меньше.   
    Однако, единожды загруженный файл в кеш - может там остаться даже если приложение, которое это инициировало - завершилось.  
    Поскольку операции доступа до диска это дорогие по времени операции.  
    И ядро считает, что стоит сохранить какие-то из данных, не чистить их сразу. На тот случай, если кому-то еще эти данные понадобятся. 

    Итого свободная память - это та память которая ни нужна ни для кэша, ни для чего-то ещё.  
    `available` - 3381 мегабайт может быть доступно в случае необходимости.  
    Если available нет, то его в примерном виде можно посчитать так: free + 70% от кэша.   
    Ибо не во всех дистрибутивах этот показатель есть.  

    **Какие ситуации будут указывать на возможную проблему?**  
    * Available память или ( free -/+ buffers/cache ) близки к нулю или очень маленькое значение.  
    * В логах ядра есть сообщения `OutOfMemory`. (`dmesg -T | grep out of memory`)

---

### Как работает оом киллер и для чего нужен? Out of memory, oom

- Ответ
    
    Когда на вашем Linux-компьютере заканчивается память, ядро вызывает Убийцу нехватки памяти (OOM) для освобождения памяти. Это часто встречается на серверах, на которых запущен ряд процессов с интенсивным использованием памяти.
    
    Оом киллер освобождает память для спасения системы, но чтобы процессы освобождаемые были наименее важны для системы.
    
    У нас не только физическая и виртуальная память может закончиться. А если процесс потребляет страницу определенного размера, то могут быть не очень хорошие вещи.
    
    Ядро Linux дает оценку каждому запущенному процессу, называемому **oom_score**, которая показывает, насколько вероятно, что он будет остановлен в случае нехватки доступной памяти. 
    
    Оценка пропорциональна количеству памяти, используемой процессом. Оценка - 10% процентов памяти, используемой процессом. Таким образом, максимальная оценка составляет 100% x 10 = 1000.
    
    [https://github.com/hightemp/docLinux/blob/master/articles/Linux OOM killer - выживание.md](https://github.com/hightemp/docLinux/blob/master/articles/Linux%20OOM%20killer%20-%20%D0%B2%D1%8B%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.md)
    

---

### Как процессы в системе взаимодействуют между собой?

- Ответ
    
    **Трубы(пайпы '|')** — связь между двумя взаимосвязанными процессами. Механизм является полудуплексным, что означает, что первый процесс связан со вторым процессом. Для достижения полного дуплекса, т. Е. Для взаимодействия второго процесса с первым процессом требуется другой канал.
    
    **FIFO** — Связь между двумя не связанными процессами. FIFO — это полный дуплекс, что означает, что первый процесс может взаимодействовать со вторым процессом и наоборот одновременно.
    
    **Очереди сообщений** — связь между двумя или более процессами с полной дуплексной пропускной способностью. Процессы будут связываться друг с другом, отправляя сообщение и извлекая его из очереди. Полученное сообщение больше не доступно в очереди.
    
    **Совместно используемая память.** Связь между двумя или более процессами достигается за счет совместного использования памяти всеми процессами. Совместно используемая память должна быть защищена друг от друга путем синхронизации доступа ко всем процессам.
    
    **Семафоры** — семафоры предназначены для синхронизации доступа к нескольким процессам. Когда один процесс хочет получить доступ к памяти (для чтения или записи), он должен быть заблокирован (или защищен) и освобожден при удалении доступа. Это должно быть повторено всеми процессами для защиты данных.
    
    **Сигналы** — Сигнал — это механизм связи между несколькими процессами посредством сигнализации. Это означает, что исходный процесс отправит сигнал (распознанный по номеру), а целевой процесс обработает его соответствующим образом.
    
    **Примечание.** Почти все программы в этом руководстве основаны на системных вызовах в операционной системе Linux (выполняется в Ubuntu).
    

---

### a=5; true | { true && a=10; } чему будет равно a?

- Ответ будет 5.
    Потому что каждая команда конвейера исполняется в отдельной подоболочке (SubShell)
    ```
    nparamonov@peka:~$ a=5; true | { true && a=10; echo $a; }
    10
    nparamonov@peka:~$ echo $a
    5
    ```

---

### Что такое QEMU

- Ответ
    
    Это виртуализированный эмулятор, который запускает программы и ОС, созданные для одной машины на другой машине в процессе эмуляции машины. Он может достичь очень хорошей производительности с помощью динамического перевода.
    
    QEMU (Quick Emulator) – эмулятор различных устройств, который позволяет запускать операционные системы, предназначенные под одну архитектуру, на другой (например, ARM –> x86). Кроме процессора, QEMU эмулирует различные периферийные устройства: сетевые карты, HDD, видео карты, PCI, USB и пр.
    
---

### Что такое KVM (гипервизор)

- Ответ
    
    KVM (Kernel-based Virtual Machine) – гипервизор (VMM – Virtual Machine Manager), работающий в виде модуля на ОС Linux. Гипервизор нужен для того, чтобы запускать некий софт в несуществующей (виртуальной) среде и при этом, скрывать от этого софта реальное физическое железо, на котором этот софт работает. Гипервизор работает в роли «прокладки» между физическим железом (хостом) и виртуальной ОС (гостем).
    
---

### Что такое qemu-kvm?

- Ответ
    
    KVM предоставляет доступ гостям к Ring 0 и использует QEMU для эмуляции I/O (процессор, диски, сеть, видео, PCI, USB, серийные порты и т.д., которые «видят» и с которыми работают гости).
    
    Бинарный программный код на процессорах работает не просто так, а располагается на разных уровнях (кольцах / Protection rings) с разными уровнями доступа к данным, от самого привилегированного (Ring 0), до самого ограниченного, зарегулированного и «с закрученными гайками» (Ring 3).
    
---

### Что такое iowait и почему он может появляться?

- **Ответ**
    
    iowait это показатель, показывающий процентное соотношение времени процессора, которое он потратил на ожидание ввода-вывода.
    
    Высокий показатель может сказать о том, что система ограничена возможностями дисковой памяти. Выполняется много операций ввода-вывода. Это замедляет систему.
    Конкретно это обычно означает что блочные устройства работают медленно или они переполнены.
    
    Замеряется в количестве потоков, которые ждут работы.
    

    
---

## Диски и файловая система  

**Что такое блочные устройства? Какие элементарные операции можно с ними производить?**

- Ответ
    
    Блочное устройство представляет собой уровень абстракции, описывающий любое устройство хранения информации, которое может быть разбито на блоки определенного размера; доступ к каждому блоку осуществляется независимо от доступа к другим блокам. 
    Такой доступ часто называют произвольным доступом.
    Иными словами блочные устройства нужны тогда, когда используется передача большого объема данных.
    - Сюда входят RAM-диски, компакт диски, накопители на магнитах
    - Доступ также осуществляется через спец файлы интерфейсы в `dev`.
    - На блочных устройствах как правило файловые системы.
    - Блочные устройства представлены часто как множество блоков.
    - Один блок кратен степени двух и равен килобайту данных.
    - Это позволяет линуксу читать и писать как в символьные устройства, так и в блочные.
    - Разница в том, что передается блок данных, а не байт.
    - Для пользователя это незаметно.
    - Используется для монтирования файловых систем.
    
    Через `lsblk` можно посмотреть такие устройства.  
    Данные передаются блоками. Как правило, кратный размер 256 байт  
    Можно записывать считывать, разделы создавать.  
    
    Блочные устройства не работают напрямую с системными вызовами. 
    И в случае блочных устройств их взаимосвязь обеспечивается системой управления файлами и подсистемой плочного устройства. 
    Эти подсистемы нужны чтобы подготовить ресурсы (буферы) драйвера устройства. Сохранять недавно прочитанные устйроства в кэш буфере, упорядочивание операций чтения и записи для повышения производительности.
    
    

### Что такое символьные устройства? Какие элементарные операции с ними можно производить?  

- Ответ
  Один из типов устройств. 
  Используется для медленных устройств, у которых происходит обмен небольшим объемом данных. И доступ к ним не требует частых поисковых запросов.
  Примеры таких устройств: мышь, клавиатура, последовательные порты. 
  В этом случае данные передаются последовательно, байт за байтом.
  
  Для этих устройств системные вызовы идут напрямую к драйверам устройств.
    

---

### Что такое major and minor numbers блочных устройств, чему они соответствуют?  

- Ответ
    
    На примере вывода:
    
    ```bash
    crw-rw-rw- 1 root   root    1, 3   Feb 23 1999  null
     crw------- 1 root   root   10, 1   Feb 23 1999  psaux
     crw------- 1 rubini tty     4, 1   Aug 16 22:22 tty1
     crw-rw-rw- 1 root   dialout 4, 64  Jun 30 11:19 ttyS0
     crw-rw-rw- 1 root   dialout 4, 65  Aug 16 00:00 ttyS1
     crw------- 1 root   sys     7, 1   Feb 23 1999  vcs1
     crw------- 1 root   sys     7, 129 Feb 23 1999  vcsa1
     crw-rw-rw- 1 root   root    1, 5   Feb 23 1999  zero
    ```
    
    Цифры 1, 10, 4 и 7 - старшие, мажорные номера.
    
    Цифры 1, 3, 5, 64, 65 и 129 - минорные номера
    
    Старший номер идентифицирует драйвер, который связан с устройством.
    
    `null` и `zero` управляются драйвером 1.
    
    `tty1`, `ttyS0`, `ttyS1` - управляются драйвером четыре. Это виртуальные консоли и терминалы.
    
    Как правило один старший номер - один драйвер
    
    Младший же номер используется ядром что бы определить о каком устройстве идет речь.
    И можно получить ссылку на устройство через ядро. Само ядро ничего про них не знает, знают только то, что здесь ссылаются на устройства, которыми драйвер управляют.
    
    

---

### Что такое файловая система? Для чего она нужна?

- Ответ

    **Файловая система** — это способ организации данных на диске, который разделяет данные на отдельные части, называемые файлами. Она также управляет метаданными этих файлов, такими как их имена, разрешения и другие атрибуты.
    
    Операционная система должна поддерживать файловую систему, чтобы она могла отображать её содержимое, открывать файлы и сохранять их. Если операционная система не распознаёт файловую систему, вы можете установить специальный драйвер, который обеспечит её поддержку.
    
    #### Файловая система как система хранения
    
    Файловую систему на компьютере можно сравнить с системой хранения документов. Биты данных на компьютере называются "файлами", и они организованы в "файловую систему", как бумажные файлы организуются в файловые шкафы. Файловые системы обеспечивают различные методы организации этих файлов и хранения данных, и каждый из них имеет свои особенности.
    
    Существуют разные виды файловых систем, и каждая операционная система может поддерживать разные типы для работы с файлами.
    
    Для более подробного объяснения, можно ознакомиться с материалом по ссылке:  
    [Подробнее о файловых системах](https://windows-school.ru/blog/kompjuteru_nuzhna_fajlovaja_sistema/2018-08-03-155)


---

### Как создать файловую систему на блочном устройстве? Какие параметры можно задать при создании?

- Ответ

    Создание файловой системы на блочном устройстве можно сделать с помощью команды `mkfs` (make file system).  
    Эта команда обычно используется вместе с типом файловой системы, который вы хотите создать, например, ext4, ext3, xfs и т.д.

    Вот пример команды, которая создает файловую систему ext4 на блочном устройстве `/dev/sdb1`:

    ```bash
    mkfs -t ext4 /dev/sdb1
    ```

    При создании файловой системы можно задать различные параметры, в зависимости от типа файловой системы. Например, для файловой системы ext4 можно задать следующие параметры:

    - `-L label` : задает метку для файловой системы.
    - `-m reserved-blocks-percentage` : задает процент блоков, зарезервированных для суперпользователя.
    - `-E extended-options` : задает расширенные параметры, такие как stride, stripe-width и т.д.
    - `-b block-size` : задает размер блока в байтах (по умолчанию 4096).
    - `-N number-of-inodes` : задает количество индексных дескрипторов (inode) в файловой системе.

    Но для той или иной файловой системы команды и ключи могут быть другими. Так что смотрите какая фс.

    
---

### Что такое **inodes айноды**

- Ответ
    
    **Inode** (индексный дескриптор) - структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. 
    
    Хранит всю информацию, кроме имени файла и данных. 
    Каждый файл в данном каталоге ( по факту таблица с индексами ( inumber ) ) является записью с именем файла и номером индекса.
    
    Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. 
    Номера inodes уникальны на уровне раздела. Каждый раздел имеет собственную таблицу индексов. 
    Если у вас закончились inode, вы не можете создавать новые файлы, даже если у вас есть свободное 
    место на данном разделе.
    
    Inodes хранят метаданные о файле, к которому они относятся. 
    Эти метаданные содержат всю информацию об указанном файле:
    
    - Размер.
    - Разрешение.
    - Владелец/группа.
    - Расположение жесткого диска.
    - Дата/время.
    - Любая другая необходимая информация.
    
    Чтобы увеличить количество inode, нужно увеличить размер файловой системы, 
    ведь количество инодов фиксированное и оно задается при создании файловой системы. 
    Значит увеличение файловой системы = увеличение количества инодов.
    
    Существуют файловые системы с динамическим количеством инодов, одна из которых - XFS.
    
    Динамические иноды отличаются от статических тем, что они динамически создаются по 
    мере необходимости и могут делать это автоматически, но это требует более сложных механизмов отслеживания.
    

---

### Где физически находятся inodes айноды

- Ответ
    
    Будет зависеть от файловой системы. Например, в ext2, ext3 хранится перед блоками данных. Это атрибут не диска, а файловой системы.
    
    иноды хранятся в таблицах инодов, и в каждой группе блоков в разделе есть таблица инодов.
    
    Может быть каталог инодов и имен, которые с ним связаны. Но это также будет зависеть от файловой системы. В fat32 их нет
    
    ![partition-images](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%202.png)
    
- Краткий ответ
    
    Имена inodes (имена файлов, каталогов, устройств и т. Д.) Хранятся на диске в каталогах. В каталоге хранятся только имена и соответствующие номера inode; Фактическое дисковое пространство для именованных данных хранится в пронумерованном индексном узле, а не в каталоге.
    
    Айнода просто указывает на файл и каталог

---

### По какой причине и на какого типа системах айноды могут закончиться? И к чему это может привести?

- Ответ
    
    Не будет возможности создания файла
    
    Зависит от размера блока, на который жесткий диск бьется. И от размера жесткого диска. И также могут разные файловые системы так работать.
    
---

### Какая файловая система бывает  динамическими айнодами и что это такое, зачем нужно?

- Ответ
    Динамические айноды это тот подход, при котором количество айнод не фиксируется при создании файловой системы.   
    Что позволяет изменить их до нужного нам количества.  
    
    В отличие от других файловых систем, где это нужно заранее резервировать.  
    Поскольку в этом случае придется создавать новую файловую систему, раздел с нужным нам количеством данных.  

    Как правило такие файловые системы хорошо подходят для систем, где ожидается большое количество файлов.
  
    Примеры таких файловых систем:  
    XFS, ZFS, BTRFS
    
---

### Где хранится информация об именах файлов, директорий?

- Ответ
    - Inodes не содержат имён файлов, только другие метаданные файла.
    - Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса.
    - Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса.
    
    Таким образом имя файла/директории хранится в информационной структуре каталогов.
    
    ![https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/inf_struct_catalogs.gif](https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/inf_struct_catalogs.gif)
    

---

### Каким образом осуществляется монтирование ФС? Как можно посмотреть список примонтированных ФС? (2 - 3 способа)

- Ответ
    
    ```bash
    mkfs -t ext3 /dev/hda8
    ```
    
    `mount` - показать все файловые системы
    
    `mount -t ext4` - покажет ext4 файловые системы
    
    Если нужно примонтировать usb
    
    Создаем файлик и монтируем
    
    ```bash
    sudo mkdir -p /media/usb
    sudo mount /dev/sdd1 /media/usb
    ```
    

    

---

### Что такое псевдофайловая система?

- Ответ
    
    «Псевдо» означает ложь, притворяться. Таким образом, «псевдофайловая система» означает файловую систему, которая не имеет *фактических* файлов - скорее, она имеет виртуальные записи, которые сама файловая система создает на месте.
    
    Можно сказать это интерфейс ядра linux.
    
    Например, `/proc` во многих ОС - это procfs, который динамически генерирует каталоги для каждого процесса. 
    Точно так же `/sys` в Linux генерирует файлы и каталоги для представления аппаратных схем. Есть FUSE на основе псевдо-файловая система для *многих* вещей.
    
    `/dev` может быть реальной файловой системой (просто подкаталогом `/`) или виртуальной псевдофайловой системой (например, devfs), или средней точкой, такой как Linux devtmpfs (которая является полной файловой системой в памяти, но все же создает узлы устройства из нигде).
    
    Основное предназначение современных VFS — организация единого интерфейса доступа пользователя к различным файловым системам, [драйверы](https://ru.wikipedia.org/wiki/%D0%94%D1%80%D0%B0%D0%B9%D0%B2%D0%B5%D1%80)
     которых загружены в память компьютера. Для реализации этой цели от ядра [операционной системы](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0)
     требуется создание единого [программного интерфейса](https://ru.wikipedia.org/wiki/API)
     внутренних вызовов ядра

   Если говорить о том, где хранится `proc`, то это **представление** структуры ядра. И можно сказать, что содержимое хранится в памяти ядра, то есть в ОЗУ.
    

---

### Какие проблемы могут возникать с файловой системой и жёстким диском? Можно ли восстановить ФС при незначительном повреждении её структуры? Как это сделать?  

- Ответ
    
    #### Восстановление файловых систем и инструменты для проверки

    Если автоматическая проверка при загрузке не может восстановить согласованность файловой системы, система обычно переходит в однопользовательский режим и выводит сообщение с указаниями для ручного запуска утилиты `fsck`. Для файловой системы **ext2**, которая не поддерживает журналирование, вам может быть предложена серия вопросов для подтверждения операций восстановления. Рекомендуется следовать предложениям `fsck`, отвечая "y" для подтверждения операций. После перезагрузки системы обязательно проверьте, не пропали ли какие-либо файлы или данные.
    
    #### Ручная проверка файловой системы
    
    Если вы подозреваете порчу данных или хотите вручную проверить файловую систему, большинство утилит требует предварительного размонтирования файловой системы. Однако размонтировать корневую файловую систему работающей системы невозможно. В этом случае можно перейти в однопользовательский режим (используя команду `telinit 1`), затем перемонтировать корневую файловую систему в режиме «только чтение» и выполнить проверку согласованности. Лучший способ проверки файловых систем — это загрузка с резервной системы (например, с CD-диска или USB-накопителя) и проведение проверки в размонтированном состоянии.
    
    #### Продвинутые инструменты
    
    Существуют более функциональные инструменты для проверки и восстановления файловых систем. Правила их использования можно найти в документации (`man`), а также в **Linux Documentation Project**. Большинство этих команд требуют размонтированной файловой системы, хотя некоторые функции могут работать и с файловыми системами, смонтированными в режиме «только чтение».
    
    **Важно**: перед любыми операциями по восстановлению обязательно создавайте резервную копию файловой системы.
    
    #### Инструменты для файловых систем ext2 и ext3

    - **tune2fs**  
    Настраивает параметры файловых систем **ext2** и **ext3**. Может добавлять журнал к системе ext2, преобразуя её в **ext3**, а также выводит или задаёт максимальное число монтирований перед проверкой. Можно также задать метку и управлять дополнительными опциями.
  
    - **dumpe2fs**  
      Выводит информацию о суперблоках и группах блоков в файловых системах **ext2** и **ext3**.

    - **debugfs**  
      Интерактивная утилита для отладки файловых систем **ext2** и **ext3**. Используется для проверки и изменения состояния файловой системы.

    #### Инструменты для файловых систем ReiserFS

    - **reiserfstune**  
    Выводит и настраивает параметры файловой системы **ReiserFS**.

    - **debugreiserfs**  
      Выполняет функции, аналогичные `dumpe2fs` и `debugfs`, для файловой системы **ReiserFS**.

    #### Инструменты для файловой системы XFS

    - **xfs_info**  
    Выводит информацию о файловой системе **XFS**.

    - **xfs_growfs**  
      Расширяет файловую систему **XFS**, если имеется дополнительное дисковое пространство.

    - **xfs_admin**  
      Изменяет параметры файловой системы **XFS**.

    - **xfs_repair**  
      Восстанавливает файловую систему **XFS**, если стандартные проверки при монтировании не могут восстановить её целостность.

    - **xfs_db**  
      Проверяет и отлаживает файловую систему **XFS**.

    

---

### Какую файловую систему выбрать ext4 или xfs?
- Ответ
    XFS поддерживает очень большие разделы и файлы.
    Также она хорошо работает при многопоточной нагрузке параллельной записи и чтения.
    Не очень подходит для однопоточных нагрузок с большим количеством метаданных. Например если один поток создает и удаляет большое количество мелких файлов.xfs поддерживает динамические inod-ы. В xfs они динамические, и их можно добавить.
    Ограничение системного раздела - 500TB
    В xfs можно потерять все данные, если сбилось что-то в момент записи на диск.
    Да и развернуть бэкап может не получиться, xfs разный может быть на серверах.

    ext4 поддерживает разделы до 50TB. Позволяет уменьшить созданный раздел.
    Лучше себя проявляет на медленных дисках с точки зрения пропускной способности. 


    Итог:
    Если много потоков последовательной записи или чтения с большим потреблением cpu в виде мелких файлов, и много метаданных то лучше ext4.

    Если у нас параллельная нагрузка в несколько потоков с большими файлами - лучше xfs.

    https://access.redhat.com/articles/3129891

    По своему опыту скажу - что xfs дисковые аварии в облаках плохо переживает. Потом сложно будет диск привести в рабочее состояние. То и дело будут отвалы, и проверки будут показывать ошибки. 
    


---

### Как определить, на каком физическом жёстком диске находится раздел с файловой системой? Как можно идентифицировать этот носитель без выключения сервера?

- Ответ

  Посмотреть название блочного устройства нужного можно например с помощью команды:
  `mount | grep " $(stat -c%m /home) " | awk '{print $1}'`
  
  А дальше на основе полученной информации можно выудить фирму, серийный номер и размер диска.
  `smartctl -a /dev/sda | grep -e "Serial Number" -e "Device Model" -e "Model Family" -e "User Capacity"`
  
  
  
  
  
  
    
---

**Какую файловую систему Вы бы выбрали для работы с большим количеством файлов?**

- Ответ
   ext4, она лучше справляется с большим количеством файлов, метаданных
    

---

### Как узнать, какими процессами используется раздел? 

- Ответ
    
    `lsof | grep /media/whatever`
    
    `fuser -mv /path/to/mountpoint`
    

---

### Для чего необходимы файлы /etc/fstab, /etc/mtab, /etc/mdadm/mdadm.conf?

- Ответ
    
    При включении главный диск смонтирован в корень. Загрузочный в boot. 
    
    Дополнительные диски можно увидеть в `mnt/*`  
    Информация об этих монтированиях хранится в файле `/etc/fstab`  
    
    Система автоматом монтирует диски на основании тех данных, которые берет их этого файла.
    
    То есть монтирование происходит во время загрузки
    
    `/etc/mtab` – это файл, который содержит список уже смонтированных файловых систем.
    
    Поэтому, когда вы запускаете команду «df», она обращается к этому файлу для генерации вывода.
    
    Файл mtab содержит софт ссылку на файл /proc/self/mounts.
    
    [https://zalinux.ru/?p=4895](https://zalinux.ru/?p=4895)
    
    mdadm - настройки подсистемы софтового рейда
    

---

### Отличие хардлинков от симлинков hardlinks symlinks

- **Ответ определения**
    
    Хардлинк - жесткая ссылка. По своей сути является тем же файлом на который ссылается. Также счетчик в айнодах есть. Цифра 1 это оно. Счетчик имен одного и того же файла.
    
    ```
    ls -lih | grep file
    475949 -rw-r--r--  1 root     setevoy     0B Aug 13 11:51 file1
    475950 -rw-r--r--  1 root     setevoy     0B Aug 13 11:51 file2
    475951 -rw-r--r--  1 root     setevoy     0B Aug 13 11:51 file3
    ```
    
    Симлинк - магкая ссылка. При ее создании создается новый объект на существующий файл файловой системы.
    
    Отличить можно по наличию буквы l в выводе команды ls например:
    
    ```
    ls -lih | grep sym
    475948 lrwxr-xr-x  1 root     setevoy     5B Aug 13 12:02 symlink1 -> file1
    ```
    
- **Ключевые отличия**
    - `hardlink` не может указывать на файл в другой файловой системе (так как `inode` может принадлежать только одной ФС), а `symlink` – может.  
    - при редактировании файла-ссылки в случае с `hardlink`ом – изменятся оба файла, так как это один и тот же объект, а в случае с `symlink`а – можно изменять его имя, атрибуты, направить его на другой файл и при этом оригинальный файл не будет затронут (но учтите, что если вы откроете файл симлинка для редактирования – то измените оригинальный файл, т.к. по сути вы откроете для редактирования именно его)
    - жёсткая ссылка не может указывать на на каталог
    - При удалении `hardlink`
    -а – файл будет существовать до тех пор, пока есть хотя бы 1 `hardlink`
     на него, но может “менять каталог размещения”, если был удалён “исходный” файл, но остался файл-`hardlink`
     в другом месте. При удалении же файла, на который указывает `symlink`
     – файл-ссылка просто станет нерабочим.

---

### Что такое RAID? Какие основные типы RAID существуют, чем они отличаются?

- Ответ
    
    **RAID** (Redundant Array of Independent Disks/Избыточный массив независимых дисков) - это технология, 
    которая позволяет объеденить несколько независимых физических дисков в одну сущность.

    В работе с дисками есть две проблемы
    
    - Низкая скорость чтения\записи
    - Выход дисков из строя и потеря данных
    
    И это всё решается с помощью технологии RAID.
    
    Существуют следующие уровни спецификации RAID: 1,2,3,4,5,6,0. Кроме того, существуют комбинации: 01,10,50,05,60,06.  Существуют аппаратные и программные RAID-массивы.
    
    - Программные массивы создаются уже после установки Операционной Системы средствами программных продуктов и утилит, что и является главным недостатком таких дисковых массивов.
    - Аппаратные RAID’ы создают дисковый массив до установки Операционной системы и от неё не зависят.
    
    **RAID 0** - чередование
    
    **RAID 1** - зеркалирование
    
    **RAID 5** - чередование с четностью
    
    **RAID 6** - чередование с двойной четностью
    
    **RAID 10** - совмещение зеркалирования и чередования
    
    **Уровень RAID 0 - Чередование**
    
    В системе **RAID 0** данные разделяются на блоки, которые записываются на все диски в массиве. При одновременном использовании нескольких дисков (как минимум 2) это обеспечивает превосходную производительность ввода-вывода. Достигается это за счёт того что данные передаются контроллерам дисков по быстрой шине одновременно, и диски записывают данные на свои блины или чипы одновременно. Таким образом, эффективная скорость записи может вырасти кратно до числа дисков. Эту производительность можно повысить, используя несколько контроллеров, в идеале один контроллер на диск.
    
    ![raid-0-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%203.png)
    
    **Преимущества**
    
    - RAID 0 обеспечивает высокую производительность как в операциях чтения, так и записи. Нет никаких накладных расходов, вызванных контролем четности.
    - Используется весь объем памяти, накладных расходов нет.
    - Технология проста в реализации.
    
    **Недостатки**
    
    - RAID 0 не отказоустойчив.
    - В случае сбоя одного диска все данные в массиве RAID 0 будут потеряны.
    - Он не должен использоваться для критически важных систем.
    
    **Лучшее применение:**
    
    RAID 0 идеально подходит для некритического хранения данных, которые должны считываться/записываться с высокой скоростью, например, на ретушь изображений или на станции видеомонтажа.
    
    Если вы хотите использовать RAID 0 исключительно для объединения емкости хранилищ в одном томе, рассмотрите возможность подключения одного диска в путь к папке другого диска. Это поддерживается в Linux, OS X, а также Windows и имеет то преимущество, что сбой одного диска не влияет на данные второго диска.
    
    **Уровень RAID 1 - Зеркальное отображение**
    
    Данные хранятся дважды, записывая их как на основной диск (или набор дисков), так и на зеркальный диск (или набор дисков). В случае сбоя диска контроллер использует основной диск или зеркальный диск для восстановления данных и продолжает работу. Вам нужно как минимум 2 диска для массива RAID 1.
    
    ![raid-1-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%204.png)
    
    **Преимущества**
    
    - RAID 1 предлагает отличную скорость чтения и скорость записи, сопоставимую с одиночным диском.
    - В случае сбоя диска данные не нужно перестраивать, их просто нужно скопировать на новый диск.
    - RAID 1 - очень простая технология.
    
    **Недостатки**
    
    - Основным недостатком является то, что эффективная емкость хранилища составляет только половину от общей емкости диска, поскольку все данные записываются дважды.
    - Программные решения RAID 1 не всегда допускают горячую замену неисправного диска. Это означает, что неисправный диск можно заменить только после выключения компьютера, к которому он подключен.
    - Для серверов, которые используются одновременно многими людьми, это может быть неприемлемо. Такие системы обычно используют аппаратные контроллеры, которые поддерживают горячую замену.
    
    **Идеальное использование**
    
    RAID-1 идеально подходит для критически важных хранилищ, например, для учетных систем. Он также подходит для небольших серверов, в которых будут использоваться только два диска с данными.
    
    **RAID уровень 5**
    
    RAID 5 является наиболее распространенным безопасным уровнем RAID.  Требуется как минимум 3 диска, но может работать до 16. Блоки данных распределяются по дискам, и на одном диске записывается контрольная сумма четности всех данных блока.  Данные о четности не записываются на фиксированный диск, они распространяются на все диски, как показано на рисунке ниже.  Используя данные контроля четности, компьютер может пересчитать данные одного из других блоков данных, если эти данные больше не будут доступны.  Это означает, что массив RAID 5 может противостоять отказу одного диска без потери данных или доступа к ним.  Хотя RAID 5 может быть реализован программно, рекомендуется аппаратный контроллер.  Часто дополнительная кеш-память используется на этих контроллерах для улучшения производительности записи.
    
    ![raid-5-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%205.png)
    
    **Преимущества**
    
    - Транзакции чтения данных очень быстрые, в то время как транзакции записи данных несколько медленнее (из-за четности, которая должна быть рассчитана).
    - В случае сбоя диска у вас по-прежнему есть доступ ко всем данным, даже если неисправный диск заменяется, а контроллер хранилища восстанавливает данные на новом диске.
    
    **Недостатки**
    
    - Отказы дисков влияют на пропускную способность, хотя это все еще допустимо.
    - Это сложная технология. Если один из дисков в массиве, использующий диски 4 ТБ, выходит из строя и заменяется, восстановление данных (время восстановления) может занять день или более, в зависимости от нагрузки на массив и скорости контроллера. Если другой диск выйдет из строя в течение этого времени, данные будут потеряны навсегда.
    - При этом нагрузка на каждый из дисков возрастает, поэтому вероятность выхода из строя выше чем у любых других схем, а при выходе из строя одного диска алгоритм восстановления крайне активно работает со всеми дисками, что потенциально может привести к лавинообразному выходу из строя последующих дисков.
    
    **Идеальное использование**
    
    RAID 5 — это хорошая универсальная система, которая сочетает в себе эффективное хранилище с превосходной безопасностью и достойной производительностью. Он идеально подходит для файловых серверов и серверов приложений с ограниченным количеством дисков с данными.
    
    **Уровень RAID 6 - Чередование с двойной четностью**
    
    RAID 6 похож на RAID 5, но данные о четности записываются на два диска. Это означает, что для него требуется как минимум 4 диска и он может выдержать 2 диска, умирающих одновременно. Вероятность поломки двух дисков в один и тот же момент, конечно, очень мала. Тем не менее, если диск в системах RAID 5 умирает и заменяется новым, для восстановления замененного диска требуются часы или даже больше дня. Если в это время умирает другой диск, вы все равно теряете все свои данные. При использовании RAID 6 массив RAID переживет даже этот второй сбой.
    
    ![raid-6-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%206.png)
    
    **Преимущества**
    
    - Как и в RAID 5, операции чтения данных выполняются очень быстро.
    - Если два диска выйдут из строя, у вас все равно будет доступ ко всем данным, даже если вышедшие из строя диски заменяются. Таким образом, RAID 6 более безопасен, чем RAID 5.
    
    **Недостатки**
    
    - Операции записи данных выполняются медленнее RAID 5 из-за дополнительных данных о четности, которые необходимо рассчитать. Производительность записи теоретичски может быть на 20% ниже.
    - Отказы дисков влияют на пропускную способность, хотя это все еще допустимо.
    - Это сложная технология. Восстановление массива, в котором вышел из строя один диск, может занять много времени.
    
    **Идеальное использование**
    
    RAID 6 — это хорошая универсальная система, которая сочетает в себе эффективное хранилище с превосходной безопасностью и достойной производительностью. Это предпочтительнее, чем RAID 5 на файловых серверах и серверах приложений, которые используют много больших дисков для хранения данных.
    
    **RAID уровень 10 - объединение RAID 1 и RAID 0**
    
    Можно объединить преимущества (и недостатки) RAID 0 и RAID 1 в одной системе. Это вложенная или гибридная конфигурация RAID. Он обеспечивает безопасность путем зеркального отображения всех данных на вторичных дисках, в то же время используя распределение по каждому набору дисков для ускорения передачи данных.
    
    ![raid-10-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%207.png)
    
    **Преимущества**
    
    Если что-то идет не так с одним из дисков в конфигурации RAID 10, время восстановления очень быстрое, поскольку все, что нужно, - это скопировать все данные с выжившего зеркала на новый диск. Это может занять всего 30 минут для дисков емкостью 1 ТБ.
    
    **Недостатки**
    
    Половина емкости хранения уходит на зеркалирование, поэтому по сравнению с большими массивами RAID 5 или RAID 6 это дорогой способ обеспечения избыточности.
    
    **Как насчет уровней RAID 2, 3, 4 и 7?**
    
    Эти уровни существуют, но они не являются общими (RAID 3 по сути похож на RAID 5, но данные четности всегда записываются на один и тот же диск). В этой статье описывается лишь общая классификация RAID-систем, и отображает общие сведения о технологии объединения накопителей.
    
    **RAID не заменит резервную копию!**
    
    Все уровни RAID, кроме RAID 0, обеспечивают защиту от сбоя одного диска. Система RAID 6 продолжит работу, даже при выходе из строя одновременно 2 дисков. Для полной безопасности вам все равно необходимо выполнить резервное копирование данных из системы RAID.
    
    - Эта резервная копия пригодится, если все диски выйдут из строя одновременно из-за скачка мощности.
    - Это защита от кражи системы хранения.
    - Резервные копии могут храниться вне серверной комнаты или ЦОД, в другом месте. Это может пригодиться в случае чрезвычайного происшествия, масштабного системного сбоя, пожара и т.д.
    - Наиболее важной причиной резервного копирования данных нескольких поколений является ошибка пользователя. Если кто-то случайно удаляет некоторые важные данные, и это остается незамеченным в течение нескольких часов, дней или недель, хороший набор резервных копий гарантирует, что вы все равно сможете сохранить эти файлы.

---

### Какие средства для работы с программными RAID массивами существуют в linux?

- Ответ
    
    `mdadm`
    
    [https://www.dmosk.ru/miniinstruktions.php?mini=mdadm](https://www.dmosk.ru/miniinstruktions.php?mini=mdadm)
    

---

### Что такое LVM? Для решения каких задач он предназначен?

- Ответ
    
    менеджер, позволяющий управлять логическими томами в системах Linux. Сами логические тома можно собрать из нескольких дисков или разделов дисков. LVM расшифровывается как Logical Volume Manager или по-русски — менеджер логических томов.
    
    LVM или Logical Volume Manager - это еще один программный уровень абстракции над физическими разделами жесткого диска, который позволяет создавать логические тома для хранения данных без непосредственной переразметки жесткого диска на одном или нескольких жестких дисках. LVM увеличивает удобство работы с жестким диском, аппаратные особенности работы скрываются программным обеспечением, поэтому вы можете изменять размеры дисков, перемещать их на лету, без остановки приложений или размонтирования файловых систем. Это очень удобно на серверах, вы можете добавить еще один диск или расширить существующие lvm тома на лету.
    

---

### Что такое loop devices? Как их можно использовать?

- Ответ
    
    В Unix-подобных операционных системах устройство цикла , vnd (диск vnode) или lofi (интерфейс файла цикла) является псевдоустройством, которое делает компьютерный файл доступным как блочное устройство . 
    
    Перед использованием петлевое устройство должно быть подключено к существующему файлу в файловой системе. Ассоциация предоставляет пользователю интерфейс прикладного программирования ( API ), который позволяет использовать файл вместо блочного специального файла (см. Файловую систему устройства ). Таким образом, если файл содержит всю файловую систему, файл может быть смонтирован, как если бы это было дисковое устройство. 
    
    Файлы этого типа часто используются для CD образов ISO и дискет образов. Монтирование файла, содержащего файловую систему, с помощью такого монтирования цикла делает файлы в этой файловой системе доступными. Они появляются в каталоге точки монтирования . Петлевое устройство - 
    
    Петлевое подключение имеет несколько применений. Это удобный метод автономного управления и редактирования образов файловой системы, которые в дальнейшем используются для нормальной работы системы. Сюда входят образы CD или DVD или системы установки. Его можно использовать для установки операционной системы в файловую систему без повторного разбиения диска. Он также обеспечивает постоянное разделение данных, например, при имитации съемных носителей на более быстром и удобном жестком диске или инкапсуляции зашифрованной файловой системы. Петлевое устройство - [https://ru.xcv.wiki/wiki/Loop_device](https://ru.xcv.wiki/wiki/Loop_device)
    

---

### При создании нового файла система возвращает ошибку no space left device

**no space left on device
несмотря на то, что df
сообщает о наличии свободного места. При каких обстоятельствах может возникнуть описанная ситуация?(inodes)**

- Ответ
    
    ```bash
    Сначала смотрим свободное место
    df
    
    Потом иноды, поскольку айноды тоже имеют свойство заканчиваться
    df -i
    
    ```
    

---

### df сообщает о наличии 20 Гб занятого пространства, подсчёт занятого файлами места при помощи du даёт результат в 20 Мб. При каких обстоятельствах может возникнуть описанная ситуация?(deleted files)

- Ответ
    
    При удаленном файле такое может быть. Файловый дескриптор держит файл
    
    Ищем файл через 
    
    `lsof -a +L1 | grep var | grep httpd`
    
    При удалении файла, который в этот момент был «занят» процессом — его имя удаляется, но inode — остаётся в файловой системе до тех пор, пока не завершится процесс, который «держит» этот файл.
    
    Соответственно, что бы «освободить» уже удалённые файлы — необходимо перезапустить процесс, который этот файл держит.
    

---

### При создании нового файла пользователем система возвращает ошибку no space left on device 
несмотря на то, что df сообщает о наличии свободного места; при это
пользователь root может создавать и записывать файлы. При каких обстоятельствах может
возникнуть описанная ситуация?(quotas)**

- Ответ
    
    Бывает так, что превышается квота
    Для каждого юзера и пользователя она своя может быть, жестко заданная
    
    ```bash
    #посмотреть квоту юзера
    quota -v user
    ```
    

---

## Debug

### Сервер не отвечает, как можно получить доступ к серверу, не находясь непосредственно в ЦОДе

- Ответ
    
    tcpconsole, ipmi, kvm
    
    Написать тикет в цод, чтобы потыкали
    

---

### Веб-сервер, работающий на сервере в нашей сети, отдаёт ошибку 502. Каким образом можно найти причину ошибки?

- Ответ
    
    502 bad gateway, ошибка на стороне вышестоящего сервера. То есть nginx сообщает о том, что получил ответ от другого сервера, к которому он обращался - некорректный или непонятный. 
    И тут уже надо копать что там в логах у вышестоящего сервера не так.
    
    Если брать nginx+apache
    
    Как минимум нужно посмотреть конфиги nginx, подрубить логгирование. И проверить параметры. Как минимум там должно быть такое:
    
    ```bash
    server {
        listen 80;
        server_name landing.example.com;
    
        location / {
    			proxy_pass                  http://my_server;
          proxy_set_header            Host $host;
          proxy_set_header            X-Real-IP $remote_addr;
          proxy_http_version          1.1;
          proxy_set_header            X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header            X-Forwarded-Proto http;
          proxy_redirect              http:// $scheme://;
        }
    
        access_log /landing-access.log;
        error_log  /landing-error.log info;
    }
    ```
    Обращаем внимание на proxy_pass. Это то, куда у нас пошел запрос.
    А дальше действуем по ситуации. Перезапускаем сервис, смотрим логи этого приложения, или, как в данном случае можно еще посмотреть логи сервера apache.
    Впрочем, это касается всех ошибок 5xx.
    

---

### В директории находится файл с нечитаемым содержимым. Каким образом можно узнать  формат хранения данных и предназначение файла?

- Ответ
    Поможет команда `file`. Она в большинстве случаев показывает что это за файл по своей сути.
    ```bash
    $ file stat-master.zip
    stat-master.zip: Zip archive data, at least v1.0 to extract

    $ file unins000.exe
    unins000.exe: PE32 executable (GUI) Intel 80386, for MS Windows
    
    $ file -i -b unins000.exe
    application/x-dosexec; charset=binary
    ```
    

---

### Попытка запуска исполняемого файла завершается ошибкой no such file or directory. Почему?

- Ответ
    
    Причин подобного поведения несколько
    
    - Файл не существует.
    - Файл существует, но это символическая ссылка
    - Файл существует, но это 32 битный файл. И нужны библиотеки для его запуска.
    - Иногда из-за символов каких-нибудь, в питоне такое происходит, поудалять символы лишние нужно, в самом файле.
    - Нету интерпретатора в системе

---

### Программа сообщает о том, что не может найти свой конфигурационный файл. Каким образом можно узнать, где она пытается его найти?

- Ответ
    
    Поможет утилита strace
    line-buffered в данном случае это опция, которая выведет результат как только найдет
    
    strace -f - отслеживание дочерныих процессов
    
    ```bash
    strace -f lftp sitename |& grep --line-buffered open | grep /home/akkana
    ```
    
    Либо в самой программе, если удастся найти параметры вывода проблемы. Как правило это -vvv, verbose
    
    ```bash
    /usr/sbin/mysqld --verbose --help | grep -A 1 "Default options"
    ```
    

---

### Что будешь делать если у команды chmod убрали права на исполнение? (chmod -x chmod)

- Ответ
    
    1. Используем утилиту setfacl. По умолчанию её может не быть в системе, но не проблема установить.
    
   ```
   setfacl -m u::rwx,g::rx,o::x /usr/bin/chmod
   ```
    
    2 Можно запустить утилиту chmod, передав её явно динамическому компоновщику. В контексте данной заметки считайте компоновщик интерпретатором для программы chmod. В разных дистрибутивах он может иметь разное название и расположение. Пример для Debian 11:
   ``` 
   /usr/lib64/ld-linux-x86-64.so.2 /usr/bin/chmod +x /usr/bin/chmod**
   ```
    
    3 Можно скопировать права с любого исполняемого файла и записать содержимое утилиты chmod в этот файл. Получается рабочая копия chmod.
    Создаём пустой файл с правами утилиты ls.
    
    ```
    cp --attributes-only /usr/bin/ls ./new_chmod
    ```
    
   Копируем содержимое утилиты chmod в созданный файл:
   ``` 
   cat /usr/bin/chmod > ./new_chmod
   ```
    
    Можно использовать:
    ```
    /new_chmod +x /usr/bin/chmod
    ```
    
    4 Почти то же самое что и предыдущий вариант только проще:
   ``` 
   install -m 755 /usr/bin/chmod ./new_chmod
   ```
    
    или так:
    ```
    rsync --chmod=ugo+x /usr/bin/chmod ./new_chmod
    ```
    
    5 Если умеете программировать на какой-то языке, то можно с его помощью вернуть бит исполнения. Пример с python:
    ```
    python -c "import os;os.chmod('/usr/bin/chmod', 0755)"
    ```
    

---

### База сейчас сидит и упирается в диск. И с ней ничего не сделать — больше сервер никто покупать не будет. Как сделать так, чтобы оно работало быстрее прямо сейчас?

- Ответы
    
    ОПАСНО!!!: нужно выключить fsync, чтобы база не дожидалась записи с данных на диск, а как бы сохраняла. 
    
    Linux может отдавать успешную запись, когда он к себе положил в буфер, а не когда на диск засинкал. Это немного костыльный режим работы, даже скорее опасный, рискованный. Питание вырубят в этот момент, и все навернется. Но зато этот метод ускоряет запись на порядок. 
    

### Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?

- Ответы
    - Total. Эта цифра представляет всю существующую память.
    - Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.
    
    `used = total - free - buff/cache`
    
    - Free – свободная память в системе.
    - Shared – память, используемая (преимущественно) в tmpfs
    - Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
    - Available – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки.  
      В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент. (То есть то, что можно потенциально освободить. Кэш, буфер и тп)
    
    Вот и получается, что доступная память (available) как правило больше или равна свободной памяти (free)

---

### Что такое разделяемая память?
Привести примеры**

- Ответ
    Разделяемая память - это область памяти, которую могут использовать несколько процессов одновременно. Это один из способов межпроцессного взаимодействия, позволяющий различным процессам обмениваться данными без необходимости использования более сложных механизмов, таких как сокеты или каналы.

    Например, клиент и сервер.
    Клиент это терминал ввода. Сервер принимает данные. 
    Клиент вводит строку терминала. Строка передеается серверу через сегмент памяти. После чего информация выводится. 

    Более глобальные примеры:
    Базы данных. Общая память используется в бд, где ряд процессов обращаются к общим структурам данных, и манипулируют ими. 

    Веб сервера. Например, апач. Апач использует общую память для рабочих процесов. Что позволяет разным процессам обслуживать разные запросы. 

    Операционные системы. Например, linux использует общую память для IPC, кэширования файловой системы и других задач.

    Подробнее про такую память можно почитать тут:
    https://dev.to/0xog_pg/using-shared-memory-in-linux-1p62

    


---

### Сервер под нагрузкой тормозит - тяжелые запросы к кассандре и ELK отрабатывают сильно медленнее чем раньше и чем другие аналогичные сервера.
    
    Мы сняли с сервера нагрузку, но оставили кассандру и ELK запущенными. Надо понять что делает сервер тормозным.

- Ответ

    - Сначала делаем команду top, обратить внимание на sys time и 35% CPU, которое отъедало systemd. Соответственно, что-то там усиленно ядро творило в своем sys time
    - Чтобы увидеть что именно делает systemd можно запустить `strace -c -p 1`, это даст таблицу сисколов, среди которых `waitid` отъедал много ресурсов.(78% CPU времени кушало). Данный системный вызов используется во время ожидания изменения состояния процесса. 
    Отсюда предположение - systemd что-то порождает, оно падает, случается waitid и все это добро происходит быстро и в больших кол-вах
    - Далее смотрим что именно systemd может так усиленно плодить: `watch -n 1 ps --ppid 1`. Тут мы видим какие процессы активно форкаются.
    И в  таблице вывода замелькали сомнительные `a.out` и `a.sh`
    - Поиск по имени (`find / -name "a.sh" 2`> /dev/null) привел к скрипту /var/games/a.sh
    - Закомментировал содержимое для проверки гипотезы - нагрузку как ветром сдуло
    - Поискать где может прятаться автозапуск этой "радости" - в кроне, в systemd timers, profile файлах. Либо спрятано с особой выдумкой, либо было запущено вами вручную с последующей чисткой history.


---

### допустим у тебя есть бинарник который запускается и сразу падает, у него все файловые дискрипторы пустые, как бы ты искал решение проблемы?

- Ответ

   Есть утилита strace, с помощью которой можно отследить какие вызовы к ядру делает процесс приложения, которое падает
   Её можно использовать следующим образом:  
    ```
    strace ./my_crashing_binary
    strace ./my_crashing_binary 2>out.txt
    strace -p 12345 2>out.txt
    ```
    Пример вывода ошибки. Здесь мы видим что идет попытка обращения к файлу, которого нет. По итогу программа падает
    ```
    <snip>
    ...
    write(1, "Hello World\n", 12) = 12
    brk(0) = 0x940e000
    brk(0x942f000) = 0x942f000
    open("/myfile", O_RDONLY) = -1 ENOENT (No such file or directory)
    --- SIGSEGV (Segmentation fault) @ 0 (0) ---
    +++ killed by SIGSEGV (core dumped) +++
    ---
    ```


## Docker контейнеры

**Что такое контейнеризация? Чем она отличается от виртуализации?**

- Ответ
    
    ![container-vs-vm-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%208.png)
    
    Если говорить о виртуальных машинах, там они работают через **Виртуализацию**
    
    И машины создаются с помощью гипервизора. И все аппаратные составляющие создаются через нее. И затем на нее накатываются операционные системы.
    Соответственно, ресурсы машины будут уходить на поддержание работы запущенной операционной системы.
    
    При контейнеризации аппаратные ресурсы выделяются с помощью ядра операционной системы, и изолируются пространством имен. Следовательно, они потребляют меньше ресурсов, и быстрее пересоздаются.
    
    Плюсы:
    
    - Меньше ресурсов потребляется
    - Быстрый запуск
    

---

### Что такое docker и какие инструменты linux лежат в основе? Для чего он используется?

- Ответ
    
    Docker базируется на технологиях **namespaces**, **cgroups**, **capabilities**, **overlay**
    **namespaces** - обеспечивает изоляцию. Используется для изоляции. Например, можно айдишники процессов разместить в разных контейнерах.
    **cgroup** - штука, которая позволяет управлять группой процессов, и управлять их ресурсами.
    **capabilites** - штука, которая позволяет дать некоторые рут привелегии процессам или исполняемым файлам. Например, изменить UID процесса на 0, или дать возможность монтировать файловые системы.
    **overlay (overlayFS, overlay2-драйвер)** - файловая система, которая умеет работать "слоями". Не сохранять каждый раз новые файлы, а наслаивать один слой на другой, тем самым экономя место на диске и время создания контейнера. 
    
    А вот докер - это уже штука, которая всеми этими технологиями рулит. Да ещё и удобным для нас образом.
    
    

    Компоненты докера:  
    1. Docker Daemon — то самое Container Engine; запускает контейнеры.
    2. Docker CII — утилита по управлению Docker.
    3. Dockerfile — инструкция по тому, как собирать образ.
    4. Image — образ, из которого раскатывается контейнер.
    5. Container.
    6. Docker registry — хранилище образов.
    
    ![docker-basic-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%209.png)
    
    На Docker_host работает Docker daemon, запускает контейнеры. Есть Client, который передаёт команды: собери образ, скачай образ, запусти контейнер. Docker daemon ходит в registry и выполняет их. Docker-клиент может обращаться и локально (к юникс-сокету), и по TCP с удалённого хоста.
    
    
    Docker daemon (демон)
    
    — это серверная часть, она работает на хост-машине: скачивает образы и запускает из них контейнеры, создаёт сеть между контейнерами, собирает логи. Когда мы говорим «создай образ», этим тоже занимается демон.
    
    Docker CLI
    
    — клиентская часть Docker, консольная утилита для работы с демоном. Повторю, она может работать не только локально, но и по сети.
    

---

### Что такое контейнеры, образы? В чём заключаются концепции их использования?

- Ответ
    
    **Образ** - шаблон приложения, который содержит слои файловой системы в режиме "только-чтение".
    
    **Контейнер** - запущенный образ приложения, который кроме нижних слоев в режиме "только чтение" содержит верхний слой в режиме "чтение-запись".
    
    Контейнер - это уже развернутое и запущенное приложение. Однажды запущенный контейнер сохранён в библиотеке, его можно останавливать, менять настройки, перезапускать, но до удаления контейнера это некоторая постоянная сущность со своим id. Продолжая аналогию с установкой ПО, контейнер можно сравнить с уже установленной и работающей программой на ПК.
    
    Образ - Это неизменяемый образ, из которого разворачивается контейнер. Его можно рассматривать как набор файлов, необходимых для запуска и работы приложения на другом хосте. Можно привести аналогию из мира установки ПО: образ — это компакт-диск, с которого устанавливается программа.
    

---

### В каком виде хранятся образы? Для чего используются слои? Что представляет собой overlayfs?

- Ответ
    
    **Образы(images)** - это логическая группировка слоев плюс метаданные о том, что делать при создании контейнера и как собирать слои. Часть этих метаданных заключается в том, что каждый слой знает ID своего родителя.
    
    Итак, что входит в слой? Файлы (и каталоги), которые вы добавили в родительский файл. Существуют также специальные файлы ("whiteout"), которые указывают на то, что что-то было удалено из родительского файла.
    
    Docker-image — шаблон только для чтения (read-only) с набором некоторых инструкций, предназначенных для создания контейнера. Он состоит из слоев, которые Docker комбинирует в один образ при помощи вспомогательной файловой системы UnionFS. Так решается проблема нерационального использования дисковой памяти. Параметры образа определяются в Docker-file.
    

---

### Что такое docker commit

- Ответ
  Это утилита, с помощью которой можно сощздать новый образ на основе контейнера либо перезаписать текущий образ

  Может быть полезно когда ты что ты изменил какой то файл в docker контейнере, и тебе нужно сохранить этот новый рабочий обновленный образ.


---

### Каким образом в docker реализована изоляция контейнеров друг от друга? Какие средства linux для этого используются?(namespace)

- Ответ
    
    Докер используется namespaces. Для создания изолированного рабочего пространства, которое называется контейнером. 
    При запуске контейнера докер создает набор неймспейсов для этого контейнера.

    Эти неймспейсы обеспечивают уровень изоляции. Каждый аспект контейнера выполняется в отдельном контейнере и его доступ ограничен неймспейсом.

    В частности в Docker Engine использует следующее:
    - Пространство имен pid: Изоляция процессов (PID: идентификатор процесса).
    - Пространство имен net: Управление сетевыми интерфейсами (NET: Networking).
    - Пространство имен ipc: Управление доступом к ресурсам IPC (IPC: InterProcess Communication).
    - Пространство имен mnt: Управление точками монтирования файловой системы (MNT: Mount).
    - Пространство имен uts: Изолирование идентификаторов ядра и версий. (UTS: Unix Timesharing System).
        

---

### Почему в контейнере можно увидеть только процессы, запущенные в самом контейнере?

- Ответ

    Это связано с тем, что Docker использует пространство имен PID (Process ID) для обеспечения изоляции процессов в контейнерах. 
    Когда создается новый контейнер, Docker создает новое пространство имен PID для этого контейнера и запускает процесс в этом пространстве имен. 

    В этом изолированном пространстве имен PID относится только к процессам, запущенным в том же контейнере.  
    Это означает, что процесс в контейнере **может видеть только другие процессы в том же контейнере и не имеет возможности видеть процессы, запущенные в других контейнерах или на хост-системе**. 
    Это ключевой аспект изоляции и безопасности, обеспечиваемой контейнерами Docker.
    
---

### В папке /var/lib/docker/ как понять какая папка к какому контейнеру принадлежит

- Ответ

  Например можно попробовать так:
  ```
   docker inspect $(docker ps -qa) |  jq -r 'map([.Name, .GraphDriver.Data.MergedDir]) | .[] | "\(.[0])\t\(.[1])"'
  ```
 


---

### Какие типы сетей есть в докере

- Ответ  
  **bridge** - Это стандартная сеть по умолчанию, которая создает виртуальный мост (bridge) для обмена данными между контейнерами. Каждый контейнер получает собственный IP-адрес из диапазона сети Docker.

  **host** - использует сетевой стек хоста, что означает, что контейнеры не изолированы на уровне сети от хоста. То есть, контейнер не изолирован по портам и делает запросы напрямую через сеть хоста.

  **none** - контейнер не имеет доступа к сети.

  **overlays** - тип сетей которые пересекают несколько узлов. Полезно когда у тебя docker контейнеры запушенны на разных хостах, но они должны общаться между собой. Для реализации этой сети Docker использует технологии, такие как **VXLAN** (Virtual Extensible LAN).

---

### Можно ли настроить сетевое взаимодействие между двумя docker-контейнерами? Как это реализовано?

- Ответ
    
    Можно.
    
    - Контейнеры должны быть частью одной сети
    - Докер создает виртуальную сеть, default bridge и подключает к ней контейнеры. Также, использует драйвер overlay для многохостовых сетей
    - В сети контейнерам назначается айпишник
    - Если контейнеры имеют выход в большую сеть, то они ведут себя как программы на отдельных компах

    Пример с сетевым драйвером bridge:
    1. Создаем сеть
       ```
       docker network create my_network
       ```

    2. Запускаем два контейнера в сети (sleep 1d это для бездействия контейнера в течение дня. Полезно при дебаге порой):
       ```
        docker run -d --name container1 --network my_network alpine sleep 1d
        docker run -d --name container2 --network my_network alpine sleep 1d
       ```

    3. Пробуем попинговать по имени:
       ```
        docker exec -it container1 ping container2
        ubuntu@host:~$ docker exec -it container1 ping container2
        PING container2 (172.18.0.3): 56 data bytes
        64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.110 ms
        64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.083 ms
        64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.111 ms
       ```
    Это работает потому, что когда вы создаете контейнер в сети Docker, он получает собственный IP-адрес в этой сети и добавляет DNS-запись на DNS-сервер сети. 
    Это позволяет контейнерам в одной сети взаимодействовать друг с другом, используя свои имена.
    Если вы хотите создать сеть на нескольких хостах Docker, используйте сетевой драйвер `overlay`.  
    Для этого потребуется Docker Swarm или стороннее хранилище ключевых значений, например Consul или etcd.

---

### Что происходит когда пишешь ENTRYPOINT?

- Ответ
    
    Точка входа в приложение.

    Это инструкция в докерфайле, которая всегда будет выполняться при запуске контейнера. 
    Она часто используется для определения основной команды для запуска контейнера. 
    Например для запуска веб-сервера или какой-либо иной службы. 

    Что происходит пошагово:    
    Инструкция ENTRYPOINT в Dockerfile задает команду, которая всегда будет выполняться при запуске контейнера. Она часто используется для задания основной команды для запуска контейнера, например, для запуска веб-сервера, базы данных или службы.
    Вот что происходит шаг за шагом:  

    1. В процессе сборки образа Docker читает Dockerfile строка за строкой, сверху вниз. Когда Docker встречает инструкцию ENTRYPOINT, он записывает команду и ее аргументы.  

    2. После сборки образа, при запуске контейнера из этого образа Docker выполняет команду, указанную в инструкции ENTRYPOINT. 

    3. Если команда Docker run также включает в себя команду, то она передается в качестве аргумента команде ENTRYPOINT.  

    Например, если у вас есть Dockerfile со следующим ENTRYPOINT:

    ```
    ENTRYPOINT ["/app/start.sh"]
    ```

    И запускается контейнер из этого образа с помощью команды:

    ```
    docker run -it my_image echo "Hello, World!"
    ```

    Докер выполнит команду ENTRYPOINT с командой run в качестве аргумента:

    ```
    /app/start.sh echo "Hello, World!"
    ```

    Обратите внимание, что команду ENTRYPOINT можно отменить при запуске контейнера, используя флаг `--entrypoint` в команде `docker run`.
    В этом основной смысл, что можно переопределить аргумент, или вообще его отменить.

### В чем отличие CMD и ENTRYPOINT

- Ответ
    
    Эти инструкции Dockerfile задают команду, исполняемую при запуске контейнера. При их использовании есть несколько правил, например:
    
    - Должна быть минимум одна из них, CMD или ENTRYPOINT, в Dockerfile.
    - Если контейнер используется как исполняемый файл — ENTRYPOINT должна быть определена.
    - Если контейнер запускается с другими аргументами — CMD будет переопределена.
    
    Инструкция RUN позволяет вам установить ваше приложение и необходимые для него пакеты. Он выполняет любые команды поверх текущего изображения и создает новый слой, фиксируя результаты. Часто в Dockerfile вы найдете несколько инструкций RUN.
    
    Хорошей иллюстрацией инструкции RUN может быть установка нескольких пакетов систем контроля версий:
    
    ```
    RUN apt-get update && apt-get install -y \
      bzr \
      cvs \
      git \
      mercurial \
      subversion
    ```
    
    Обратите внимание, что `apt-get update`и `apt-get install`выполняются в одной инструкции RUN. Это делается для того, чтобы убедиться, что будут установлены самые последние пакеты. Если бы `apt-get install`это была отдельная инструкция RUN, то она бы повторно использовала слой, добавленный `apt-get update`, который мог быть создан давным-давно.
    
    Инструкция CMD позволяет вам установить команду по *умолчанию* , которая будет выполняться только тогда, когда вы запускаете контейнер без указания команды. Если контейнер Docker запускается с командой, команда по умолчанию будет игнорироваться. Если Dockerfile содержит более одной инструкции CMD, все инструкции CMD, кроме последней, игнорируются.
    
    CMD имеет три формы:
    
    - `CMD ["executable","param1","param2"]`
        
        (исполнительная форма, предпочтительнее)
        
    - `CMD ["param1","param2"]`*exec*
        
        (устанавливает дополнительные параметры по умолчанию для ENTRYPOINT в форме
        
    - `CMD command param1 param2`
        
        (форма оболочки)
        
        `docker run -it <image> /bin/bash` - тут при наличии CMD он будет проигнорирован, и будет запущен баш
        
        Инструкция ENTRYPOINT позволяет настроить контейнер, который будет работать как исполняемый файл. Он похож на CMD, потому что также позволяет указать команду с параметрами. Разница заключается в том, что команда ENTRYPOINT и параметры не игнорируются, когда контейнер Docker запускается с параметрами командной строки. (Есть способ игнорировать ENTTRYPOINT, но вряд ли вы это сделаете.)
        
        Докерфайл
        
        ```
        ENTRYPOINT ["/bin/echo", "Hello"]
        CMD ["world"]
        ```
        
        когда контейнер запускается, как `docker run -it <image>`будет производиться вывод
        
        ```
        Hello world
        
        ```
        
        но когда контейнер запускается, `docker run -it <image> John`это приведет к
        
        ```
        Hello John
        ```
        
- Краткий ответ
    
    cmd подставится после entrypoint при запуске. Тем самым можно запускать контейнер с нужными параметрами.
    
    То есть в entrypoint можно передать бинарь, а в cmd передать параметры.
    
    CMD может перетереться просто.
    
---

### Как уменьшить размер образа докера? У нас много COPY, RUN

- Ответ
    1. Использовать специальные облегченные базовые версии докер-образов.
    2. Уменьшать размер слоев, запуская RUN нечасто, объединив команды в одну
    3. Не устанавливать рекомендованные пакеты. И удалять содержимое `/var/lib/apt/lists/*`
    4. Docker-multistage-build. Тут указываем несколько `FROM`. И можно копировать результат одного `FROM-а` в другой
        - Пример
            
            ```docker
            # 1 =====================================
            # специальный образ, который содержит все необходимые 
            # для сборки библиотеки и приложения
            # размер образа ~730mb
            FROM diproart/ruby:2.6.4-alpine3.10 AS builder
            
            # полный набор пакетов
            ENV COMMON_PACKAGES \
            	tzdata \
                ...
                
            ENV ..
            
            RUN set -xe \
                && apk update \
                && apk upgrade \
                && apk add --no-cache --update ${COMMON_PACKAGES} \
                && rm -rf /var/cache/apk/* /tmp/* /var/tmp/*
            
            # additional clean
            #RUN rm -rf /usr/local/bundle/cache/*gem     
            
            RUN mkdir -p /usr/src/app
            WORKDIR /usr/src/app
            COPY . .
            RUN 
            
            # 2 =====================================
            # чистый образ, в который добавим только самое необходимое
            # размер образа ~51mb
            FROM ruby:2.6.4-alpine3.10
            
            # только необходимые для работы 
            # в production пакеты
            ENV PRODUCTION_PACKAGES \
            	tzdata \
                ...
            
            ENV ...
            
            RUN set -xe \
                && apk update \
                && apk upgrade \
                && apk add --no-cache --update ${PRODUCTION_PACKAGES} \
                && rm -rf /var/cache/apk/* /tmp/* /var/tmp/*
            
            RUN mkdir -p /usr/src/app
            WORKDIR /usr/src/app
            
            WORKDIR /usr/src/app
            
            # копируем скомпилированное приложение
            # и пакеты в напрямую в образ из предыдущего шага
            COPY --from=builder /usr/src/app .
            COPY --from=builder /usr/local/bundle/ /usr/local/bundle/
               
            EXPOSE 3000
            ENTRYPOINT [ "bundle", "exec" ]
            CMD [ "rails", "s", "-b", "0.0.0.0" ]
            ```
            
---

### Разработчики собрали образ, и запустили докер контейнер. При запуске выдает ошибку /bin/bash not found. Как диагностировать проблему?

- Ответ

  Попробовать запустить с sh, bash переопределив энтрипоинт
  ```
  docker run  --entrypoint="/bin/sh"  
  ```
  

---

### Какие команды порождают слои?

- Ответ
    
    `RUN` порождает слои
    
---

### Что за none образы можно увидеть в docker images?

- Ответ  
  Каждый образ в докере состоит из слоев, и имеет дочерние связи с другими слоями. По умолчанию они лежат в `/var/lib/docker/graph`.
  И когда мы закачиваем новую версию образа, то образ подгружает слой раз за разом. И получается что none это лишь один из слоев.
  Этот образ называется промежуточным. Их можно увидеть с помощью `docker images -a`
  Также, есть обособленные образы none:none. Например, когда мы собираем примерно такой же образ, но например с иной версией операционной системы.
  И в этом случае будет создан именно такой образ. Поскольку мы пересобрали образ с помощью докерфайла, а старая система стала обособленной.
  
  Можно почистить так:
  ```
  docker rmi $(docker images -f "dangling=true" -q)
  ```


---

### Что такое squash сквош?

- Ответ
    
    Это штука, позволяющая все слои спушить в один. В качестве побочного эффекта - размер образа уменьшается. 
    
    Но он ломает кэширование, поскольку у нас всё в одном слое. 
    
    С одной стороны инструмент мощный. Но нужно обращаться осторожно. 
    Лучше для базового образа использовать. Заранее набросал, и вот у тебя образ.



---

### Что такое Docker squash?

- Ответ
    
    Это утилита на питоне, которая позволяет объединить слои в один.
    
    Также это экспериментальный параметр с помощью которого можно создать сжатый образ.
    

---

### Можно ли ограничить использование ресурсов (cpu, ram, io, network) для docker контейнера? Как это реализовано? (cgroup)**

- Ответ
    
    Можно. И делается через cgroup. В модуле ядра.
    
    А можно посмотреть в докере как ключи ставить
    
    [https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)
    

---

### Для решения каких задач применяется docker-compose?

- Ответ
    
    Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.
    Вы передаёте файл с инструкциями для docker-compose, настроечными файлами, и докер на месте собирает из этого нужную вам комбинацию контейнеров, подтягивает образы нужных версий, пробрасывает в них волюмы с данными, поднимает между ними локальные сети и настраивает порты обмена.

---

### Что такое виртуализация? Чем виртуализация отличается от эмуляции?

- Ответ
    
    Виртуализация очень похожа на эмуляцию, но между ними есть важные различия. В частности, виртуализация обычно относится к использованию виртуальных машин. Виртуализация и эмуляция выполняют одно и то же, но делают это немного по-разному.
    
    Оба предназначены для запуска программного обеспечения в изолированной среде. Виртуализация ориентирована на изоляцию, а эмуляция — на среду. Это означает, что эмуляторы имитируют большее количество оборудования, чем виртуальные машины.
    
    Например, вы не можете запустить систему PlayStation на виртуальной машине. Но вы можете запустить эмулятор PlayStation в виртуальной среде Windows.
    
    Эмуляция-это использование программного обеспечения для обеспечения другой среды выполнения или архитектуры. Например, у вас может быть эмулятор Android, запущенный на коробке Windows. Коробка Windows не имеет того же процессора, что и устройство Android, поэтому эмулятор фактически выполняет приложение Android с помощью программного обеспечения.
    
    Виртуализация-это скорее создание виртуальных барьеров между несколькими виртуальными средами, работающими в одной и той же физической среде. Большая разница заключается в том, что виртуализированная среда представляет собой одну и ту же архитектуру. Виртуализированное приложение может предоставлять виртуализированные устройства, которые затем преобразуются в физические устройства, и узел виртуализации контролирует, какая виртуальная машина имеет доступ к каждому устройству или части устройства. Однако фактическое выполнение чаще всего все еще выполняется изначально, а не с помощью программного
    

### В чем разница между `docker stop` и `docker pause`?

- Ответ
    
    В том, что они посылают разные сигналы 
    
    docker pause - SIGSTOP(19), что приостанавливает процессы в контейнере
    
    docker stop - SIGTERM(15) и SIGKILL(9) использует к главному процессу контейнера
    

### Что такое слои в докере?

- Ответ
    
    По сути, слой или *слой образа*
     - это изменение образа или **промежуточного образа**. Каждая команда, указанная (  
    `FROM`,  
    `RUN`,  
    `COPY`  
    и т.д.) в вашем Dockerfile вызывает предыдущий образ изменения, создавая тем самым новый слой. Вы можете думать об этом как о внесении изменений при использовании git: вы добавляете изменение файла, затем еще одно, затем добавляя ещё одно, и слои накладываются один за другим.

    Так же любые изменения, которые происходят в docker контейнере, автоматически записываются в новый слой.
    

### В чем разница между ADD и COPY

- Ответ  
    В Dockerfile, инструкции `ADD` и `COPY` обе используются для копирования файлов и директорий из локальной файловой системы в образ контейнера, но между ними есть несколько важных различий:  
    * **COPY** поддерживает **только** базовое копирование локальных файлов в контейнер  
    * **ADD** имеет дополнительный функционал, к примеру, может извлекать архивы (напр, .tar, .tar.gz, .zip и другие форматы) и загружать файлы по URL. Но если, например, копировать через него архив, то он распакуется как каталог. Это уменьшает размер образа  

  В большинстве случаев предпочтительнее использовать COPY, так как это более предсказуемо и ясно, а ADD стоит использовать только тогда, когда вам действительно нужны её дополнительные возможности, такие как извлечение архивов или загрузка файлов по URL.  
    

### Почему latest образы использовать нежелательно?

- Ответ
    
    Сложно в отладке как минимум. Не разобраться какая именно версия закосячила. А так прод работает на определенной версии, пусть дальше на ней и работает.
    Помимо этого это небезопасно. Никто не знает что выкатит разработчик в новой версии. Может не быть обратной совместимости в проекте.
    

---

### В чем отличие ARG от ENV?

- Ответ
    
    **ENV** позволяет создавать переменные окружения, которые будут работать во время работы контейнера.
    
    **ARG** позволяет закинуть переменные, которые будут доступны во время сборки. Но они недоступны в контейнере. Однако через `ARG` можно задавать значения переменных по умолчанию для `ENV`

---

### От кого по умолчанию запускается контейнер? Почему это плохо?

- Ответ
    
    Процесс внутри пользователя запускается от root. id = 0.
    
    Лучше вот так делать
    
    ```docker
    FROM alpine
    RUN groupadd -r myuser && useradd -r -g myuser
    <Здесь еще можно выполнять команды от root-пользователя, например, ставить пакеты>
    USER myuser
    ```
    
    Можно таким образом нарушить изоляцию и получить рутовый доступ.
    
    Ну и не все запускают от рута в итоге
    
---

### Как убить контейнер изнутри?

- Ответ
    
    Через sigkill нельзя. Нужен обработчик сигнала. Sigkill я зарегистрировать не смогу. И игнорировать этот сигнал тоже. Но можно обрабатывать  sigterm. И его использовать для выхода из приложения.
    
    [https://medium.com/@andrestc/killing-a-container-from-the-inside-b4923f3a4182](https://medium.com/@andrestc/killing-a-container-from-the-inside-b4923f3a4182)
    

---

### Возможен ли самостоятельный перезапуск контейнера?

- Ответ
    
    Да, можно вот так указать:
    
    `docker run --restart=always`
    
---

### Какие есть best practices для написания Dockerfile?

- Ответ
    1. Запускать только один процесс на контейнер.
    2. Стараться объединять несколько команд **RUN** в одну для уменьшения количества слоёв образа.
    3. Частоизменяемые слои образа необходимо располагать ниже по уровню,
    чтобы ускорить процесс сборки, т.к. при изменении верхнего слоя, все
    нижеследующие слои будут пересобираться.
    4. Указывать явные версии образов в инструкции **FROM**, чтобы избежать случая, когда выйдет новая версия образа с тегом **latest**.
    5. При установке пакетов указывать версии пакетов.
    6. Очищать кеш пакетного менеджера и удалять ненужные файлы после выполненной инструкции.
    7. Использовать **multistage build** для сборки артефакта в одном контейнере и размещении его в другом.

---

### Что такое ката kata контейнер?

- Ответ
    
    Это иная реализация контейнеров. Которые работают в оси под открытой инициативой. **Kata Containers** объединяют преимущества контейнеров и виртуальных машин (VM). Они обеспечивают более высокий уровень **изоляции и безопасности** для приложений, сохраняя при этом **лёгкость и скорость работы контейнеров**.  
    Если обычные контейнеры используют стандартные механизмы контейнеризации Linux, у **Kata Containers** используются qemu, kvm.  
    
    Контейнер на стероидах. Больше для безопасности придумано.


---

### CRI, CSI, CNI, что это ?

- Ответ 

    **CRI** ( container runtime interface ) - это интерфейс который отвечает за жизенный цикл контейнера 
    и среду выполнения этого контейнера ( docker, containered и тд. )

    **CSI** ( container storage interface ) - это интерфейс который позволяет, как я понял,
    стандартизировать подключения каких то хранилищ к контейнеру

    **CNI** ( container network interface ) - это интерфейс, который позволяет тюнить сетевые взаимодействия
    как между контейнерами, так и контейнера к какому-то сервису

    | Термин | Описание | Область применения | Уровень взаимодействия | Примеры реализации |
    |--------|----------|--------------------|-----------------------|---------------------|
    | **CRI** | Интерфейс для управления жизненным циклом контейнеров в Kubernetes. Позволяет Kubernetes взаимодействовать с различными средами выполнения контейнеров. | Оркестрация и управление контейнерами. | Инфраструктурный уровень, взаимодействие с контейнерами. | Docker, containerd, CRI-O. |
    | **CSI** | Стандарт для подключения систем хранения данных к контейнерам. Позволяет разработчикам интегрировать разные решения для управления данными в контейнерах. | Хранение и доступ к данным в контейнерах. | Инфраструктурный уровень, взаимодействие с системами хранения. | OpenEBS, Rook, Portworx. |
    | **CNI** | Спецификация для настройки сетевых интерфейсов контейнеров. Управляет сетевыми настройками и политиками безопасности для контейнеров. | Управление сетями и коммуникацией между контейнерами. | Интерфейс для сетевых плагинов, работающих на уровне контейнеров. | Calico, Flannel, Weave Net. |
    
---

## Сети сеть

### Почему latency до 8.8.8.8 всегда низкий?

- Ответ
    
    8.8.8.8 это не один хост. Это anycast адрес, который перенаправляет на ближайший хост, которые по всему миру.

---

### Расскажи мне, как неподготовленному слушателю как устанавливает соединение SSH и происходит авторизация разными методами: по паролю и SSH-ключам.

[https://www.youtube.com/watch?v=f3KZ86l1p5w](https://www.youtube.com/watch?v=f3KZ86l1p5w)

**Открытый ключ нужен для зашифровки сообщений, он доступен всем.**

**Но расшифровать это сообщение можно только закрытым ключом. Он известен только владельцу**

1. Приходит браузер на сайт магазина, берет у него открытый ключ и шифрует им свое сообщение.
2. Магазин, получая шифрограмму расчехляет закрытый ключ и расшифровывает ваше сообщение
3. Затем магазин берет открытый ключ браузера и отправляет шифрограмму браузеру.

Так налаживается рукопожатие.

---

### Что такое IP и маска подсети?

- Ответ
    
    IP-адрес (IP от англ. Internet Protocol) — цифровой идентификатор, присваиваемый устройству, которое работает в условиях публичной или локальной сети на основе стека протоколов TCP/IP. Без него невозможно существование Интернета или какой-либо внутренней IP-сети.
    
    Однако, когда IP-адрес присваивается интерфейсу (сетевому адаптеру или как там его еще называют) компьютера или маршрутизатора, то кроме самого адреса данного устройства ему назначают еще и маску подсети.
    
    Маска подсети используется протоколом TCP/IP для определения того, находится ли хост в локальной подсети или в удаленной сети.
    
---

### Что такое и зачем нужен ARP протокол?

- Ответ
    
    Протокол разрешения адресов (Address Resolution Protocol). 
    
    Это протокол уровнем ниже чем IP. У устройств в сети есть мак-адреса, такой адрес представляет собой 12 шестнадцатиричных цифр, например A5:22:98:5C:24:93, обычно они прошиты изготовителем сетевого устройства, но на большинстве сетевых карт могут быть программно же изменены. В отличие от IP, мак задаётся на устройстве самостоятельно, хорошо бы был уникальным, и не может быть получен от другого устройства. Мак-адреса в норме известны только на том уровне сети где все устройства соединены друг с другом, в крайнем случае через свич. Перед посылкой пакета для незнакомого адресата, отправитель отправляет широковещательное сообщение "эй, у кого айпи-адрес 192.168.0.2?", и, если такое устройство в этой сети есть и хочет общаться, оно ответит "у меня, мой мак 5C:24:93:A5:22:98", и дальше они будут общаться по этим адресам.
    
---

### Зачем нужен VLAN?

- Ответ определение
    
    VLAN (Virtual Local Area Network), или так называемые виртуальные локальные сети, которые позволяют на на одном физическом порту роутера создать несколько виртуальных локальных сетей сразу. 
    
    Это разделение одной сети на несколько логических подсетей, разделенных друг от друга. Причем эти сети будут работать независимо друг от друга
    
    Реализуется коммутаторами и находится на канальном уровне.
    
- Зачем всё таки нужен
    
    Изоляция сетей 
    
    - Разные отделы внутри одной компании
    
    Допустим каждый отдел в компании захочет иметь свою собственную подсетку
    
    - Разные компании в бизнес-центре
    
    Можно конечно физические сети строить. Но мы заранее не знаем чего сколько должно быть. Логично построить одну сеть, а затем разбивать её логически на куски.
    
    Преимущества
    
    - Нагрузка распределяется, чтобы вся сетка не парализовалась
    - Ограничение широковещательного трафика

    Недостатки
    
    - Кажущаяся безопасность. Вроде бы данные идут куда надо, но любой желающий может подслушать любые данные, просто выставив нужный номер VLAN на подключённом устройстве

---

### Чем отличается TCP от UDP?

- Ответ
    
    **TCP** – транспортный протокол передачи данных в сетях TCP/IP, предварительно устанавливающий соединение с сетью. Ориентирован на соединение, используется для передачи данных (электронная почта, файлы, сообщения). При определении потери пакетов будет выполнен перезапрос потерянных пакетов.
    
    **UDP** – транспортный протокол, передающий сообщения-датаграммы без необходимости установки соединения в IP-сети. Не ориентирован на установление соединения, используется в потоковой передаче данных (IPTV, VoIP). При потере пакетов перезапроса потерянных пакетов не происходит.
    
    Нельзя сказать, что TCP лучше UDP, т.к. данные транспортные протоколы используются для различных типов передачи трафика.
    
- Ответ чтоб меньше доебывали
    
    tcp перед передачей сигнала устанавливает связь между устройствами. И он требует хендшейк.
    udp сразу отправляет, хендшейк не устанавливает. Возможна частичная потеря и несоблюдение порядка данных.
    Но что делать, если доставка не гарантирована в таком случае? Просто отправляются по два пакета. Если один потерялся - дойдет второй.

---

### Как TCP устанавливает соединение?

- Ответ
    
    ![tcp-con-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2010.png)
    
    1. Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом `SYN`. Он является пакетом синхронизации. Устанавливается только в первом пакете хоста и сервера. Позволяет установить сеанс, делая возможным обеим сторонам согласовать порядковый номер для начала связи.
       Дальнейший алгоритм: Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет (буферы и управляющие структуры памяти) для обслуживания нового клиента;    
       В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED;  
       В случае неудачи сервер посылает клиенту сегмент с флагом RST.
    2. Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK. Дальнейший алгоритм: Если он одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED; Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться; Если клиент не получает ответа в течение 10 секунд, то он повторяет процесс соединения заново.  
    3. Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED. В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED. Процесс называется «трёхэтапным рукопожатием» (англ. three way handshake), так как несмотря на то что возможен процесс установления соединения с использованием четырёх сегментов (SYN в сторону сервера, ACK в сторону клиента, SYN в сторону клиента, ACK в сторону сервера), на практике для экономии времени используется три сегмента.

---

### Как TCP поддерживает соединение?

- Ответ
    
    Многие реализации TCP способны посылать сообщение о *поддержании соединения*
     (keep-alive), тестирующее неактивные соединения.
    
    Такие сообщения периодически отправляются партнеру для проверки его существования в сети. В ответ должны поступать сообщения ACK. Использование сообщений о поддержании соединения не является обязательным. Если в системе имеется такая возможность, приложение может отменить ее собственными средствами. Предполагаемый период *по умолчанию*
     для тайм-аута поддержания соединения составляет целых два часа!
    

### Что происходит когда в браузере вводишь yandex.ru? Описать процесс

- Ответы
    
    Любой URL содержит следующую структуру `<протокол>/<хост>/путь`, например `https://yandex.ru/pogoda/samara`. Также URL может содержать данные для отображения страницы.
    
    1. При вводе URL браузер смотрит на протокол запроса. Если протокол в URL не указан, то браузер смотрит на список HSTS (HTTP Strict Transport Security - механизм, принудительно активирующий защищенное соединение через протокол HTTPS), если хост есть в данном списке, то браузер отправит запрос по протоколу HTTPS, если нет, то по HTTP.
    2. Для того, чтобы установить соединение с сервером, необходим его IP адрес. Так как мы используем домен, то необходимо установить соответствие домена и IP адреса сервера, где размещается ресурс. При запросе мы обращаемся к DNS. Cначала проверяется кеш DNS. Приоритет опроса DNS кеша следующий:
    - Кеш браузера,
    - Проверяется hosts файл ,
    - Кеш ОС,
    - Кеш роутера,
    - Кеш интернет-провайдера Если данных о данном запрашиваемом хосте в кеше нет, то:
    - DNS интернет провайдера отправляет запрос к корневому серверу DNS (.),
    - Если корневой сервер не знает запрашиваемого домена, то он отправляет запрос серверу ответственному за зону (.ru), в которому привязан домен,
    - Если DNS сервер зоны не знает запрашиваемого домена, то запрос отправляется к NS серверу домена. IP адрес хоста, при его наличии у DNS сервера, возвращается обратно по цепочке
    
    3. После того, как IP адрес хоста получили, необходимо сформировать на прикладном уровне запрос к серверу. К запросу добавляются следующие заголовки:
    - Прикладной уровень: протокол запроса (HTTP/S, FTP и т.д),
    - Транспортный (TCP/UDP): порт, по которому обращаемся к серверу.
    - Сетевой уровень: IP адрес пакета
    - Канальный уровень: определяет есть ли такой адрес в сети. Если нет, то пакет передаётся шлюзу. Устройство шлюза проверяет свою таблицу маршрутизации и направляет пакет в нужном направлении.
    - 
    4. Далее выполняется следующий алгоритм действий установления соединения:
    - После того, как запрос достиг сервера, клиент отправляет клиенту запрос (client hello) и свою версию протокола TLS на защищенное соединение.
    - Сервер отвечает клиенту (server hello) с информацией о выбранной версии TLS, методом шифрования, методом компресии и публичный сертификат сервера, подписанный центром сертификации. Сертификат содержит публичный ключ, который будет использован клиентом для шифрования данных.
    - Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если сертификат подписан центром из списка, то серверу можно доверять.
    - Клиент шифрует данные публичным ключом и отправляет серверу зашифрованное сообщение.
    - Сервер расшифровывает сообщение с помощью своего приватного ключа и генерирует симметричный мастер-ключ и отправляет его клиенту.
    - Клиент отправляет серверу сообщение о финише, шифруя хэш передачи с помощью симметричного ключа.
    - Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хэш, чтобы проверить совпадает ли хэш клиента с хэшом сервера. Если совпадение обнаружено, то сервер отправляет клиенту сообщение о финише.
    
    После этого защищенное соединение с сервером установлено.
    
    5. Далее необходимо сформировать запрос серверу:
    - Клиент формирует запрос HTTP, в котором участвует метод (например GET), URL и версию протокола. Например `GET /pogoda/samara HTTP/2`.
    - Следующий заголовок клиента HOST, в котором указывается к какому хосту необходимо обратиться. Например `HOST: yandex.ru`. По заголовку HOST сервер может определить к какому сайту на сервере необходимо обратиться.
    - Запрос может также содержать и другие заголовки. Необходимо только, чтобы сервер смог понять эти заголовки.
    
    После этого всё, соединение установлено
    
---

### На каком уровне работает протокол TCP?

- Ответы
    
    Транспортный. Поскольку TCP является протоколом транспортного уровня.
    
---

### На каком уровне оси работает ssh?

- Ответы
    
    На прикладном
    
---

### Как работает DNS, зачем он нужен?

- Ответ
    
    DNS — фундаментальная технология современной интернет-среды, которая отвечает за хранение и обработку информации о доменных адресах.
    Нужен для того, чтобы соотносить айпи адреса с доменными именами.
    
---


### типы DNS записей, какие бывают

- Ответ 

    **A запись**: запись связывает доменное имя с ipv4 ip адресом.  
    **AAAA запись**: запись связывает доменное имя с ipv6 ip адресом.  
    **CNAME запись (Canonical Name)**: одно доменное имя может быть алиасом другого допустим `www.example.com` и `example.com` .  
    **NS запись**: указывает имя сервера который обрабатывает информацию о домене.  
    **MX запись**: определяет почтовые серверы, принимающие почту для домена. допустим `mail.example.com`.  
    **TTL запись**: время жизни хранения записи. Представляет собой продолжительность кэширования записи *каждым звеном* цепочки установки соответствий DNS.    
    **TXT запись**: поле с текстом. Часто через это поле проверяют право владения доменом (если можешь менять записи значит ты владелец).  
    Используется для выпуска сертификатов. Также для SPF записей, DKIM ключа (для почтовых сервисов)  
    **PTR запись:** обратная запись, которая позволяет связать IP адрес с доменом (эту запись может ставить ТОЛЬКО ВЛАДЕЛЕЦ IP АДРЕСА)  
    **SOA запись:** начальная запись зоны, которая указывает, на каком сервере хранится эталонная информация о домене.  
    Удалить эту запись нельзя. SOA-запись и ее значения не влияют на работу домена  

---

### Что такое адреса 127.0.0.0/8, 192.168.0.0/16, 10.0.0.0/8, 172.16.0.0/12? Зачем они нужны?  

- Ответ
    В rfc1918 указаны определенные префиксы\подсети, которые должны использоваться в приватных сетях. 
    
    https://datatracker.ietf.org/doc/html/rfc1918#:~:text=The%20Internet%20Assigned,192.168/16%20prefix)
    ```
       The Internet Assigned Numbers Authority (IANA) has reserved the  
       following three blocks of the IP address space for private internets:  

         10.0.0.0        -   10.255.255.255  (10/8 prefix)  
         172.16.0.0      -   172.31.255.255  (172.16/12 prefix)  
         192.168.0.0     -   192.168.255.255 (192.168/16 prefix)  
    ```
    Наши домашние роутеры, офисы и так далее. Публично они не маршрутизируемые, потому что провайдеры их фильтруют. Ну или по крайней мере стараются это делать.


    Адрес 127.0.0.1 используется для того, чтобы устройство могло самому к себе обращаться, это так называемый loopback адрес.  

    Случай аналогичный тому, что выше. В глобальной сети не используется. Описан в rfc5735
    ```
    127.0.0.0/8 – этот блок предназначен для использования в качестве loopback-адресов хостов Internet.  
    Дейтаграмма, переданная протоколом вышележащего уровня по адресу из этого блока, не покинет этот хост (вернется ему же).  
    Изначально этот процесс был реализован с использованием одного адреса 127.0.0.1/32.  
    Как указано в [RFC1122] (параграф 3.2.1.3), адреса из блока 127.0.0.0/8 не могут легитимно появляться где-либо в сети.  
    ```
    https://datatracker.ietf.org/doc/html/rfc5735  
    https://www.protokols.ru/WP/rfc5735/#:~:text=127.0.0.0/8%20%E2%80%93%20%D1%8D%D1%82%D0%BE%D1%82,%D0%BB%D0%B8%D0%B1%D0%BE%20%D0%B2%20%D1%81%D0%B5%D1%82%D0%B8.  

---

### Как работает NAT, зачем он нужен?

- Ответ
    
    #### Частные и публичные IP-адреса. NAT (Network Address Translation)

    Изначально сети проектируются с использованием **частных IP-адресов**. Эти IP используются внутри площадки или организации для общения устройств в локальной сети. Однако, для того чтобы устройства могли взаимодействовать с внешними ресурсами за пределами локальной сети, их **частные IP-адреса** должны быть преобразованы в **публичные**.
    
    #### NAT (Network Address Translation)
    
    **NAT** — это технология, которая занимается переводом частных IP-адресов в общедоступные. **NAT** позволяет устройствам с частными адресами IPv4 обращаться к внешним ресурсам за пределами локальной сети. 
    
    Технология NAT полезна в контексте сохранения ограниченного количества общедоступных IPv4-адресов. Она позволяет многим устройствам в частной сети использовать один публичный IP-адрес для выхода в интернет.
    
    ---
    
    #### Дополнительное объяснение NAT
    
    Часто на офис или дом выдается один глобальный IP-адрес. **Фаервол** применяет технологию NAT, которая также известна как **masquerade**. В этом случае фаервол подменяет локальные IP-адреса устройств на свой глобальный IP-адрес, добавляя к каждому соединению случайный порт. Это позволяет фаерволу отслеживать, возвращаются ли пакеты от внешнего источника на правильный локальный адрес внутри сети.
    
    Все подключения с публичным IP-адресом заносятся в **таблицу NAT**, где фаервол ведёт учёт текущих соединений. Записи в таблице NAT удаляются либо по таймауту, если это настроено, либо при получении специального пакета **FIN**, который сообщает о завершении соединения.
    
    Таким образом, NAT не только преобразует IP-адреса, но и помогает управлять соединениями, отслеживая их статус и обеспечивая корректную работу сетевых взаимодействий между внутренними и внешними ресурсами.


---    

### Что такое SNI?

- Ответ
    
    **SNI**
     или **Server Name Indication** — расширение популярного криптографического протокола TLS широко использующегося в веб.
    
    Практический смысл SNI в том, что если в настройках веб-сервера включена поддержка технологии на одном IP адресе может размещаться неограниченное количество сайтов, работающих по https.
    

### Что такое TLS и SSL

- Ответ

    Протокол TLS (transport layer security) основан на протоколе SSL (Secure Sockets Layer), изначально разработанном в Netscape...
    


### Чем симметричное шифрование отличается от ассиметричного?  

- Ответ
    
    Принципиальное различие между этими двумя методами заключается в том, что алгоритмы симметричного шифрования используют один ключ, в то время как асимметричные используют два разных, но связанных между собой ключа
    
    алгоритмы [симметричного шифрования](https://academy.binance.com/ru/articles/what-is-symmetric-key-cryptography) используют один и тот же ключ для выполнения этой функции, алгоритм асимметричного шифрования напротив, использует один ключ для шифрования данных и другой для его дешифрования.

---

### Почему DNS использует UDP?

- Ответ
    
    Пока устраиваешь TCP-сессию, ты можешь 3 раза отправить UDP пакетик туда и получить его обратно. И никакого оверхеда.
    
---

### днс использует только udp соединение?

- Ответ

   Почти всегда, если дата пакет не помещаеться в один upd запрос, то днс устанавливает tcp соединение. Происходит это посредством отправки udp пакета с установленным флагом Truncation (TC), что говорит о том, что запрашиваемому нужно повторить запрос по TCP:
   https://labs.apnic.net/index.php/2024/02/26/dns-and-truncation-in-udp/#:~:text=DNS%20transactions%20should%20use%20UDP,DNS%20response%20(Figure%201).  

   В каких случаях может устанавливаться tcp соединение:  
   * Трансфер зоны. В этом случае происходит синхронизация между DNS серверами, проходит большой объем данных. 
   * Использование протокола DNS over TLS (DoT). Используется для шифрования DNS запросов. 


---

### На каком порту работает ping?   
- **Ответ**  
    **Краткий ответ** - ни на каком. Потому что предполагается что работает на сетевом уровне по ICMP, где портов нет.  

    **Длинный ответ**:    
    Вообще этот вопрос с подвохом.   
    В первую очередь `ping` это какая-то программа. Которая может еще отличаться от поставщика к поставщику, от системы к системе.   
    Что означает то, что и работать они могут по-разному.   

    Мы предполагаем, что эта программа работает по протоколу ICMP, которая генерирует эти ICMP сообщения.   
    Но это не значит, что оно так везде работает. Какого-то стандарта здесь нет.   


    Сообщения ICMP оптравляются, и конечный хост дает какой-то ответ. Либо ответа не дает.  
    Здесь мы можем сделать выводы о доступности, либо недоступности. Либо информацию о том, что маршрут закольцевался. Либо что-то еще.  
    Те сообщения, которые были получены на этом уровне - не предшествует непосредственной отправке данных куда-либо.   


    Помимо этого icmp может использоваться при проверке **достижимости** порта. Это тоже ICMP сообщение.    
    Например сообщение Destination Port Unreachable(тип 3 код 3):    
    ```
    PING 192.168.2.4 (192.168.2.4) 56(84) bytes of data.  
    From 192.168.1.15 icmp_seq=1 Destination Port Unreachable  
    ```

    Вроде бы портов в icmp нет, как так?    
    Во-первых с 70ых-80ых в целом понятие портов менялось, и могли иметься в виду другие понятия.  
    Например, в ip якобы есть порты, хотя это могут быть цифры для того, чтоб понимать что это за протокол.  

    Все дело в том, что уровни так же могут между собой взаимодействовать.  
    При отправке udp запроса на закрытый порт на удаленном хосте - мы можем получить сгенерированное сообщение о недоступности порта.  
    Которое генерирует конечная операционная система. Но, такие сообщения генерируются не всегда. И пакеты могут отбрасываться без уведомления.   

    То есть ICMP это такой механизм обратной связи, который позволяет сообщать о проблемах на различных уровнях сетевого стэка.  

---

### Как работает ICMP  

- **Ответ**
    Internet Control Message Protocol. Протокол межсетевых управляющих сообщений. Протокол IP предоставляет сервис передачи данных без гарантии доставки.
    
    Функции ICMP 
    
    - Оповещение об ошибках на сетевом уровне
    - Тестирование работоспособности сети

    
    Тип сообщения - он говорит о том, что произошло в сети. Какое действие пытается выполниться
    
    Код сообщения - в нем подробнее описывается попытка, причина и диагностическое действие
    
    Контрольная сумма - используется для проверки правильности доставки
    
    4 байта со служебной информацией зависит от типа и коода сообщения
    
    Поле данных icmp - фрагмент пакета при передаче которого произошла ошибка
    
    | Тип | Назначение |
    | --- | --- |
    | 0 | Эхо-ответ |
    | 3 | Узел назначения недостижим |
    | 5 | Перенаправление маршрута |
    | 8 | Эхо-запрос |
    | 9 | Сообщение о маршрутизаторе |
    | 10 | Запрос сообщения о маршрутизаторе |
    | 11 | Истечение времени жизни пакета |
    | 12 | Проблемы с параметрами |
    | 13 | Запрос отметки времени |
    | 14 | Ответ отметки времени |
    
    В icmp 2 типа сообщений
    
    - Запрос ответ доступности сети (0 и 8) - доступность узлов
    - Запрос и ответ отметки времени (13 и 14) - проверка быстродействия сети


---

### Что такое TTL?  
- Ответ  
    #### Time To Live (TTL)

    **Time To Live (TTL)** — это метод, который используется для ограничения времени жизни данных в сети. В контексте IP-пакетов TTL представляет собой счётчик, который уменьшается на единицу при каждом прохождении пакета через узел (хоп) на маршруте.
    
    Когда значение **TTL** становится равным нулю, пакет уничтожается.
    
    #### Почему был введён TTL?
    
    TTL был введён для предотвращения ситуации, когда IP-пакет мог бы "бесконечно" путешествовать по сети, если не было бы возможности его уничтожить. В стандартном протоколе IP изначально не было ограничения на время жизни пакета, что могло приводить к тому, что пакеты застревали бы в петле маршрутизации, что негативно влияло бы на работу сети.
    
    TTL решает эту проблему, гарантируя, что пакеты будут удалены, если они не смогут достичь своей конечной точки за ограниченное количество хопов.

---


### Как работает traceroute?  
 
- Ответ  
  В первую очередь это тоже утилита, как и пинг. И основываться может либо на ICMP, либо на UDP, и даже на TCP.   
  Нужна для того, чтобы определить маршруты следования данных по сети.     
  В отличие от ping, который лишь сообщает о проблеме, помогает точнее определить где возникла проблема.    
  В целом это второй инструмент, который помогает сузить круг поиска возможных проблем при сетевой недоступности.

  **Как работает?**
  * На вход даётся конечный адрес назначения (destination, dst).   
  * Программа генерирует серию сообщений, начиная с **TTL** = 1.    
  * Каждый маршрутизатор на пути уменьшает **TTL** на 1.   
  * Когда **TTL** достигает 0, маршрутизатор отбрасывает пакет и отправляет ICMP "Time Exceeded" обратно.   
  * Traceroute фиксирует этот ответ и IP-адрес отправителя.    
  * Процесс повторяется с увеличением **TTL** на 1, пока не достигнет конечного адреса. Либо пока не кончатся переходы (самое большое число 255). То есть в данном случае TTL будет 2. Первый запрос попадет на наш первый маршрутизатор. TTL уменьшится на 1. И маршрутизатор отправит запрос на следующий маршрутизатор. После чего TTL будет 0 и пакет отбросится.  
  * Если используется UDP, на закрытый порт конечного хоста придёт ICMP "Port Unreachable".    

  Что позволяет найти, какие ошибки?   
  * Полный путь, который проходит пакет   
  * Увидеть имена, адреса маршрутов и\или иных устройств на пути следования пакетов  
  * Сетевые задержки, сколько времени нужно для отправки и получения данных всем устройствам  


  Минусы:  
  Это занимает много времени как правило  
  Тут может быть нюанс, что маршрутизаторы могут не давать ответа, не отвечать на UDP\TCP\ICMP-echo запросы.  
  И пробовать нужно будет разные варианты. И в целом это лишь один из инструментов диагностики.      

  https://youtu.be/HgYuBN0ZYu0

  https://predzimye.livejournal.com/16179.html  

---

### Что такое authority в DNS?

- Ответ
    
    Возможно, речь идет об авторитативном сервере
    
    Authoritative-Only DNS-сервер — это сервер, который заботится только о том, чтобы отвечать на запросы для зон, за которые он отвечает. Поскольку он не помогает разрешать запросы для внешних зон, он, как правило, очень быстрый и может эффективно обрабатывать много запросов.
    
    Серверы с только авторитативной функцией имеют следующие свойства:
    
    - **Очень быстро реагирует на запросы для зон, которые он контролирует.** Сервер с только авторитативной функцией будет иметь всю информацию о домене, за который он отвечает, или справочную информацию для зон в домене, которые были делегированы другим серверам имён.
    - **Не будет отвечать на рекурсивные запросы.** Серверы с только авторитативной функцией по своему понятию не предназначены отвечать на них. Это делает его только сервером, а не клиентом в системе DNS. Любой запрос, достигающий Authoritative-Only сервера, обычно поступает от распознавателя (резолвера), получившего ссылку на него, а это означает, что Authoritative-Only сервер либо имеет полный ответ, либо сможет передать новую ссылку на сервер имён, которому была делегирована соответствующая ответственность.
    - **Не кеширует результаты запроса.** Поскольку сервер authoritative-only никогда не запрашивает информацию на других серверах для обработки запроса, то ему просто нечего кэшировать. Вся информация, которую он знает, уже находится в его системе.
    
---


### Как узнать мой внешний ip адрес?
- Ответ
  Проще всего это выяснить, сделав запрос на сервисы по типу 2ip.ru, и им подобных.
  `$ curl 2ip.ru`  
  Там будет сразу выведен адрес.

---

### Что такое рекурсивный DNS

- Ответ
    
    Рекурсивный сервер — это DNS-сервер, который настроен на выполнение запросов к другим DNS-серверам, пока не найдёт ответ на вопрос. Он вернёт клиенту ответ на его запрос, либо сообщение об ошибке (его получит системный распознаватель, который, в свою очередь, передаст его клиентскому приложению).
    
---

### Рекурсивный и нерекурсивный запрос к серверу dns

- Ответ
    
    При ответе на нерекурсивный запрос, а также - при неумении или запрете выполнять рекурсивные запросы, - DNS-сервер либо возвращает данные о зоне, за которую он ответствен, либо возвращает адреса серверов, которые обладают большим объёмом информации о запрошенной зоне, чем отвечающий сервер, чаще всего - адреса корневых серверов.
    
    ---
    
    В случае рекурсивного запроса DNS-сервер опрашивает серверы (в порядке убывания уровня зон в имени), пока не найдёт ответ или не обнаружит, что домен не существует. (На практике поиск начинается с наиболее близких к искомому DNS-серверов, если информация о них есть в кеше и не устарела, сервер может не запрашивать другие DNS-серверы.)
    
    Рекурсивные запросы требуют больше ресурсов от сервера (и создают больше трафика), так что обычно принимаются от «известных» владельцу сервера узлов (например, провайдер предоставляет возможность делать рекурсивные запросы только своим клиентам, в корпоративной сети рекурсивные запросы принимаются только из локального сегмента). 
    
    Нерекурсивные запросы обычно принимаются ото всех узлов сети (и содержательный ответ даётся только на запросы о зоне, которая размещена на узле, на DNS-запрос о других зонах обычно возвращаются адреса других серверов).
    
- Краткий ответ
    
    При рекурсивном запросе Вы просто обращаетесь к серверу, а он, если не найдет у себя нужной записи, идет к другим серверам и спрашивает у них.
    
    Нерекурсивный dns сервер в данном случае просто говорит - "я не знаю, но спроси у этого сервера". И клиент будет слать ещё один запрос. Понятное дело, что при медленном интернете первый вариант лучше.
    
---

### Базовая http аутентификация авторизация, как работает

- Ответ
    
    HTTP имеет функцию базовой аутентификации. Это протокол, который описан в стандартах HTTP 1.0/1.1 
    
    Принцип работы:
    
    1. Первоначальный запрос
       * Клиент делает запрос к защищенному ресурсу без учетных данных
       * Сервер отвечает ответом `401 Unauthorized`
       * Сервер добавляет заголовок `WWW-Authenticate: Basic realm="Name of the realm"`
    2. Ответ клиента
       * Браузер показывает встроенную форму для ввода логина и пароля
       * Формируется новый запрос с заголовком `Authorization`
       * Учетные данные кодируются (не шифруются) в формате `base64(username:password)`
    
    Есть несколько схем аутентификации
    
    **Basic**. Она самая простая. И там данные передаются в формате **base64(username:password)**. Что небезопасно без использования https. Данные передаются в закодированном, но не в зашифрованном виде.  
    
    **Digest** Является более безопасной альтернативой Basic. Использует алгоритм MD5 для хеширования. И имеет дополнительные поля.
    
---

### В чём отличие аутентификации от авторизации?   
   - Ответ

    **Аутентификация** пытается ответить на вопрос "Кто ты?"
    Подтверждает личность пользователя, и проверяет, что пользователь действительно тот, за кого он себя выдает.

    Авторизация пытается ответить на вопрос "Что тебе можно?"   
    То есть проверяет права доступа, и определяет что можно смотреть, изменять, комментировать и тд аутентифицированному пользователю.  

    Пример:  
    При вводе логина и пароля на форме сайта - проходим авторизацию на сайте.  
    Пытаясь зайти на определенную страницу происходит авторизация, которая позволит или не позволит посмотреть её содержимое.   


---


### Как работают сертификаты? Как подтверждается соединение? (https соединение)

- Ответ
    
    Процесс работает следующим образом:
    
    1. Браузер или сервер пытается подключиться к веб-сайту (веб-серверу), защищенному с помощью SSL.
    2. Браузер или сервер запрашивает идентификацию у веб-сервера.
    3. В ответ веб-сервер отправляет браузеру или серверу копию своего SSL-сертификата и публичный ключ.
    4. Браузер или сервер проверяет, является ли этот SSL-сертификат доверенным. У него уже зашиты сервера с помощью которых нужно производить проверку, с помощью центров сертификации. Если это так, он сообщает об этом веб-серверу. Генерирует сенасовый ключ, шифрует пебличным ключом и отправляет на сервер.
    5. Сеервер расшифровывает сообщение и сохраняет сеансовый ключ. Затем веб-сервер возвращает подтверждение с цифровой подписью и начинает сеанс, зашифрованный с использованием SSL.
    6. Зашифрованные данные используются совместно браузером или сервером и веб-сервером.
    
    Этот процесс иногда называют подтверждением SSL-соединения. Хотя по описанию этот процесс выглядит длительным, в реальности он занимает миллисекунды.
    
    ![ssl-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2013.png)
    

---

### Опиши принцип работы ssl-шифрования

- Ответ
    
    В основе любого метода шифрования лежит ключ. Ключ — это способ зашифровать или расшифровать сообщение. В работе SSL-сертификата участвуют три ключа: публичный, приватный и сеансовый.
    
    **Публичный** ключ зашифровывает сообщение. 
    
    Браузер использует его, когда нужно отправить пользовательские данные серверу. Например, после того как вы ввели данные банковской карты и нажали «Оплатить». Этот ключ виден всем, браузер прикрепляет его к сообщению.
    
    **Приватный** ключ расшифровывает сообщение. 
    
    Его использует сервер, когда получает сообщение от браузера. Этот ключ хранится на сервере и никогда не передаётся вместе с сообщением.
    
    **Сеансовый** ключ одновременно зашифровывает и расшифровывает сообщения. 
    
    Браузер генерирует его на время, которое пользователь проводит на сайте. Стоит пользователю закрыть вкладку, сеанс закончится и ключ перестанет работать.
    
    Публичный и приватный ключи генерируются один раз при создании запроса на выпуск сертификата. Поэтому приватный ключ нужно хранить осторожно. Если ключ попадёт в руки другому человеку, он сможет расшифровывать сообщения, а вам придётся переустанавливать сертификат.
    
    **Шифрование с двумя разными ключами называют асимметричным.** Использовать такой метод более безопасно, но медленно. Поэтому браузер и сервер используют его один раз: чтобы создать сеансовый ключ.
    
    **Шифрование с одним ключом называют симметричным.** Этот метод удобен, но не так безопасен. Поэтому браузер и делает уникальный ключ для каждого сеанса вместо того, чтобы хранить его на сервере.
    
---

### Какие стандартные коды ответов есть у веб-серверов?

- Ответ
    - 1XX — информационные коды. Они отвечают за процесс передачи данных. Это временные коды, они информируют о том, что запрос принят и обработка будет продолжаться.
    - 2XX — успешная обработка. Запрос был получен и успешно обработан сервером.
    - 3XX — перенаправление (редирект). Эти ответы сервера гласят, что нужно предпринять дальнейшие действия для выполнения запроса. Например, сделать запрос по другому адресу.
    - 4XX — ошибка пользователя. Это значит, что запрос не может быть выполнен по его вине.
    - 5XX — ошибка сервера. Эти коды возникают из-за ошибок на стороне сервера. В данном случае пользователь всё сделал правильно, но сервер не может выполнить запрос. Для кодов этого класса сервер обязательно показывает сообщение, что не может обработать запрос и по какой причине.

---


### Какие существуют основные типы запросов HTTP?

- Ответ
    
    Два наиболее часто используемых видов HTTP запросов это: GET и POST.
    
    **GET** - запрашивает данные с определенного ресурса (сайта). 
    
    **POST** - отправляет данные на сервер для последующей их обработки.
    
    **Особенности GET запроса:**
    
    - Может быть закэширован
    - Остается в истории браузера
    - Может быть закладкой в браузере
    - Не должен использоваться при работе с крайне важными данными
    - Имеет ограниченную длину
    - Должен применяться только для получения данных
    
    **Особенности POST запроса:**
    
    - Не кэшируется
    - Не может быть закладкой в браузере
    - Не остаётся в истории браузера
    - Нет ограничений по длине запроса
    
    **post_error**
    [Untitled](%D0%92%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B%20%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B0%D0%BC%202%200%2060c73919d6564d1e880f209921e7b84d/Untitled%20Database%2026b6f5f23de74bf88002e57c48e41ea6.csv)
    

---

### Что такое маска подсети?

- Ответы
    
    Маска подсети тоже является числом, и она определяет диапазон IP-адресов, которые может использовать сеть.

    Маска подсети служит для разделения сетевой части и части хоста, определяет диапазон айпи адрессов, которые относяться к сети узлов.
    

---

### Что такое таблица маршрутизации

- Ответ 
  
  это таблица, состоящая из сетевых маршрутов котороая предназначенная для определения наилучшего пути передачи сетевого пакета.



---

### Что такое REST API и API

- Ответ 

  REST API - это архитектура построения веб-приложений которая основана на том, что общение между приложениями в сети ( клиент-сервер-сервер и тд) происходит за счет обменивание данными с использованием HTTP-запросов и ответов. Особенности:

   - Каждый ресурс имеет свой урл, к которому можно обратиться с КРУД методом и так взаимодействовать с ресурсами
   - Ни клиент ни сервер не хранит информацию о друг друге, вся нужная информация хранится в запросах


  API - это способ взаимодействия между приложениями и серверами, и это есть Эндпоинты с своим урлом на которые клиент либо другой сервер может делать КРУД запросы
  для взаимодействия

  ![RESTAPI-model](./imgs/RESTAPI.png)


---

### Динамическая маршрутизация и разные протоколы динамической маршрутизации, ebgp ibgp, константы bgp. На чём сейчас принято строить bgp-пиринги. Что такое blackhole.

- Ответ 

   **Основные протоколы динамической маршрутизации:**
    1. **RIP (Routing Information Protocol)** - один из старейших протоколов, использует алгоритм расстояния-вектора.
    2. **OSPF (Open Shortest Path First)** - протокол маршрутизации внутри автономной системы, использует алгоритм состояния канала.
    3. **EIGRP (Enhanced Interior Gateway Routing Protocol)** - протокол Cisco, сочетает в себе лучшие черты RIP и OSPF.
    4. **BGP (Border Gateway Protocol)** - протокол междоменной маршрутизации, используется для маршрутизации между различными автономными системами.


    #### eBGP и iBGP

    **eBGP (External BGP)** и **iBGP (Internal BGP)** являются двумя вариантами протокола BGP:

    - **eBGP** используется для маршрутизации между различными автономными системами (AS). Обычно eBGP требует, чтобы маршрутизаторы были непосредственно соединены.
    - **iBGP** используется внутри одной автономной системы. Маршрутизаторы, использующие iBGP, могут быть соединены через другие маршрутизаторы, не участвующие в BGP.

    #### Константы BGP

    Константы BGP включают различные атрибуты и параметры, которые используются для выбора наилучшего пути. Некоторые из ключевых атрибутов:

    - **AS_PATH** - список AS, через которые проходит маршрут.
    - **NEXT_HOP** - следующий переходный узел, к которому должен обратиться маршрутизатор для достижения целевой сети.
    - **LOCAL_PREF** - предпочтение маршрута внутри AS; чем выше значение, тем предпочтительнее маршрут.
    - **MED (Multi-Exit Discriminator)** - атрибут, используемый для влияния на выбор входящего маршрута соседним AS.

    #### Построение BGP-пирингов

    Современные BGP-пиринги часто строятся на основе сетевых устройств, способных обрабатывать большие объемы маршрутизационной информации и поддерживать высокую производительность. Используются как физические, так и виртуальные маршрутизаторы. Важным аспектом является настройка безопасности пиринга, включая аутентификацию и фильтрацию маршрутов.

    #### Blackhole

    **Blackhole** в сетевых терминах — это механизм, используемый для преднамеренного "поглощения" трафика, который по какой-либо причине считается нежелательным или вредоносным. Трафик, направленный в blackhole, обычно отбрасывается, что помогает защитить сеть от DDoS-атак или избавиться от трафика к недоступным сервисам. 

---

### Расскажи про модель TCP IP 

- Ответ

   4. Прикладной(хттп, ftp, SMTP, DNC и тд)
   3. Транспортный(передача данных, либо дейтаграмм в udp)
   2. Межсетевой(маршрутизаторы, роутеры и тд)
   1. Канальный уровень(подготовка пакета)

   ![TCP/IP-img](./imgs/TcpIp.png)


   Можно описать на примере работы протокола SSH

   1. **Канальный уровень**
      Здесь данные формируются во фреймы для передачи, а также ведется контроль доступа к среде передачи данных. 
   2. **Сетевой уровень**
      Этот слой отвечает за определение пути, по которому будет следовать пакет данных.
   3. **Транспортный уровень**
       Этот слой управляет передачей данных от одной системы к другой. SSH взаимодействует с этим слоем через протокол TCP.
   4. **Прикладной уровень**
       В первую очередь этот уровень предоставляет инструменты для взаимодействия пользовательских приложений с сетью. Все делается так, чтобы данные доходили в понятном пользователю или софту виде.
       SSH функционирует на этом слое, предоставляя защищенный канал для удаленной сессии или туннелирования других сетевых протоколов.


---

### Чем отличаются балансировщики L4 и L7? Что умеет балансировщик L7, чего не умеет L4?  
- Ответ  
    L7 работает на прикладном уровне. И принимает решения основываясь на данных этого уровня. Например:  
    * URL пути  
    * HTTP заголовки  
    * Куки  
    * Тип контента (content-type)  
    * HTTP методы (GET,POST,PUT и т.д.)  
   
    L4 работает на траспортном уровне, и взаимодействует с:  
    * IP-адресами  
    * Портами  
    * Протоколами TCP\UDP  

    Если подытожить - L7 работает непосредственно с самими данными. L4 для работы с сетевыми параметрами, без анализа содержимого самих пакетов.

---

## Ansible

### Для чего нужен ad hoc в ansible?

- Ответ
    
    Это режим работы ансибл когда запрос к серверу выполняется напрямую из командной строки, без создания дополнительных файлов.
    

### Что такое роли в ansible, пример

- Ответ
    
    Роли имеют свою структуру каталогов, которая выглядит так:
    
    ```yaml
    rolename
     - files
     - handlers
     - meta
     - templates
     - tasks
     - vars
    ```
    
    Назначение директорий:
    
    - `files`: содержит файлы, которые будут скопированы на настраиваемые хосты; так же – может содержать скрипты, которые позже будут запускаться на хостах;
    - `handlers`: обработчики, которые будут использоваться при выполнении задач;
    - `meta`: описание зависимостей, т.е. – ролей, которые должны быть обработаны перед запуском настраиваемой роли и мета-данных, таких как автор, описание продукта и прочее;
    - `templates`: шаблоны файлов с переменными;
    - `tasks`: все задачи, которые ранее были описаны в *Playbook*е;
    - `vars`: переменные для шаблонов.
    
    Тут описывается установка nginx
    
    [https://rtfm.co.ua/ansible-roli-roles-primer/](https://rtfm.co.ua/ansible-roli-roles-primer/)

---  

### Что такое идемпотентность? Приведи пример таких операций, и противоположных им

- Ответ
    
    Идемпотентность это когда делаем одну и ту же операцию много раз, и при многократном ее повторении результат будет таким же, как в первый раз. Некоторые операции не являются идемпотентными сами по себе, и там потребуется дополнительная логика.
    
    Например, делаем запрос к странице, просто ее качаем - это идемпотентно. Потому что результат не изменится.
    
    Допустим делаем DELETE запрос. Он сам по себе тоже идемпотентен, ибо удаляет то, что мы хотели изначально удалить. Однако, сначала сервер ответил 200, потом ответил 404. Но общее состояние всё то же, файл же уже удалён.
    
    В ансибле есть идемпотентность в модулях. Если я скажу создать файл при первом запуске он его создаст. При втором он увидит, что создано, и создавать не будет.
    
    Но может быть проблема например с распаковкой архива. Мы можем просто его распаковывать и распаковывать в какую-то директорию. Это уже ближе к неидемпотентному сценарию.
    
- Ответ в контексте ансибла
    
    **Идемпотентность** - это такая характеристика действия, согласно которой повторное выполнение этого действия будет давать тот же результат, что и первый запуск.
    
    В контексте систем управления конфигурациями это означает, что сценарии, написанные с соблюдением такого подхода, не изменят, не сломают и не выдадут ошибок на управляемом хосте при повторном запуске.
    
    Например, нам нужно добавить пользователя на хост, для bash это будет выглядеть так:
    
    ```yaml
    useradd newuser -ms /bin/bash
    ```
    
    Но если мы запустим команду второй раз, то получим ошибку
    
    ```yaml
    useradd newuser -ms /bin/bash
    useradd: user 'newuser' already exists
    ```
    
    Поэтому нам нужно дополнительно добавлять проверку, например так:
    
    ```yaml
    id newuser || useradd newuser -ms /bin/bash
    ```
    
    В случае Ansible мы только декларируем состояние, например:
    
    ```yaml
    - hosts: localhost
      gather_facts: no
      tasks:
        - user:
            name: newuser
            shell: /bin/bash
            state: present
    ```
    
    При первом запуске плейбук Ansible ответит:
    
    ```yaml
    TASK [user] ***
    changed: [localhost] => {
      "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
      },
      "changed": true,
      "comment": "",
      "create_home": true,
      "group": 1001,
      "home": "/home/newuser",
      "name": "newuser",
      "shell": "/bin/bash",
      "state": "present",
      "system": false,
      "uid": 1001
    }
    ```
    
    При повторном:
    
    ```yaml
    TASK [user] ***
    ok: [localhost] => {
      "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
      },
      "append": false,
      "changed": false,
      "comment": "",
      "group": 1001,
      "home": "/home/newuser",
      "move_home": false,
      "name": "newuser",
      "shell": "/bin/bash",
      "state":
      "present",
      "uid": 1001
    }
    ```
    
    Обратите внимание, что статус задания сменился с `changed` на `ok` и повторный запуск вернул значение `"changed": false` 
    
    Таким образом, сценарии, написанные с учетом идемпотентности, реализуют ту самую декларативность в описании состояния инфраструктуры, а инфраструктура соответствует состоянию, описанному в коде нашего скрипта.
    
    Это и есть **IaС - Infrastructure as Code - инфраструктура как код**
    
---

### Для чего нужны хендлеры, handlers?

- Ответ
    
    Задачу можно дополнить обработчиками, которые будут срабатывать, если задача была выполнена успешно.
    
    Например, мы установили nginx и хотим его запустить
    
    ```yaml
    ---
    - hosts: testbox
      sudo: yes
      tasks:
       - name: Install Nginx
         yum: pkg=nginx state=latest
         notify:
             - NGINX start
    
      handlers:
        - name: NGINX start
          service: name=nginx state=started
    ```
    
---

### В чем разница pull и push модели?

- Ответы
    
    **Pull**-модель преполагает, что управляемые хосты подтягивают инструкции с мастер-сервера.
    
    **Push**-модель реализует подход, когда инструкции по желанию или по событию доставляются с управляющего на управляемые хосты.
    
    Ansible чаще всего используется для push-модели управления, но умеет и pull-модель.
    
---

### В чем плюсы ансибла?

- Ответы
    
    Выгодные отличия Ansible от других систем управления конфигурациями:
    
    - быстро осваивается, достаточно поверхностного понимания синтаксиса YAML и Jinja
    - нет необходимости устанавливать специальное ПО на хосты, нужен только SSH и python
    - подробная и наглядная документация
    - большое количество модулей
    - позволяет реализовать принцип идемпотентности в управлении состояниями хостов
---

### Опишите основные примитивы Ansible

- Ответы
    
    **Инвентарь (Inventory)**
     - cписок хостов, может быть статичным в виде текcтового файла в формате `.ini` или динамическим в виде скрипта или плагина, который подгружает структуру данных из стороннего источника, например, Openstack API или база LDAP.
    
    ```
    $ cat hosts
    [web]
    nginx01
    nginx02
    nginx03
    
    [mysql]
    mysql01
    mysql02
    mysql03
    
    [prod:children]
    web
    mysql
    
    [devel]
    dev-nginx01
    dev-mysql01
    ```
    
    Данный пример описывает группы хостов web, mysql, prod и devel, группа prod наследует содержимое групп web и mysql.
    
    **Задание (Task)**
    
    - атомарная операция, выполняемая на управляемом хосте, например:
    
    ```yaml
    apt:
      package: nginx
      state: present
    ```
    
    Данный пример аналогичен команде `apt install nginx`
    
    **Сценарий (Play)** или **Плейбук (Playbook)**
    
    - сценарий или скрипт, содержащий одно или несколько заданий на выполнение, например:
    
    ```yaml
    $ cat prod-playbook.yml
    ---
    - hosts: nginx
      tasks:
        - apt:
            package: nginx
            state: present
        - shell: whoami
    ```
    
    **Роль (Role)**
    
    - более сложная абстракция, выглядит как структура директорий и файлов, которые описывают набор дефолтных переменных, зависимостей от других ролей, может содержать файлы и темплейты, содержит задания(Tasks).
    
    **Факты (Facts)**
    
    - структура данных, которая содержит информацию о хосте, например, версию дистрибутива, IP адреса и файловые системы. Ansible забирает эту информацию с хоста, и на нее можно ссылаться в коде плейбуков и ролей.
    
    Сбор фактов хоста занимает некоторое время, поэтому их можно кэшировать или отключить их сбор при выполнении плейбука.
    
---

### В чем разница между модулем и плагином**

- Ответ
    
    Модули что-то делают на хостах. Модули вызываются в задачах (tasks) плейбука
    
    Плагины расширяют функционал ансибла
    

---

## СУБД Базы Mysql

### Что такое индексы, зачем они нужны?

- Ответ
    
    Представьте себе, что у вас есть полочка для книг. При этом изначально эта полочка с книгами пуста. Книги вам то приносят, то уносят, то делают в них какие-то корректировки (к примеру, мемуары или может быть черновики) и тому подобное.
    
    Так как полочка маленькая, то вы как-то не особо задумывались о какой-либо системе классификации, а просто вставляете книги в любые пустые места.
    
    Каждый раз когда-то вам или кому-то необходимо найти определенную книгу, возникает необходимость просматривать все книги с самого начала полочки до первой попавшейся (если нужна только одна книга) или полностью все (если нужно собрать все копии). В принципе, для одной полочки это весьма необременительно.
    
    И нужно придумать систему классификации.
    
    Например, можно добавлять закладки в каталог.
    
    Поэтому вы поступаете проще, вы берете каталог, где возможно добавлять листочки. При этом каждую страницу выделяете только под одно название книги, а сами страницы располагаете в каталоге в порядке возрастания названий. Содержание этих страниц весьма просто — вы записываете в каком стеллаже, на какой полке и какой по счету является книга. Если книг несколько, то строчек в этой странице становится несколько.
    
    Таким образом, чтобы найти одну или все нужные книги по названию, вам достаточно открыть этот каталог и быстро пролистнуть до нужной страницы, а затем пройтись по всем указанным стеллажам. При этом для упрощения, вы также можете первые буквы названий так же индексировать. То есть добавляете наклейку на каждую первую страницу с указанной буквой (таким образом можете сразу перейти, например, к букве «Р», не пролистывая все названия до нее).
    
    Конечно, для поддержки такой системы требуется дополнительное время, но все же оно существенно меньше, чем попытка найти вслепую книгу из тысячи (пара минут против нескольких часов и более).
    
- Альтернативный ответ, ссылка на статью
    
    [https://infostart.ru/1c/articles/444987/](https://infostart.ru/1c/articles/444987/)
    

---

### Какая будет проблема если проставить много индексов?

- Ответ
    
    Причина того, что наличие большого количества индексов — это плохо, заключается в том, что это резко увеличивает объем операций записи, которые необходимо выполнить в таблице. Это происходит в нескольких разных местах. Когда происходит запись, данные сначала записываются в журнал транзакций. Когда это происходит, это регистрируется для каждого отдельного индекса, в который выполняется запись. Таким образом, для таблицы с девятью некластеризованными индексами в журнале транзакций выполняется 10 операций записи.
    
- Другой ответ, более полный
    
  1) **Накладные затраты при записи данных**
      
      Очевидно, что для поддержаиня какой-либо дополнительной структуры данных, либо определенной организации данных, требуется совершать дополнительные действия.
      
      Действий не так много, накладные затраты на них небольшие. Но плохо то, что эти затраты и действия возникают при записи данных. А запись данных происходит в транзакции.
      
      Хуже если в транзакции происходит и запись и чтение данных (контроль остатков). В этом случае индекс должен быть всегда в актуальном состоянии.
      
      Затраты на запись или чтение в транзакции намного "дороже" внетранзакционных издержек. Дело в том, что запись может вестись строго последовательно, и время на фиксацию изменений в БД сократить достаточно сложно. Более мощное оборудование тут не всегда помогает.
      
      Внетранзакционное же чтение данных может вполне успешно выполняться параллельно, при этом в случае увеления количества запросов на чтение данных, к примеру, вследствие роста количества пользователей, то они вполне могут решиться наращиванием аппаратных ресурсов.
    
  2) **Накладные затраты на обслуживание индексов**
      
      При интенсивной записи данных в таблицу данные индексов к ней не всегда распологаются на той странице, на которой должны. Появляются "пропуски", физическая структура индексов становится неэффективной. Поэтому иногда бывает необходимо производить дефрагментацию индексов. Производительность запросов к СУБД во время дефрагментации, соответственно, падает. Есть ещё процесс полного перестроения индексов - но в современных версиях MS SQL необходимости выполнения данной операции по регламенту нет.
      
  3) **Влияние индексов на размер базы**
      
      Не самое страшное последствие, но так или иначе если база весит 150-200 ГБ, то об этом надо уже задуматься. Для средней OLTP базы размер индексов, как правило, превышает объём самой базы.
      
      Не верите? Вполне можете воспользоваться какой-либо обработкой вроде этой:
      
      [//infostart.ru/public/19463/](https://infostart.ru/public/19463/)
      
      и посмотреть, сколько же в вашей базе места занимают индексы.
      
  4) **Затраты на создание и поддержание актуальной статистики**
      
      Статистику в базе нужно регулярно обновлять при интенсивных операциях вставки и обновления. Это занимает вычислительные ресурсы, хоть и не влияет непосредственно на процесс. Рекомендовано и в некоторых БД реализуется автоматически обновление статистики ночью, в период офф-пика, когда executor nodes нельзя полностью гасить, но можно занять их несрочной работой.
      
      Неактуальная статистика может привести к проблемам производительности системы.
      
      Но это не значит, что индексы - это плохо, без них СУБД были бы бесполезны.
      
    **Плохи индексы, которые не используются.**

---

### Как настроить мастер слейв репликацию в мускуле?

- Ответ
    
    Необходимы 2 сервера: master и slave.
    
    1. На оба сервера устанавливаем сервер MySQL одинаковой версии.
    2. Включаем сервер базы данных на обоих серверах.
    3. Настраиваем **master** - в `/etc/my.cnf` устанавливаем следующие значения:  
    ```bash
    # выбираем ID сервера, произвольное число, лучше начинать с 1
    server-id = 1

    # путь к бинарному логу
    log_bin = /var/log/mysql/mysql-bin.log

    # название Вашей базы данных, которая будет реплицироваться
    binlog_do_db = newdatabase
    ```
    Перезапускаем сервер базы данных.  

    4. Подключаемся к **master** серверу, создаем пользователя и назначаем ему права для выполнения репликации.  
    ```bash
    mysql -u root -p <пароль root сервера БД>
    GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'%' IDENTIFIED BY 'password';
    FLUSH PRIVILEGES;
    ```
    
    5. На master сервере делаем дамп базы данных c блокировкой таблиц.  
    ```bash
    mysqldump -u root -p --lock-all-tables newdatabase > newdatabase.sql
    ```
    
    6. Переносим дамп базы на slave сервер, создаем базу данных с таким же именем и импортируем базу. 
    ```bash
    CREATE DATABASE newdatabase;
    mysql -u root -p newdatabase < newdatabase.sql
    ```
    
    7. Настраиваем slave в `/etc/my.cnf`:  
    ```bash
    # ID Слейва, удобно выбирать следующим числом после Мастера
    server-id = 2
    # Путь к relay логу
    relay-log = /var/log/mysql/mysql-relay-bin.log
    # Путь к bin логу на Мастере
    log_bin = /var/log/mysql/mysql-bin.log
    # База данных для репликации
    binlog_do_db = newdatabase
    ```
    Перезапускаем сервер базы данных.  
    
    8. Запускаем репликацию на slave сервере.  
    ```bash
    CHANGE MASTER TO MASTER_HOST='10.10.0.1', MASTER_USER='slave_user', MASTER_PASSWORD='password',
    MASTER_LOG_FILE = 'mysql-bin.000001', MASTER_LOG_POS = 107;
    # Указанные значения мы берем из настроек Мастера
    После этого запускаем репликацию на Слейве:
    START SLAVE;
    ```
    
    9. Проверяем статус репликации:  
    ```bash
    SHOW SLAVE STATUSG
    ```
    
---

### В чем разница между TRUNCATE DELETE и DROP?

- Ответ  
    Тут важно понимать что от базы к базе поведение данных операций может отличаться.  
    1. Оператор `DROP` используется для удаления **структуры** таблицы. После удаления индексы, ограничения и триггеры, зависящие от таблицы, также будут удалены, но функции и хранимые процедуры, которые зависят от таблицы, останутся, но станут недействительными. Операция необратимая. Это операция **DDL** (Data Definition Language). Бытовая аналогия - снести целый дом.  
    2. Оператор `DELETE` используется для удаления **данных** в таблице, его можно удалить с помощью условий, и все данные в таблице удаляются без условий. Операция откатываемая. Дольше работает, поскольку информация для отката записывается. Блокирует только удаляемые строки, а не всю таблицу. Это операция **DML** (Data Manipulation Language).  Бытовая аналогия - выбросить какие-то отдельные вещи из дома.   
    3. Оператор `TRUNCATE` используется для удаления всех данных в таблице.  Операция быстрая и эффективная, ибо **не хранит подробную операцию для отмены**. Необратимая операция. На время работы блокирует таблицу. Это также операция **DDL**.  Бытовая аналогия - выбросить содержимое дома, но оставить сам дом.   

    * **DDL** (Data Definition Language) - язык определения данных. Операции изменяют структуру базы данных (CREATE,ALTER,DROP,TRUNCATE)  
    * **DML** (Data Manipulation Language) - язык манипулирования данными. То есть работают с содержимым таблиц (SELECT,INSERT,UPDATE,DELETE)  

    Основное отличие в том, что **DDL** работают со структурой базы данных и обычно необратимы.  
    А **DML** операции работают с данными внутри таблиц и могут быть отменены до подтверждения транзакции.  

---

## Что такое роли в pgsql

- Ответ
    
    **PostgreSQL** использует концепцию ролей (*roles*) для управления разрешениями на доступ к базе данных. 
    
    Роль можно рассматривать как пользователя базы данных или как группу пользователей, в зависимости от того как роль настроена.
    
    Роли могут владеть объектами базы данных (например, таблицами) и выдавать другим ролям разрешения на доступ к этим объектам, управляя тем, кто имеет доступ и к каким объектам.
    
    Кроме того, можно предоставить одной роли *членство* в другой роли, таким образом одна роль может использовать привилегии других ролей.
    
    Концепция ролей включает в себя концепцию пользователей ("users") и групп ("groups"). До версии 8.1 в PostgreSQL пользователи и группы были отдельными сущностями, но теперь есть только роли. Любая роль может использоваться в качестве пользователя, группы, и того и другого.
    
---

### Почему не следует использовать утилиту mysqldump на большой активной базе данных? Какие Вы знаете альтернативы?  

- Ответ
  
    Потому что может произойти блокировка таблиц. И любые изменения данных будут ожидать полного окончания дампа.  
    Из-за этого приложение фактически перестает работать.  
    Поэтому во время снятия дампа  нужно отключить блокировку таблиц.  

Можно использовать ключ `--single-transaction`, который позволит прочитать базу, и потом уже делать дамп. Это создаст корректный дамп.  
`--skip-lock-tables` - помогает в случаях когда у нас есть движок MYIASAM. И это позволяет избежать несогласованности данных.  

---

### Аббревиатура ACID, как расшифровывается?

- Ответ

    - **Atomicity** (Атомарность) - говорит что каждая транзакция является неделимой единицей работы, 
    и либо выполняется полностью, либо не выполняется вовсе.  
    - **Consistency** (Согласованность) - обеспечивает, что транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние. То есть, из одного валидного состояния в другое.  
    Допустим, есть правило что баланс счета не должен быть минусовой, Consistency гарантирует, что после транзакции ни один из балансов не будет минусовой
    - **Isolation** (Изоляция) - каждая транзакция должна выполняться изолированно от других транзакций.  
    Допустим две транзакции не могут одновременно работать с одними данными в один момент времени.
    - **Durability** (Долговечность) - после того как транзакция была успешно завершена, изменения должны остаться в базе данных, даже если что-то отъебнет.  
    
---

### Как безопасно удалить или изменить миллион строк в базе данных?  
- Ответ  
  
  Если просто в лоб удалять таблицу через DELETE, то мы можем столкнуться с блокировками таблицы. То есть таблица какое-то время будет недоступна.   
  Также можно столкнуться с повышенной нагрузкой на систему, что также замедлит общую производительность запросов.  
  1. Создать временную таблицу, с той же структурой, что и у текущей таблицы. Скопировать туда нужные данные. Потом переименовать таблицы. И удалить старую ненужную. В некоторых случаях это быстрее.  
  2. Порционное удаление. То есть мы разбиваем удаление по частям, например по 1000 записей. Можно оставить задержку между удалением. (Нужно это делать в транзакции).  
  3. Нужно найти время, когда нагрузка на базу минимальная. Как правило, это ночное время.  
  4. На всякий случай создать резервную копию базы.  

---

### Что такое wal-файл и зачем он нужен?  
- Ответ  
  WAL (Write-Ahead Logging) - механизм журналирования в PostgreSQL который записывает все изменения данных перед тем, как они попадут на диск.       
  По сути это страховка для базы данных, помогающая не потерять данные, если что-то пойдет не так.    

  Задачи:    
  1. Обеспечение целостности и надежности данных  
    * В случае сбоя системы или краха данных  
    * При внезапном отключении питания  
    * При аппаратных проблемах  
  
  2. Репликация  
    * Wal используется для синхронизации реплик  
    * Обеспечивает последовательное применение изменений  

  3. Оптимизация производительности  
    * Изменения сначала записываются в wal файл (быстрая последовательная запись)  
    * После чего происходит асинхронное обновление основных файлов базы (медленные случайные операции I/O)  
  
  4. Point-in-time-recovery   
    * Позволяет восстановить базу данных на любой момент времени  
    * Помогает при случайном удалении или повреждении данных  
    * Позволяет откатиться к определенной точке  

---

## Python

### Хеш-таблица

- Ответ
    #### Что такое хеш-таблица?
    **Хеш-таблицы** — это структура данных, где адрес или индекс элемента генерируется с помощью **хеш-функции**. Это позволяет ускорить доступ к данным, так как значение индекса используется как ключ для поиска соответствующего значения. В хеш-таблице хранятся пары **ключ-значение**, где ключ создаётся при помощи функции хеширования.
    
    Хеш-таблицы широко используются в программировании для быстрого поиска, добавления и удаления данных.
    
    #### Пример использования хеш-таблиц
    
    Одним из примеров использования хеш-таблиц являются **чит-коды** в играх, таких как **GTA San Andreas**. Те слова, которые игроки вводят в виде чит-кодов, на самом деле не являются изначально задуманными командами разработчиков. Эти слова проходят через хеш-функцию, которая преобразует их в ключи, связанные с конкретными командами в игре.
    
    Таким образом, хеш-таблицы позволяют обрабатывать чит-коды, сопоставляя введённые символы с заранее заданными значениями в игре, что значительно упрощает работу с большим количеством данных.

---

### Что такое генератор, что такое итератор?

- Ответ

    #### Итератор
    
    **Итератор** — это сущность, которая упрощает навигацию по коллекции данных. С помощью итератора можно перебрать значения в списке, применяя к каждому элементу определённую функцию. Итераторы позволяют последовательно получать элементы из коллекций, таких как списки, кортежи или множества.
    
    #### Генератор
    
    **Генератор** — это объект, который генерирует значения по мере их запроса. Генераторы похожи на списки, но отличаются следующими особенностями:
    
    - Генератор не вычисляет все значения сразу при создании. Значения генерируются по мере необходимости.
      - В памяти хранится только последнее вычисленное значение, а также правило перехода к следующему элементу и условие остановки генерации.
      - Вычисление следующего значения происходит при вызове метода `next()`. Предыдущее значение при этом теряется.
    
    Пример использования генератора и дополнительную информацию можно найти по ссылке:  
    [Генераторы в Python: что это такое и зачем они нужны](https://skillbox.ru/media/code/generatory_python_chto_eto_takoe_i_zachem_oni_nuzhny/)

---        

### В чем разница между кортежем и списком?

- Ответ
  1. **Изменяемость (Mutable vs Immutable)**:
   - **Список** можно изменять после создания. Элементы можно добавлять, удалять или изменять.
   - **Кортеж** является неизменяемым объектом. После создания кортежа его содержимое нельзя изменить.

  2. **Производительность**:
    - **Кортеж** работает быстрее, чем список, при итерации и доступе к элементам, так как из-за своей неизменяемости он оптимизирован лучше. Это делает его предпочтительным выбором для данных, которые не изменяются.
    - **Список** медленнее, так как его структура предусматривает возможность модификации данных.

  3. **Использование памяти**:
    - **Кортежи** занимают меньше памяти по сравнению со списками за счёт своей неизменяемости.
    - **Списки** требуют больше памяти, так как резервируют пространство для возможных изменений.

  4. **Функциональность**:
    - **Списки** поддерживают множество методов, таких как `append()`, `remove()`, `extend()`, и другие, позволяющие изменять его содержимое.
    - **Кортежи** не поддерживают методы изменения, так как они неизменяемы, но могут быть использованы методы, такие как `count()` и `index()`.

  5. **Использование**:
    - **Список** используется, когда данные могут изменяться, например, список задач, товаров или пользователей.
    - **Кортеж** обычно используется для хранения данных, которые не должны изменяться, например, координаты точки (x, y), дата или параметры конфигурации.

  6. **Хешируемость**:
    - **Кортеж** хешируем (если все его элементы также хешируемы), что позволяет использовать его в качестве ключа в словарях или элемента в множестве.
    - **Список** не является хешируемым и не может быть ключом в словарях или элементом в множестве.

  7. **Безопасность**:
    - **Кортеж** благодаря своей неизменяемости является более безопасным для данных, которые не должны изменяться. Это предотвращает случайные или преднамеренные изменения данных.
    - **Список**, наоборот, можно случайно изменить, что может привести к нежелательным последствиям.

  8. **Синтаксические различия**:
    - **Список** создаётся с помощью квадратных скобок:  
      `my_list = [1, 2, 3]`
    - **Кортеж** создаётся с помощью круглых скобок:  
      `my_tuple = (1, 2, 3)`  
      *Примечание*: если кортеж содержит один элемент, необходимо указать запятую:  
      `single_element_tuple = (1,)`

    Вывод:
    
    - Если вам нужна структура данных, которую можно изменять, используйте **список**.
    - Если ваши данные неизменяемы, и вам важна оптимизация памяти и производительности, выбирайте **кортеж**.
---

### Что такое декоратор?

- Ответ
    
    Декоратор позволяет добавить новую функциональность к существующей функции. Это делается следующим образом. Функция передается декоратору, а он выполняет и существующий, и дополнительный код.
    
    **Напишите функцию декоратора**. В качестве аргумента он принимает функцию func. Декоратор определяет функцию log_function_called, которая вызывает func() и выполняет некоторый код print(f'{func} called.’). Затем возвращает определенную им функцию:
    
    ```python
    def logging(func):
     def log_function_called():
       print(f'{func} called.')
       func()
     return log_function_called
    ```
    
    Напишем другие функции, к которым добавим декоратор (потом, не сейчас):
    
    ```python
    def my_name():
      print('chris')
    def friends_name():
      print('naruto')
    my_name()
    friends_name()
    #=> chris
    #=> naruto
    ```
    
    Теперь добавим декоратор к ним обоим.
    
    ```python
    @logging
    def my_name():
     print('chris')
    
    @logging
    def friends_name():
     print('naruto')
    
    my_name()
    friends_name()
    #=> <function my_name at 0x10fca5a60> called.
    #=> chris
    #=> <function friends_name at 0x10fca5f28> called.
    #=> naruto
    
    ```
    
    Теперь легко добавить ведение журнала в любую функцию, которую мы пишем. Достаточно написать перед ней @logging.

---

## Какое значение принимает переменная в Python, которая не имеет значения?

- Ответ
    
  Будет иметь значение `None`

---

## KUBERNETES

### Что такое kubernetes?

- Ответ
    
    Это система управления кластерами контейнеров linux.
    
    Кубер может запускать и управлять контейнерами на большом количестве хостов. А также имеет возможность это всё размещать и реплицировать.
    
---

### Какую проблему решает kubernetes?

- Ответ
    1. Масштабирование и запуск контейнеров на большом количестве хостов
    2. Балансировка контейнеров между ними.
    
    Также у кубера есть высокоуровневый API для группирования, размещения и балансирования контейнеров.
    
- Какие задачи он решает
    - Автоматизация инфраструктуры. Он развертывает приложения, откатывает.
    - Масштабирование приложения
    - Supervision - контролер, который мониторит состояние кластера. И сравнивает его состояние с требованиями, которые ему описали.
    - Service discovery - позволяет сервисы находить в автоматическом режиме.
    - Он решает вопросы, которые связаны с логгированием.
    - Решает вопросы с мониторингом и сбором метрик
    - CI\CD
    - Уменьшает vendor lock-in. Мы меньше зависимы от оборудования и провайдеров. Мы тут общаемся с апи кубернетеса. Он как черный ящик, которому мы говорим что делать. И он делает.
    
---

### Что такое minikube?

- Ответ
    
    Локальный кластер для знакомства с кубером, или для проверки каких-либо вещей.
    

### Приведи пример проблемы, которая упрощает работу именно с использованием кубернетеса?

- Ответ
    
    Например, у нас есть три машины. На них запущены контейнеры.
    
    И вдруг одна из машин встала с запущенными контейнерами. Или нужно машину перезапустить. 
    
    И контейнеры нужно переносить.
    
    В итоге нужно будет решать проблемы
    
    1. Контейнеры могут быть связаны, и они должны быть на одной ноде. Значит и перенести нужно на другую ноду их, сохранив эту связанность. Связанность - это использование общих данных. Или активное взаимодействие между собой.
    2. Контейнеры не могут “поместиться” на одном узле, и нужно думать а куда вот эти перевести и распределить
    3. При возвращении ноды в строй придётся возвращать все контейнеры. Снова нужно делать те же манипуляции.

---

### В чем отличие statefulset от Deployment?**

- Ответ
    
    *Deployment* - ресурс Kubernetes предназнваенный для развертывания приложения без сохранения состояния. При использовании PVC все реплики будут использовать один и тот же том, и ни один из них не будет иметь собственного состояния.
    
    *StatefulSet* - поддерживают состояние приложений за пределами жизненного цикла отдельных модулей pod, например для хранилища. Используется для приложений с отслеживанием состояния, каждая реплика модуля будет иметь собственное состояние и будет использовать свой собственный том.
    
    Также statefulset не перебросится на другую ноду. Есть диск, который привязан. И при вымирании ноды, он не переедет в отличие от деплоймента.
    
    Sigterm statefulset может ждать какое-то время.
    
    Statefulset для баз используется потому что там есть темплейт PVC.
    
---

### statefulset что такое ?

- Ответ

    *StatefulSet* - поддерживают состояние приложений за пределами жизненного цикла отдельных модулей pod, 
    например для хранилища. Используется для приложений с отслеживанием состояния, 
    каждый под будет иметь собственное состояние и будет иметь свой собственный PVC.

    - Также statefulset не перебросится на другую ноду. Есть диск, который привязан. И при вымирании ноды, он не переедет в отличие от деплоймента.
      Можно использовать NAS ( network attached storage ), nfs сервер или в целом облачную базу данных для того что бы не привязываться к ноде.

    - Sigterm statefulset может ждать какое-то время. Потому что поды удаляются там строгом порядке, в обратном от создания. 
      В стейтфулсет прилоежниях нужно сохранить состояние у каждого пода и заменеджерить каждый волюм маунт, что так же может
      потребовать больше времени.

    - Название подов у statefulset имеет структуру `<имя statefulset>-<номер пода c 0>`

    - Statefulset так же исплользуется для баз данных потому что:
        - для каждого пода есть темплейт PVC.
        - при создании новой реплики происходит клонирования данных с самого первого пода.
        - когда происходит write то сначала будет происходить запись на самый первый под,
          а затем эти данные будут копироваться на все остальные.
        - удаления подов в statefulset происходит в обратном порядке от создания.

---

### В чем отличие Deployment от Replicaset?

- Ответ
  
  Deployment  упрощает обновление модулей до какой-то определенной или новой версии.
  Допустим, у нас есть набор подов из ReplicaSet-A, чтобы выкатить новую версию нужно создать Replicaset-B.
  При этом нужно уменьшить Replicaset-A и увеличить Replicaset-B на один шаг несколько раз. То есть выполнить последовательное обновление.
  
  А deployment может это делать автоматически. И просто добавляет еще одну абстракцию.
  
  Иными словами - deployment просто выполняет непрерывное обновление с использованием наборов реплик.
    
---

### Что такое Readiness, Liveness, Startup пробы, какое отличие?

- Ответ
    
    Kubelet использует **Liveness** пробу для проверки, когда перезапустить контейнер. Например, Liveness проба должна поймать блокировку, когда приложение запущено, но не может ничего сделать. В этом случае перезапуск приложения может помочь сделать приложение доступным, несмотря на баги.
    
    Kubelet использует **Readiness** пробы, чтобы узнать, готов ли контейнер принимать траффик. Pod считается готовым, когда все его контейнеры готовы.
    
    Одно из применений такого сигнала - контроль, какие Pod будут использованы в качестве бекенда для сервиса. Пока Pod не в статусе ready, он будет исключен из балансировщиков нагрузки сервиса.
    
    Kubelet использует **Startup** пробы, чтобы понять, когда приложение в контейнере было запущено. Если проба настроена, он блокирует Liveness и Readiness проверки, до того как проба становится успешной, и проверяет, что эта проба не мешает запуску приложения. Это может быть использовано для проверки работоспособности медленно стартующих контейнеров, чтобы избежать убийства kubelet'ом прежде, чем они будут запущены.
    
- Ответ попроще
    
    Начну издалека. Для чего нужны такие механизмы? Дело в том, что запущенный под это не значит запущенное и развернутое приложение. Какая-нибудь джава может по пять минут подниматься.  
    Соответственно, нам нужно убедиться в том, что приложение запущено, и что на под можно пускать трафик
    
    **readinessProbe** - проверка готовности контейнера. При помощи описанных условий каких-то.
    
    - Пример
        
        ```
        readinessProbe: # Проверка готовности контейнера
          httpGet: # делаем гет запрос на 80 порт
            path: /
            port: 80
          periodSeconds: 2 # периодичнось опроса
          failureThreshold: 3 # сколько допустимо ошибок
          successThreshhold: 1 #  сколько успешных попыток должно быть чтоб под считался готовым к работе
          timeoutSeconds: 1 #таймаут
        ```
        
    
    **livenessProbe -** предназначена для отслеживания жизнедеятельности контейнера.
    Иногда приложение может не работать. Хотя контейнер вроде как крутится. Но приложение не работает или работает плохо.
    
    У него плюс минус те же параметры, что у **readlinessProde**, но у нее есть параметр `initialDelaySeconds` - который определяет через сколько секунд нужно выполнять liveness проверки после запуска контейнера. Также ее стоит сразу выставить на значение 10. Чтобы сразу не было ошибок о якобы нерабочем поде когда он только-только запускается. 
    
    Штука опасная. Может вернуть ошибочно что под недоступен. И кубер пометит под как нерабочий. И это может приводить к постоянному пересозданию подов. 
    
    Некоторые советуют эту пробу вообще не юзать.

---  

### Что такое оператор в kubernetes?

- Ответ
    
    Это контроллер приложения, который позволяет упаковать, развернуть и управлять приложением кубернетеса. Они расширяют функционал апи куба, и автоматически настраивают, создают экземпляры приложений

    **другая формулировка**
    
    операторы это по сути под который следит за тем что бы некии ресурсы праивильно разворачивались, 
    работали и удалялись, ничего не ломая и тд., так же за счет него можно расширят обычный кластер 
    кубернетиса за счет кастомных ресурсов (CRD).
    
---

### Что такое узел, нода?

- Ответ
    
    Это физическая или виртуальная машина, которая является частью кластера.
    Узел может быть мастером и воркером.
    
    **Мастер** нужен для размещения управляющих и координирующих элементов в кластер.
    
    **Воркер** предназначены для рабочей нагрузки. Подики и приложения
    Как правило отдельные машины на каждое. В миникубе и для мастера, и для воркера одна и та же машина.
    
---

### Опиши архитектуру кубернетес кластера, из чего состоит?

- Ответ
    
    - Мастер ноды и воркер ноды
    
    - В отказоустойчивом кластере должно быть 3 мастер нод, для достижения кворума, когда большее кол-во 
    мастер нод соглашается с решением для изменения данныхх в etcd.

    - Использование нечетного количества мастер-нод помогает избежать ситуации split-brain в Kubernetes. Это явление возникает, когда связь между группами мастер-нод или между всеми нодами одновременно нарушается, и каждая изолированная группаМастерНод/мастер нода начинает считать себя полноценным кластером. Это приводит к проблемам с консистенцией данных в etcd, поскольку разные части кластера могут независимо принимать решения и изменять состояние кластера.
    
    - Воркер нод любое количество - зависит от нагрузки, которую хотим выполнять
    
    **kubectl -** внешний клиент, который обращается к мастер ноде
    
    ---
    
    **Мастер-нода**
    
    **API сервер**
    
    С ним взаимодействуют все компоненты. Он является центральным узлом. Он принимает и обрабатывает запросы по restapi(json и yaml)
    
    **Conroller manager**
    
    Это группа служб, которая следит за состоянием кластера. 
    И которая вносит изменения для приведения фактического состояния кластера к желаеому. Мы говорим куберу что мы хотим видеть в конечном статусе.
    
    **Kube scheduler**
    
    Распределяет рабочую нагрузку по доступным узлам. Распределение выполняется на основании настроек, и на основании текущего использования ресурсов.
    
    Он планирует на каком узле запустить то или иное приложение
    
    **etcd**
    
    Распределенное хранилище. Ключ-значение. Хранит инфу о состоянии кластера.
    
    ---
    
    ***Воркер-нода***
    
    **kublet**
    
    Служба, которая опрашивает апи сервер на предмет того, какие поды предназначены узлу. (На котором служба находится). И запускает, удаляет их через **container runtime engine** (На картинке докер. Может быть что угодно.)
    
    Также информирует api сервер о статусе работающих подов на узле.
    
    **kube proxy**
    
    Компонент, управляющий сетевыми настройками узла. 
    По дефолту куб прокси настраивает с помощью iptables правила маршрутизации 
    на эндпоинты сервиса которые можно узнать с помощью `k describe svc/<svc-name>`.
    Можно зайти на любой узел и сбросить все правила командой `iptables -F`.
    Кубу по дефолту понадобиться 30 секунд что бы понять что праивл нет и восстановить их.
    либо 10 секунд по дефолту что бы обновить правила маршрутизации при изменении
    эндпоинтов или сервисов.
    
    Был вопрос на собесе про куб прокси поподробнее.
    [можно почитать про kube proxy](https://habr.com/ru/companies/flant/articles/359120/)
    
    **Container runtime** (docker) - компонент, взаимодействующий с контейнером.
    
    ![kube-proxy-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2014.png)
    
---

### Что такое pod?

- Ответ
    
    Запрос на запуск одного или более контейнеров на одном узле.
    
    Также под это совокупность контейнеров, которые запускаются в ответ на запрос.
    
    Эти контейнеры разделяют доступ к ресурсам типа томов хранилища, и сетевой стек. И каждый под имеет свой собственный внутренний апи
    
    ![pod-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2015.png)
    

---

### В чем разница между подом и контейнером?**

- Ответ
    
    Под это минимальная единица куба. В котором есть контейнеры. 
    
---

### Как создается под? Какие компоненты задействуются при его создании?

- Ответ

    Предварительная информация.
    Воркер узлы состоят из трех компонентов.
    kubelet - это модуль коммуникации сервера с kubeapi.  
    Он сообщает информацию о себе в куб апи. И принимает ее оттуда же.
    CRI - container runtime engine - штука, которая непосредственно создает контейнер.
    proxy kube server - нужен для взаимодействия узлов между собой, например, когда вычислительные мощности требуют задействовать более, чем один узел.

    Первое что задействуется - команда kubectl.
    Далее оно попадает на kubeAPI.
    KubeAPI - является основным компонентом управления кластером кубера.

    Далее kubeapi аутентифицирует и валидирует запрос. Проверит кто делает запрос, и проверит есть ли у запрашиваемого доступ к кластеру.

    Далее апи сервер запишет этот под в etcd.
    Etcd - это хранилище данных, которое распределено по кластеру, и является "точкой правды" для кластера кубера.
    Далее etcd возвращает ответ в апи о том, что под создан. Но по факту пока что еще ничего не создано кроме записи в базе.

    Далее в дело вступает планировщик, scheduler. Он следит за нагрузкой которую необходимо создать.
    Он определяет на какую ноду можно разместить тот или иной под.
    Он периодически опрашивает куб апи на предмет наличия задач. 
    Шедулер создает поды на воркер узлах, и смотрит на доступные вычивлительные мощности, место и на ограничения. 
    После того, как он определяет где можно создать подходящий под, он сообщает об этом в kubeAPI.

    kubeapi обращается в kubelet той ноды, на которую указал шедулер, как на подходящую.
    kubelet работает вместе с CRI, который создаст под, в котором работает контейнер.



    


    ![pod-create](https://github.com/Swfuse/devops-interview/blob/main/imgs/pod-create.png)

---

### Может ли под запуститься на двух разных узлах?

- Ответ
    
    Нет. Поскольку есть поле узел. И шедулер назначает какому поду куда ехать.
    
---

### Что такое ReplicaSet?

- Ответ
    
    Следующий уровень абстракции над подами.
    
    Она запускает определенное количество подов и гарантирует поддержание данного количества подов. И эти поды могут быть запущены на разных узлах кластера.
    
    ![replica-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2016.png)
    
    В спецификации указываем количество реплик.
    
- Шаблон репликасета
    
    В этом случае будет такой вывод. 
    Название будет состоять из основной части и из случайным образом сгенерированной.
    
    ```
    NAME                  READY   STATUS    RESTARTS   AGE
    my-replicaset-28gs2   1/1     Running   0          7m1s
    my-replicaset-qg47c   1/1     Running   0          7m1s
    ```
    
    ```
    apiVersion: apps/v1
    kind: ReplicaSet
    metadata:
      name: my-replicaset
    spec:
      replicas: 2 # количество контейнеров
      selector:
        matchLabels:
          app: my-app # селектор для поиска своих подов. Так репликасет понимает какой под относится к нему, а какие не к нему
      template: # шаблон этого пода. Две реплики по шаблону тут будут
        metadata:
          labels:
            app: my-app
        spec:
          containers:
            - image: nginx:1.12
              name: nginx
              ports:
                - containerPort: 80
    ```
    
    И вывод такой реплики:
    
    ```
    swfuse@swfuse:~/kuber_manifests$ kubectl get replicasets -o wide
    NAME            DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES       SELECTOR
    my-replicaset   2         2         2       10m   nginx        nginx:1.12   app=my-app
    ```
    
    Видим инфу о копиях в desired
    
    Сколько сейчас запущено в current
    
    Сколько сейчас готово в ready
    
    Возраст в age
    
    Контейнеры
    
    Образ
    
    И метки. По каким меткам репликасет ищет поды.
    
    **ВАЖНО**
    При обновлении файла, и образа например - обновится только репликасет. А вот поды будут со старыми значениями пока их не удалю.
    
    Если я хочу чтоб контейнеры менялись, мне нужен деплоймент.
    
    Репликасет следит только за количеством контейнеров.

---  

### Что такое Deployment?

- Ответ
    
    Переводится как развертывание
    
    Это механизм обновления подов с помощью репликасетов
    
    Он очень похож на репликасет. Но позволяет управляемо обновлять образами подов.
    
    ![deployment-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2017.png)
    

- Шаблон деплоймента
    
    ```
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: my-deployment
    spec:
      replicas: 2 # количество контейнеров
      strategy:
        type: Recreate # стратегия обновления
      selector: # селектор для поиска своих подов
        matchLabels:
          app: my-app 
      template: # шаблон пода
        metadata:
          labels:
            app: my-app
        spec:
          containers:
            - name: nginx
              image: nginx:1.12
              ports:
                - containerPort: 80
    ```
    
    **Recreate** - стратегия пересоздания при обновлении. В остальном то же самое, что и репликасет.
    
    При модификации деплоймента репликасет удаляется и создается новый с новыми настройками
    
    **RollingUpdate** - он постепенный. То есть поды в него постепенно начинают переезжать(удаляются в одном, в новом репликасете создаются). И это регулируется параметрами maxSurge, maxUnavailable. Лимит превышения и недоступности соотвесттвенно. 
    Также репликасеты не удаляются, они будут пустыми. И репликасет это история изменений.
    
    Если создать деплоймент, то можно увидеть следующее
    
    ```
    swfuse@swfuse:~/kuber_manifests$ kubectl get pods
    NAME                            READY   STATUS    RESTARTS   AGE
    my-deployment-c4c8f45fc-ltckj   1/1     Running   0          4s
    my-deployment-c4c8f45fc-qvp6w   1/1     Running   0          4s
    
    swfuse@swfuse:~/kuber_manifests$ kubectl get replicasets
    NAME                      DESIRED   CURRENT   READY   AGE
    my-deployment-c4c8f45fc   2         2         2       17s
    ```
    
    Создается репликасет с названием деплоймента+уникальныйайди
    
    И поды создаются из названиядеплоймента+уникальныйайдирепликасет+уникальныйайди
    
    Когда создается деплоймент, он внутри себя создает репликасет.
    
    Чтобы обратиться к айпишникам внутри кластера можно попробовать сделать следующее:
    
    ```
    kubectl run --rm -it --image amouat/network-utils test bash
    ```
    
---

### Что такое Service

- Ответ
    
    Service - обеспечивает сетевой доступ к поду снаружи.
    
    Это тип ресурса, который заставляет прокси настраиваться на пересылку запросов на набор контейнеров.
    
    У каждого пода айпишник постоянно меняется. И сервис это абстракция, которая предоставляет сетевой доступ к приложению, который работает на группе подов. А также балансирует запросы к этим подам.
    
    Отличается от всех других тем, что не предоставляет свой айпишник
    
---

### Какие типы service бывают?

- Ответ
    - Без селектора
    - ClusterIP - по умолчанию. Сервису выделяется отдельный айпишник внутри кластера. Доступ можно сделать с помощью проксировани.
    - NodePort - выделяется айпи внутри кластера, и на каждом узле выделяется порт из диапазона 30000 - 32767.  То есть указываем на каком порте узлов это работает
    - LoadBalancer - использует внешний айпи адрес. И он уже перенаправляет трафик на нод порт и кластер айпи, которые создаются автоматически. Минус в том, что внешний айпи адрес стоит денег. В облаке доступен из коробки а на bare metal нужно что то стороннее, допустим [MetalLB](https://metallb.universe.tf/)
    - ExternalName - перенаправление трафика. Через cname в днс кластере.

---

### Что такое Ingress

- Ответ
    
    Это не тип сервиса, но это абстракция связана с предоставлением доступа к сервисам извне.
    
    Чем-то похоже на нжинкс. Который по локейшнам перенаправляет что-то куда-то.

    есть такая особенность что ингресс перенаправляет трафик не на сервис, который
    мы прописываем в backend.service.name а сразу на ендпоинты, что бы исключить
    этот лишний хоп.
    
---

### Что такое Job

- Ответ
    
    Одноразовая задача. Создает один или несколько подов, и ожидает их успешного завершения.
    
    Если что-то завершается с ошибкой, то джоб бдует запускать новые копии, пока количество успешных выполнений не будет равно заданному.
    
    Типовые примеры:
    
    - Запуск тестов
    - Применение миграций базы данных
    - Выполнение одноразовых скриптов
    
- Пример джобы
    
    Успешное выполнение сколько раз нужно чтоб выполнились задачи
    
    Параллельные запуски - контейнеры будут подниматься, одновременно выполняться. Если 1, то друг за дружкой выполняться
    
    **Backofflimit** - максимальное количество попыток. Джоб после этого не будет пытаться что-то делать. И новых контейнеров не создаёт.
    
    **activeDeadlineSecond** - таймлайны для джобы. Больше ничего создаваться не будет. 
    
    **ttlSecondsAfterFinished** - максимальное время жизни завершенного джоба. Нужна для того, чтобы человек мог успеть посмотреть результат. В контейнере логи глянуть например.
    
    **restartPolicy** - регулируем перезапускать или нет. Но самому контейнеру за этим следить не надо. Поэтому Never
    
    ![restart-policy-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2018.png)
    

---

### Что такое CronJob

- Ответ
    
    Абстракция, которая автоматически создаёт поды по расписанию. 
    Расписание задаётся в крон-формате.
    
    Применение:
    
    - Рассылки писем, уведомлений
    - Бэкапы
    - Выполнение задач в менее нагруженное время
    
- Пример кронджобы
    
    ![cronjob-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2019.png)
    
---

### Что означает версия api (apiVersion)

- Ответ
    - v1
    - v2beta1
    - v3aplha1
    - extensions/v1/beta1
    
    **Alpha-версии** - отключены по умолчанию. Могут содержать баги. Поддержка может быть прекращена в любое время. И совместоимость с будущими не гарантируется. Не рекомендуется использовать в продакшене.
    
    **Beta-версии** включены по умолчанию. Хорошо протестированы. Поддержка не будет прекращена, но может быть разница в семантике. Если она меняется - будет инструкция по миграции. Не рекомендуется использовать в проде. Но можно в dev для тестирования фич.
    
    **Стабильные версии API** - готовы для продакшена. Совместимы с будущими версиями.
    
---

### Что такое namespace?

- Ответ
    
    Это пространство имен.
    Пространство имен - это способ разделения ресурсов в кластере между пользователями или проектами.
    
    1. Все имена ресурсов должны быть уникальными в пределах одного и того же пространства имён.
    2. Каждый ресурс может быть только в одном пространстве имен
    3. Пространства имен не могут быть вложенными.
    
    ---
    
    По умолчанию существует три пространства имен
    
    - **Default** - пространство имён по умолчанию для объектов. Без какого-либо иного пространства имён
    - **kube-system** - пространство имён для системных служебных объектов кубернетеса.
    - **kube-public** - создаваемое автоматически пространство имён, которое доступно для чтения пользователями. Данное пространство имён обычно используется кластером, если ресурсы должны быть общедоступными.

---

### Что такое Volume

- Ответ
    
    Volume - это абстракция файлового хранилища.
    
    Решает следующие основные проблемы:
    
    - Файловая ситема контейнера существует только до его удаления или перезапуска
    - Некоторым контейнерам нужно общее пространство для хранения файлов, или для обращения к конфигурационным файлам.
    - Изолирует приложение от технологий хранения данных
    
    Живет только с подом

---   

### Какие бывают типы файловых хранилищ

- Ответ
    
    **emptyDir**
    
    Каталог, который создается до пода, и и живет пока под не будет удален. Все контейнеры в нем могут читать данные из этого volume.
    
    В качестве системы хранения - используется файловая система узла.
    
    **hostPath**
    
    В hostpath папка на узле уже существует, и подключается к подам. Данные не пропадают после удаления пода.
    
    В случае с emptyDir создается папка, подмонтируется. Если под падает - данные пропадают.
    
    Используется для случаев, когда под отслеживает состояние узла. Предоставляется доступ к системным каталогам
    
    Также там есть ключи DirectoryOrCreate и FileOrCreate - они нужны для задачи кубернетесу проверить наличие папки, и потом обращение к файлу.
    
    
---

### Что такое configMap?

- Ответ
    
    API объект, который используется для хранение неконфиценциальных параметров типа ключ значение.
    
    Это этакое хранилище параметров
    
    Поды могут использовать значения оттуда несколькими способами:
    
    - Конф файлы, подключаемые как volumes
    - Через Переменные окружения
    - Через Параметры запуска контейнеров
- Пример использования
    
    ![configMap-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2020.png)
    
    В volumes на уровня деплоймента в спецификации указывается конфиг мап, и имя конфиг мапа. 
    
    А в спеке контейнера указываем имя уже этого вольюма
    
---

### Что такое Secret

- **Ответ**
    
    Объект, который содержит конфиденциально важное значение. (пароль, токен, ключ).
    
    Хранение важных параметров в виде секретов более безопасно и гибко, чем включение их в конфигурацию пода или в образы контейнеров.
    
    Для использования секрета поду необходимо указать его.
    
    Секрет может использоваться следующими способами:
    
    - Файл подключенный через volume контейнера.
    - Значение переменной окружения
    - kubelet использует секреты для подключения к апи серверу, для загрзки образов из докер регистри

---

### Что такое PersistentVolume, PersistentVolumeClaim

- Ответ
    
    **PersistentVolume (PV)**  - такой же ресурс кластера, как и узел. Он предоставляет не вычислительные русерсы, а тома дисковые. Примеры: NFS, RBD, CephFS и другие. В рамках PV впоследствии можно выделять подам место для хранения данных.
    
    **PersistenceVolumeClaim(PVC)**  - запрос к PV на выделение места под хранение данных. Это аналог создания пода на узле. Поды могут запрашивать определенные ресурсы узла, то же делает и PVC. Сколько ему места нужно, типы доступа. Основные параметры запроса:
    
    - Объем места
    - Тип доступа
    
    **Типы доступа у PVC**:
    
    - **ReadWriteOnce** - том может быть смонтирован на чтение и запись к одному поду
    - **ReadOnlyMany** - том может быть смонтирован на много подов в режиме реального времени
    - **ReadWriteMany** - том может быть смонтирован к множеству подов в режиме чтения и записи
- Схема статической и динамической
    
    ![pvc-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2021.png)
    
    **Статическое**.
    
    Сторадж это хранилище. Диск, облачный ресурс.
    
    Для того, чтобы к поду подмонтировалась часть пространства, администратор должен создать набор PersistanceVolume. Допустим диск на 500гб, админ нарезает его с помощью PersistanceVolume на блоки. По 10, 20, 50 гб. И так далее. Короче набор таких PV.
    
    Когда поду нужно место PVC делает заявку о том, что ему нужен диск определенного размера с определенным типом доступа. И кубер подбирает подходящие PV. И не всегда запрос совпадает с тем, что есть. Допустим, у нас нарезано по 100гб PV, а PVC запрашивает на 5 гб, то кубер отдаст на 100. Других вариантов нету просто. Нужно оптимиально их разбивать.
    
    Эту проблему решает динамическая схема создания.
    
    **Динамическое**
    
    Здесь плагин сам формируует PV при наличии запроса на него.
    
    Админ создает сторадж класс, где описывается сторадж, который подключил к кластеру. Ну и с помощью плагина в ответ на запрос pvc кубер создаст pv нужного размера, и предоставит для пода.
    
---

### Что такое nodeSelector, nodeName?

- Ответ
    
    Это тип балансировщика.
    
    В спецификации пода указываются метки узлов (nodeSelector), на которых мы хотим его запустить или указывается определенный узел (nodeName)
    
    Например
    
    ```
    # Данный под будет назначен на узел, где есть специфический тип диска
    nodeSelector:
      disktype: ssd
    
    # можем указать название узла куда под должен быть направлен
    nodeName: kube-01
    ```
    
---

### DaemonSet зачем нужен для чего его обычно используют?**

- Ответ
    
    У него широкое распространение. Нужен для сбора логов по разным нодам. Логи как-то надо собирать. Сертификаты нод. Смотреть через демонсет можно такие штуки

    Еще Daemonset не нужен шедулер ведь для сразу резервируются ресурсы на каждой ноде
    
---

### Что такое Taints, Tolerations?

- Ответ
    
    Можно настроить список блокировок (taints). Или как зараза. И если в спецификации пода не указана сопротивляемость к блокировкам(tolerations), то он не сможет попасть на определенный узел.
    
    То есть мы говорим поду где НЕ запускаться.
    
    Виды блокировок:
    
    **NoSchedule**
    
    Не размещать на узле без соответсвующих tolerations, поды которые уже работают на узле, не будут затронуты.
    
    **PreferNoSchedule**
    
    Предпочитать не размещать на узле поды без соответствующих tolerations, но  не требовать этого.
    
    **NoExecute**
    
    Не размещать на узле поды без соответствующих tolerations. все поды которые уже есть на 
    ноде с таким taint и не будут иметь соответствующие tolerations, будут мувнуты с нее на другю ноду.
    

### Что такое Requests, Limits?

- Ответ
    
    В спецификации пода мы можем указать плановое потребление ресурсов(requests) и лимиты использования ресурсов(limits). Нужный узел подбирается автоматически с учетом текущей нагрузки.
    
    cpu: 50m - m -milicpu. 
    
    limits - контейнер будет убить. Непредсказумая настройкая.
    
    Есть QoS классы подов
    
    - Guaranteed (limits = requests) //Под не может превысить свои ресурсы. Сколько запросил столько и получил
    - Burstable (limits > requests) кто-то запросил 50 цпу, но иногда превышает его. И часть контейнеров при нагрузке будут переезжать
    - BestEffort (не указаны limits и requests) - не указываем лимиты реквесты. Первыми будут переезжать эти
    
    Можно увидеть через describe пода
    
---

### Affinity, anti-affinity**

- Ответ
    
    В спецификации пода указываются требования и пожелания к узлам, а также к уже существующим подам.
    
    Как нод селектор. Но можно заказать условия. Типа метка может быть определенных типов, перечисленных.

    **example**:

    ```yaml
    affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          #параметр выше отвечает за то, что эти правила бдуут применяться при планировки а не при работе нод и тд
            nodeSelectorTerms:
            - matchExpressions: #disktype должен быть не hdd
              - key: disktype
                operator: NotIn
                values:
                - hdd
            - matchExpressions: #RAM памяти должено быть больше чем 8гб на ноде 
              - key: memory
                operator: Gt
                values:
                - 8Gi
            - matchExpressions: #gpu должн обыть на ноде
              - key: gpu
                operator: Exists
      podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - weight: 100 #позволяет задать вес правилу и там самым можно управлять их приоритетностью
        podAntiAffinityTerm:
          labelSelector:
            matchExpressions: #в целом это правило указываеьт что бы поды с меткой app = web-app были на разных хостах
            - key: app
              operator: In
              values:
              - web-app
          #topologyKey позволяет указать на каком уровне будут применяться правила, здесь на уровне  хоста
          topologyKey: kubernetes.io/hostname 
      podAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
        - podAffinityTerm:
            labelSelector: 
              matchExpressions: #лейбл security должен быть = s1 на поде
              - key: security
                operator: In
                values:
                - s1
            topologyKey: kubernetes.io/hostname
    ```
    
---
    

### Что такое Helm

- Ответ
    
    Пакетный менеджер для кубера.
    Шаблонизатор для управления
    
    Пакет в helm это набор yml и tpl файлов.

    *.tpl файлы нужны для определения каких то функций
    который будут возвращать какие то параметры либо имена и тд
    в файле *.tpl ты с помощью ключевого слова define определяешь функцию
    а в самом хелм чарте с помощью include, вставляешь ее результат.
    Обычно используется для генерации labels, полных имен и тд.
   
---

### Что дает helm в кубе ?

- Ответ

    1. Версионирования.
    2. Шаблонизирование.
    3. Удобство развертывания инфраструктуры на разные контура.
    4. Более подконтрольная работа с конкретной разворачиваемой инфраструктурой.
    5. Возможность подтягивать зависимости. Допустим  если у тебя хелм чарт 
       зависит от другого хелм чарта, ты можешьб либо в самом Chart.yml 
       файле в директиве dependency прописать зависимотси, либо 
       в отдельном файле requirements.yml прописать все зависимости
       и перед раскаткой основного хелм чарта поднятнуть все зависимости командой 
       `helm dependency update`.


---

### если лимит больше чем реквест и нету ресурсов на ноде и выложиться ли такой под

- Ответ
   
   да, ведь по реквесту под может развернуться, но как только под будет требовать ресурсов больше чем есть на ноде то под убьеться (этот процесс называется оверкомит, и как в линуксе есть что каждый процесс может запуститься но потом убьется если будет тербовать много ресурсов)


---
### Через что реализованы сети в kubernetes? 

- Ответ

    Кубер для реализации сетей использует различные плагины CNI (Container Networking Interface). 
    Наиболее известные **flannel** и **calico**.

    Пример получения IP используя *flannel*:
    Kube-controller-manager каждому узлу присваивает podCIDR. Pod'ы каждого узла получают IP-адреса из пространства адресов в выделенном диапазоне podCIDR. Поскольку podCIDR'ы узлов не пересекаются, все pod'ы получают уникальные IP-адреса.
    Во время старта агент сетевого провайдера генерирует конфиг CNI. Когда pod планируется на узел, kubelet вызывает CRI-плагин для его создания. Далее, если используется containerd, плагин Containerd CRI вызывает CNI-плагин, указанный в конфиге CNI, для настройки сети pod'а. 
    В результате pod получает IP-адрес.
    ![flannel-netowrk](./imgs/kubernetes-flannel-network.png)

    Плюсы использования *calico*
    * поддерживает network policies

---

### Что произойдет при изменении имейджа? Как будут докатываться изменения?

- Ответ
    
    В общем случае создастся количество подов с определенным заданым количеством. Потом будут уходить “старые" поды. Это контролируется политикой обновлений.
    
    И когда хелсчеки прошли по новым.
    

---

### Что такое headless service ? 

- Ответ

    Это такой сервис, который привязывается к какому-то ворклоаду и не имеет как такового IP адреса, а имеет DNS запись. 
    При ответе он подставляет не свой IP адрес, а все IP адреса, которые лейблом к этому хедлесс сервису.
    
    Как я понял, это полезно, когда тебе нужно у какой-то группы подов раскрыть их имена и обращаться к ним 
    напрямую без балансировки нагрузки, что может помочь не взаимодействовать с мертвыми подами.

    в ямле это сервисе где указывается `clusterIP: None` и может выглядить как:
    
    ```yaml 
    apiVersion: v1
    kind: Service
    metadata:
      name: my-headless-service
    spec:
      selector:
        app: web-app
      clusterIP: None
      ports:
        port: 80
        targetPort: 8080
    ```

    допустим как может выглядеть пример взаимодействия через headless servic  и черещз обычнй сервис

    ```bash
    kubectl get pods -l app=web-app -o jsonpath='{.items[*].metadata.name}' #получаем список подов

    curl http://<pod-name>.my-headless-service.default.svc.cluster.local #делам запрос на конкретный под

    curl http://my-headless-service.default.svc.cluster.local:80 #может сделать запрос просто на сервис
    ```

    через обычный сервис
    
    ```bash
    curl http://common-service
    ```
---

## GITLAB CI/CD

### Каковы ключевые компоненты GitLab CI/CD?

- Ответ
    - Ключевые компоненты включают в себя:

    **Файл .gitlab-ci.yml:**
    - Определяет конфигурацию конвейера
    - Содержит описание всех job, stages, переменных и правил
    - Должен находиться в корне репозитория

    **Runners:**
    - Выполняют задания (jobs)
    - Могут быть shared (общие), group (групповые) или specific (проектные)
    - Поддерживают различные executors (Docker, Shell, Kubernetes и др.)

    **Задания (Jobs) и этапы (Stages):**
    - **Jobs** - отдельные задачи с командами для выполнения
    - **Stages** - группируют jobs и определяют порядок их выполнения
    - Jobs в одном stage выполняются параллельно
    - Stages выполняются последовательно

    **Конвейеры (Pipelines):**
    - Автоматизируют рабочие процессы от написания кода до развертывания
    - Запускаются автоматически при push, merge request или по расписанию
    - Состоят из одного или нескольких stages

    **Пример базовой структуры:**

    ```yaml
    stages:
      - build
      - test
      - deploy

    variables:
      NODE_VERSION: "18"

    build_job:
      stage: build
      script:
        - npm install
        - npm run build
      artifacts:
        paths:
          - dist/

    test_job:
      stage: test
      script:
        - npm run test
      coverage: '/Coverage: \d+\.\d+%/'

    deploy_job:
      stage: deploy
      script:
        - npm run deploy
      only:
        - main
    ```

---

### Что такое before_script и after_script в GitLab CI/CD?/CD?

- Ответ
    - `before_script` - выполняет команды перед основным скриптом каждой job
    - `after_script` - выполняет команды после основного скрипта каждой job

    **Особенности использования:**

    **before_script:**
    - Выполняется в той же shell-сессии, что и script
    - Если завершается с ошибкой, job помечается как failed
    - Переменные, установленные здесь, доступны в script

    **after_script:**
    - Выполняется в отдельной shell-сессии
    - Всегда выполняется, даже если script завершился с ошибкой
    - Переменные из script и before_script недоступны
    - Не влияет на статус job

    **Пример использования:**

    ```yaml
    job_example:
      before_script:
        - echo "Setting up environment"
        - export DATABASE_URL="test://localhost"
        - npm install
      script:
        - echo "Running main script"
        - npm run test
      after_script:
        - echo "Cleaning up"
        - docker stop test-container || true
        - rm -rf temp-files/

    # Глобальные before_script и after_script для всех job
    default:
      before_script:
        - echo "Global setup"
      after_script:
        - echo "Global cleanup"

    # Переопределение глобальных настроек в конкретной job
    custom_job:
      before_script:
        - echo "Custom setup only"
      script:
        - echo "Custom script"
      # after_script наследуется от default
    ```

---

### У вас есть 5 проектов на одном языке программирования. Как организовать пайплайны, чтобы избежать дублирования конфигурации?

- Ответ
    - Для избежания дублирования конфигурации используйте следующие подходы:
        1. **Создание общих шаблонов** - вынесите повторяющиеся задачи (`build`, `test`, `lint`) в отдельный YAML-файл
        2. **Использование `include`** - подключайте общие конфигурации в проектах
        3. **Применение шаблонов** - используйте `extends`, `rules`, переменные окружения

    **Пример структуры:**

    ```yaml
    # common-templates.yml
    .build_template:
      stage: build
      script:
        - npm install
        - npm run build
      artifacts:
        paths:
          - dist/

    .test_template:
      stage: test
      script:
        - npm run test
      coverage: '/Coverage: \d+\.\d+%/'

    # В каждом проекте .gitlab-ci.yml
    include:
      - project: 'templates/ci-templates'
        file: 'common-templates.yml'

    build_job:
      extends: .build_template

    test_job:
      extends: .test_template
    ```

---

### Как запускать тесты только при создании merge request?

- Ответ
    - Используйте директиву `rules` с условием проверки источника пайплайна:

    ```yaml
    test_job:
      stage: test
      script:
        - echo "Running tests for merge request"
        - npm run test
      rules:
        - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    ```

    **Дополнительные варианты контроля:**

    ```yaml
    # Запуск только для MR в определенную ветку
    test_mr_to_main:
      script:
        - npm run test
      rules:
        - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"'

    # Запуск при изменении определенных файлов
    test_on_changes:
      script:
        - npm run test
      rules:
        - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
          changes:
            - "src/**/*"
            - "tests/**/*"
    ```

    **Документация:** https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/

---

### Если в before_script переопределить переменную, будет ли она доступна в script?pt`?

- Ответ
    - Да, переменная будет доступна. Все секции `before_script`, `script` и `after_script` выполняются в рамках одной shell-сессии в пределах одной job.

    **Пример:**

    ```yaml
    job_with_variable:
      variables:
        ORIGINAL_VAR: "initial_value"
      before_script:
        - export MODIFIED_VAR="modified_in_before_script"
        - echo "MODIFIED_VAR in before_script: $MODIFIED_VAR"
      script:
        - echo "MODIFIED_VAR in script: $MODIFIED_VAR"  # Будет доступна
        - echo "ORIGINAL_VAR: $ORIGINAL_VAR"           # Тоже доступна
      after_script:
        - echo "MODIFIED_VAR in after_script: $MODIFIED_VAR"  # И здесь тоже
    ```

    **Важно:** Переменные, определенные в одной job, не передаются в другие job без использования артефактов или других механизмов.

---

### Какие существуют способы контроля запуска job в GitLab CI?

- Ответ
    - Существует несколько механизмов для контроля выполнения job:

    **1. Rules (рекомендуемый способ)**
    
    Наиболее гибкий и современный подход:

    ```yaml
    deploy_job:
      script:
        - echo "Deploying to production"
      rules:
        - if: '$CI_COMMIT_BRANCH == "main"'
        - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
          when: manual
        - when: never
    ```

    **2. Only/Except (устаревший)**
    
    ```yaml
    build_job:
      script:
        - echo "Building application"
      only:
        - main
        - develop
      except:
        - tags
    ```

    **3. Встроенные переменные**
    - `$CI_COMMIT_BRANCH` - название текущей ветки
    - `$CI_PIPELINE_SOURCE` - источник запуска пайплайна
    - `$CI_COMMIT_TAG` - тег коммита
    - `$CI_MERGE_REQUEST_TARGET_BRANCH_NAME` - целевая ветка MR

    **4. Changes и Paths**
    
    ```yaml
    test_frontend:
      script:
        - npm run test
      rules:
        - changes:
            - "frontend/**/*"
            - "package.json"
    ```

    **5. Manual jobs**
    
    ```yaml
    deploy_production:
      script:
        - echo "Deploying to production"
      when: manual
      only:
        - main
    ```

    **6.Через `when`**
    - `when: always` - всегда выполнять
    - `when: on_success` - только при успехе предыдущих job (по умолчанию)
    - `when: on_failure` - только при провале предыдущих job
    - `when: manual` - запуск вручную
    - `when: never` - никогда не выполнять



### Что такое кэширование в GitLab CI/CD?

- Ответ
    - Кэширование позволяет сохранять файлы и директории между запусками job или пайплайнов для ускорения выполнения и сокращения времени сборки.

    **Основные принципы:**
    - **Цель** - избежать повторной загрузки зависимостей (node_modules, vendor/, .m2/, etc.)
    - **Область действия** - может использоваться внутри одного пайплайна или между разными пайплайнами
    - **Ключ кэша** - определяет уникальность и условия обновления кэша

    **Пример базового кэширования:**

    ```yaml
    variables:
      npm_config_cache: "$CI_PROJECT_DIR/.npm"

    cache:
      key: "$CI_COMMIT_REF_NAME"
      paths:
        - node_modules/
        - .npm/

    install_dependencies:
      stage: build
      script:
        - npm ci --cache .npm --prefer-offline
      cache:
        key: "$CI_COMMIT_REF_NAME-$CI_JOB_NAME"
        paths:
          - node_modules/
        policy: pull-push  # Загружает и сохраняет кэш

    test_job:
      stage: test
      script:
        - npm run test
      cache:
        key: "$CI_COMMIT_REF_NAME-install_dependencies"
        paths:
          - node_modules/
        policy: pull  # Только загружает кэш
    ```

    **Стратегии кэширования:**

    ```yaml
    # По содержимому файлов (рекомендуется)
    cache:
      key:
        files:
          - package-lock.json
      paths:
        - node_modules/

    # По ветке
    cache:
      key: "$CI_COMMIT_REF_NAME"
      paths:
        - vendor/

    # Глобальный кэш
    cache:
      key: "global-cache"
      paths:
        - .m2/repository/
    ```

    **Политики кэширования:**
    - `pull-push` (по умолчанию) - загружает перед job, сохраняет после
    - `pull` - только загружает существующий кэш
    - `push` - только сохраняет кэш после выполнения

    **Важные моменты:**
    - Кэш не гарантирован - может быть очищен в любой момент
    - Для критически важных файлов используйте артефакты, а не кэш
    - Кэш работает быстрее артефактов, но менее надежен

---

## GIT

### Чем `merge` отличается от `rebase`?

- Ответ
    - `git merge` - выполняет слияние коммитов из одной ветки в другую. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.
        
        ![https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-merge.png](https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-merge.png)
        
        *Преимущества*:
        
        1. Простота,
        2. Сохраняет полную историю и хронологический порядок,
        3. Поддерживает контекст ветки.
        
        *Недостатки*:
        
        1. История коммитов может быть заполнена (загрязнена) множеством коммитов,
        2. Отладка с использованием git bisect может стать сложнее.
    - `git rebase` - сжимает все изменения в один патч. Затем интегрирует патч в целевую ветку. В отличии от *merge*, *rebase* перезаписывает историю, потому что она передаётся завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.
        
        ![https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-rebase.png](https://github.com/rmntrvn/adm_linux_ops_questions/raw/master/questions/imgs/git-rebase.png)
        
        *Преимущества*:
        
        1. Упрощает потенциально сложную историю,
        2. Упрощение манипуляций с единственным коммитом,
        3. Избежание слияния коммитов в занятых репозиториях и ветках,
        4. Очищает промежуточные коммиты, делая их одним коммитом, что полезно для DevOps команд.
        
        *Недостатки*:
        
        1. Сжатие фич до нескольких коммитов может скрыть контекст
        2. Перемещение публичных репозиториев может быть опасным при работе в команде,
        3. Появляется больше работы,
        4. Для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно.
---

### Когда нужно использовать `merge`, когда `rebase`?

- Ответ
    
    Предназначение этих команд git – интеграция изменений из одной ветки в другую, но делают они это по-разному.
    
    Предположим, у вас сложилась такая ситуация:
    
    ```
    A <- B <- C    [master]
    ^
     \
      D <- E       [branch]
    ```
    
    После обычного мержа репозиторий будет выглядеть так:
    
    ```
    A <- B <- C
    ^         ^
     \         \
      D <- E <- F
    ```
    
    А после `git rebase`– так:
    
    ```
    A <- B <- C <- D <- E
    ```
    
    Rebase указывает на то, что коммиты нужно буквально перенести со старого места на новое.
    
    Что выбрать?
    
    - Если вы сомневаетесь, то используйте обычное слияние.
    - Выбор между merge и rebase обусловлен тем, какой вы хотите видеть историю коммитов: линейной или ветвящейся.
    
    Учитывайте следующие факторы:
    
    1. Если ветка, в которую вы хотите внести изменения доступна для других разработчиков (например, в open source проекте), не используйте rebase. Эта команда удаляет ветку целиком и приводит к рассинхронизации копий
    репозиториев.
    2. Представляет ли исходная ветка ценность? Некоторые команды работают
    по принципу «одна функция – одна ветка», при этом ветка идентифицирует
    последовательность коммитов. В модели «один разработчик – одна ветка» в
    этом нет особой необходимости, так как автор коммита известен.
    3. Не захотите ли вы вдруг отменить слияние? Возврат rebase значительно затруднен по сравнению с обычным слиянием, а иногда даже невозможен.

---

### Чем отличается git pull и git fetch

- Ответ
    
    При использовании `pull`, git пытается сделать всё за вас. Он сливает любые внесённые коммиты в ветку, в которой вы сейчас работаете. 
    
    Команда `pull` автоматически сливает коммиты, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.
    
    При использовании `fetch`, git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку
    
- Краткий ответ
    
    git pull — это, по сути, команда git fetch, после которой сразу же следует git merge.
    
    Команда git fetch получает изменения с сервера и сохраняет их в каталог refs/remotes/. Это действие (fetch) не влияет на локальные ветки и текущие изменения, просто изменения с удаленного сервера скачиваются в директорию локального репозитария.
    
---

### Что такое cherry pick ?

- Ответ
    
    Команда `git cherry-pick` используется для перенесения 
    отдельных коммитов из одного места репозитория в другое, обычно между 
    ветками разработки и обслуживания. Этот механизм отличается от привычных
     команд git merge и git rebase, которые переносят коммиты целыми 
    цепочками.
    
---

### Какие пратики работы с гитом вы знаете? Форки

- Ответ
    
    Работа через форки принципиально отличается от других популярных методов организации командной разработки. Вместо того чтобы использовать один серверный репозиторий в качестве центральной кодовой базы, здесь каждый разработчик получает свой собственный репозиторий. Чаще всего эта модель применяется в общедоступных open source проектах.
    
    Основное преимущество forking workflow заключается в том, что все изменения вносятся без загрязнения истории проекта. Разработчики делают push в собственные репозитории, а доступ к центральному есть только у менеджера.
    
    Когда обновление готово к интеграции, программист делает pull-запрос в главный репозиторий, а менеджер одобряет и вносит его.

    В принципе какие сть форки:
     - central workflow - когда все сразу с мастер пушится 
     - trunk based - есть 3 ветки: мастер, дев, фьечер.
       основные особенности такой разработки что ветки живут недолго, что есть флаги которыми можно выключить и включать фичи, код в мастере почти всегда готов к деплою даже если в нем есть недоработанные фичи, постоянное код ревью кода (ревью пару минут на микро изменения и мерж)
     - gitflow 

    ![по подробнее почитать про trunk based development](https://habr.com/ru/articles/519314/)
    
---

### Что такое GitFlow?

- Ответ
    
    [Модель gitflow](https://proglib.io/p/git-github-gitflow/) использует две параллельные «долгие» ветки для хранения истории проекта: master и develop.
    
    - **Master** – это полностью готовое к релизу состояние со всеми пройденными тестами.
        - **Hotfix** – ветки обслуживания, или хотфиксы, которые
        используются для быстрых патчей. Они очень похожи на feature, но вместо
        develop-ветки базируются на master.
    - **Develop** – ветка, в которой объединяются и тестируются все отдельные разработки. После прохождения проверок они отправляются в master.
        - **Feature** – отдельная ветка для каждой новой функциональности, изменения из которой отправляются в develop.
    
   ![gitflow-img](https://github.com/Swfuse/devops-interview/blob/main/imgs/Untitled%2022.png)


---

## Terraform

### Отличие ansible и terraform 

- Ответ

    **Terraform** - Предназначен для представления инфраструктуры как код и автоматизации ее развертывания. 
    
    **Ansible** - Предназначен для автоматизации развертывания и конфигурации приложений.
    
    То есть Terraform используется что бы разворачивать инфраструктуру (виртуальные машины, сети, диски, и тп.).
    Ansible предназначен для работы с существующими ресурсами, чтобы устанавливать и настраивать окружение (программы, операционные системы) на этих виртуалках.

    Нюансы:
     Terraform отслеживает состояние и делает инкрементные изменения, что особенно полезно при работе с облачной инфраструктурой.
     Ansible не управляет состоянием, и каждая задача считается независимой.

     Нужно понимать, что это инструменты. И в ряде случаев с помощью Ansible равзвернуть инфраструктуру всё таки можно. 
     Как и для терраформа написать провайдер, который будет делать что-то свое. Вопрос лишь в применимости инструментов. 

---

### Что такое провайдер в terraform

- Ответ

    Это утилита, прослойка, которая позволяет Terraform взаимодействовать с определенным API облачного провадйера.
  
    Провайдеры используются для настройки и управления ресурсами, которые разворачиваются в облаке этого провайдера.

---

### Что такое ресурс в terraform

- Ответ


  Это какой то блок кода, который описывает объект в инфраструктуре. Каждый ресурс имеет свои какие то аргументы, свои параметры, свою конфигурацию. Ресурс имеет свой какой то уникальный идентификатор (ID, ARN и тд).

  Виртуальная машина, сеть, диск, порт, балансировщик и тд.


---

### Что такое tfstate

- Ответ

  Это файл, которй хранит определенное состяние инфраструктуры на момент последнего запуска.
  Используется для отслеживания состояния инфраструктуры терраформом.

---

### configure drift что такое

- Ответ
  
   Это ситуация, когда фактическое состояние инфраструктуры в облаке отличается от ожидаемого состояния, прописанного в terraform файлах.


   Может возникать при изменении ресурсов вне терраформа, либо правки tfstate файла вручную.


   Может привести к удалению ресурсов, либо привести к нежелательным изменениям.

---

### Как блокировать tfstate 

- Ответ 
 
  в AWS облаке tfstate блокируется с помощью dynamoDB.

  При создании DynamoDB в поле Primary key указывается значение LockID типа String.

  В коде это выглядит вот так:

  ```HCL
  
    terraform {
      backend "s3" {
        bucket = "backet_name"
        encrypt = true
        key    = "dev/network/terraform.tfstate"
        region = "us-east-1"
        dynamodb_table = "terraform_state_block_DynamoDB"
    
      }
    }


  ```



  Посмотреть как это делается можно тут -> https://www.youtube.com/watch?v=R9so36Uob8c


---

### Как можно ресурс созданный в GUI перенести в код terraform

- Ответ

  можно использовать terraform import прописав сначала куда импортировать, а затем id ресурса который нужно импортировать

  Пример:

  ```bash

   terraform import aws_instance.instance_to_import  your_resource_id

  ```

  Либо можно в коде прописать секцию import указав id ресурса и куда импортировать
  
  ```HCL

      import {
         id = "your_resource_id"
         to = aws_instance.instance_for_import
       }

  ```

  - После:

  1) terraform plan для того, что бы посмотреть как terraform будет импортировать ресурсы

  2) Потом Apply для того что бы импортировать ресурсы и обновить state file.



  - Можно прописать `terraform plan -generate-config-out=generated.tf` если в конфигурации нету ресурса для импорта и после = написать ваше название файла .tf


  Почитать поподробнее можно здесь -> https://developer.hashicorp.com/terraform/language/import


---

### Отличие contidion от look up

- Ответ

  - lookup это функция которая принимает словарь переменных, который мы пишем обычно в variable.tf файле и ключ значения которое хотим от туда взять

  функция с переменными выглядит как

  **X = lookup(map, key)**

  - Conditions это условия выбора какой либо переменной

  условие с переменными выглядит так

  **X = CONDITION ? IF_TRUE : IF_FALSE**

  Пример как это можно использовать в коде:

  ```HCL

   #condition
   resource "aws_instance" "server" {
     instance_type = var.env == "prod" ? "t3.large" : "t3.micro"
   
   }
   
   #lookup
   variable "ec2_types" {
     default = {
       "prod" = "t3.large"
       "staging" = "t3.medium"
       "dev" = "t3.micro"
     }
   }
   
   resource "aws_instance" "default" {
     instance_type = lookup(var.ec2_types, "prod")
   }

  ```

----

### Ты накидал код в тераформе, запустил план, вышел. После этого твой коллега накидал свой код, выполнил план, вышел. далее тебе нужно зааплаить свою инфру, будут ли какие-то ошибки

- Ответ
  
  Нет, ведь при **terraform plan** файл tfstate не меняется, а только показывается как будет применяться новые изменения к текущей инфраструктуре. 

---

### У вас есть 20 серверов, созданных с помощью Terraform, но вы хотите удалить один из них. Можно ли уничтожить один ресурс из нескольких ресурсов без правки в самих файлах?

- Ответ

  Да можно с помощью команды terraform destroy и флага --target

  ```bash

  terraform destroy -target=aws_instance.my_instance
  
  ```
---

### Какие есть best practice для ухаживания за tfstate file?

- Ответ 

  - Хранить фалй удаленно, например в s3 backet, для обеспечения совместной работы 
    и безопасности.
  - Блокирования состояния на время применения инфраструктуры, для того что бы предотвратить конфликтов между изменениями.
  - Ограничения доступа. Доступ к стейт файлу доступ мог получить только авторизованный пользователь.
  - Настройка автоматических бэкапов, для того что бы не потерять состояние инфры 

---

### У вас есть несколько сред — dev, stage, prod для вашего приложения, и вы хотите использовать один и тот же код для всех этих сред. Как ты можешь это сделать?

- Ответ 

  Есть два вариант как это можно сделать.

  Через модули: 
  
  - Ты пишешь код инфраструктуры, в variable файл выносишь все нужные параметры, что бы их потом можно было заменить, в outputs файл выносишь все нужные выходные данные.

  - Создаешь рядом с папкой с модулем создаешь уже папку проекта с папками под каждое окружение. 
    В них уже создаешь условно файлик main.tf и в нем прописываешь блок кода module, и в коде проекта в среде прод этот блок кода может выглядить как:

    ```HCL
    
        module "vpc_prod" {
            source     = "../../modules/vpc_and_network"
            env        = "production"                                                
            cidr_block = "10.100.1.0/24"  
          
            publick_cidr_subntet = [
              "10.100.12.0/24",
              "10.100.13.0/24",
              "10.100.14.0/24",
            ]
            private_cidr_subnets = [
              "10.100.21.0/24",
              "10.100.22.0/24"
            ]
        }
       #так же это могут быть модули, которые хранятся удаленно
    
    ```
    
  Структура папок может выглядить вот так:

  ![not_best](./imgs/not_best_practice.png)

  Env по папкам это часто используется, но на деле это противоречит DRY. 
  Тут в качестве бест практис лучше иметь конфиги террагрунта под каждый env со своими переменными под окружени.
  
  Структура папок по бестпрактис может выглядить вот так:

  ![better](./imgs/folder_struct_best_practice.png)



  - Есть метод через workspace который почти нигде не используется.

  - Так же в качестве best practice разграничение по аккам используется, с точки зрения тф нужно будет деплоиться на разных акках

   В коде это будет выглядить как: 

  ```HCL

      provider "aws" {
          region = "eu-central-2"
        
        
          assume_role {
            role_arn     = "arn:aws:iam::1234567890:role/RemoteAdministrator"
            session_name = "terraform session"                                
    
      }

  ```

  На аккаунте на котором будет происходить деплой должна быть соответсвующая роль которая позволяет это делать, либо нужно вводить access_key и secret_key


---



## Рабочий процесс

### Что такое SLO, SLA, SLI?

- Ответ
  
  Кратко 
  **SLI** - непосредственно замеряемые метрики 
  **SLO** - то, к чему стремимся, чего хотим достичь
  **SLA** - о чем договорились, обязательства



  Для начала стоит отметить что все эти понятия взаимосвязаны.  
  

  - **SLA (Service Level Agreement)** - это соглашение\контракт\регламент между поставщиком услуг и конечным пользователем.
    И в рамках этого контракта оговаривается уровень доступности услуги на который можно рассчитывать.
    Также оговариваются обязательства и последствия их невыполнения.

    Примеры:  
    Если в течение месяца не выполнялись бэкапы, то компенсируется целиком стоимость этой услуги.  
    Если доступность виртуальных машин падает ниже n-% процентов, то компенсация в виде бонусных баллов за все часы простоя.  

  - **SLO (Service Level Objective)** - это как будет оцениваться качество сервиса. Каких показателей собираемся достигать.
    Иными словами это измеримая вещь, через призму которой можно понять что стоит отслеживать и улучшать. Уме  

    Примеры:
    Доступность виртуальных машин должна составлять 99,9% в месяц.   
    Время ответа api не должно превышать n-секунд\милисекунд.  
    Количество\коэффициент ошибок должен быть менее n-%  


  - **SLI (Sevice Level Indicator)** - это непосредственно собираемая конкретная характеристика, метрика.
    Сколько были доступны виртуальные машины за месяц? Какой процент ответа апи? Какое количество ошибок? 
    Всё, что может ответить на этот вопрос это всё про вот это.
    Эти значения могут быть усреднены, растянуты во времени, переведены в проценты.

    Примеры:
    Сбор метрик доступности главной страницы сайта. 

    Или еще пример - https://steamstat.us/  
    Страничка, показывающая доступны ли сервера Steam.
    Но здесь стоит сделать ремарку - компании сами замеряют SLI средствами мониторинга. 
    В данном случае это просто хороший наглядный пример. 


    Статьи, которые помогли в понимании сути:
    https://etogeek.dev/posts/sli-slo-sla/  
    https://uptimerobot.com/blog/sla-slo-sli/   
